<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-flash.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"github.nanfeng.ink","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":"ture"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="前言 本篇文章转载的GitHub上一个很火的项目 英文版本  Vim 语法 刚接触Vim时很容易被Vim许多复杂的命令吓到，如果你看到一个Vim的用户使用gUfV或1GdG，你可能不能立刻想到这些命令是在做什么。这一章中，我将把Vim命令的结构拆分成一个简单的语法规则进行讲解。  这一章将是本书中最重要的一章，一旦你理解了Vim命令的语法结构，你将能够和Vim”说话”。注意，在这一章中当我讨论Vi">
<meta property="og:type" content="article">
<meta property="og:title" content="聪明的学习Vim（上）">
<meta property="og:url" content="https://github.nanfeng.ink/2020/05/21/%E8%81%AA%E6%98%8E%E7%9A%84%E5%AD%A6%E4%B9%A0Vim%EF%BC%88%E4%B8%8A%EF%BC%89/index.html">
<meta property="og:site_name" content="西洲渡">
<meta property="og:description" content="前言 本篇文章转载的GitHub上一个很火的项目 英文版本  Vim 语法 刚接触Vim时很容易被Vim许多复杂的命令吓到，如果你看到一个Vim的用户使用gUfV或1GdG，你可能不能立刻想到这些命令是在做什么。这一章中，我将把Vim命令的结构拆分成一个简单的语法规则进行讲解。  这一章将是本书中最重要的一章，一旦你理解了Vim命令的语法结构，你将能够和Vim”说话”。注意，在这一章中当我讨论Vi">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://licensebuttons.net/l/by-nc-sa/4.0/88x31.png#id=ldrA8&originHeight=31&originWidth=88&originalType=binary&status=done&style=none">
<meta property="article:published_time" content="2020-05-21T01:58:58.000Z">
<meta property="article:modified_time" content="2023-04-18T05:14:06.028Z">
<meta property="article:author" content="南风">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="Vim">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://licensebuttons.net/l/by-nc-sa/4.0/88x31.png#id=ldrA8&originHeight=31&originWidth=88&originalType=binary&status=done&style=none">

<link rel="canonical" href="https://github.nanfeng.ink/2020/05/21/%E8%81%AA%E6%98%8E%E7%9A%84%E5%AD%A6%E4%B9%A0Vim%EF%BC%88%E4%B8%8A%EF%BC%89/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>聪明的学习Vim（上） | 西洲渡</title>
  


  <script data-pjax>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?1ecc71e997f35d4936f80db0f307d20a";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>



</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">西洲渡</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">一只还没迈入IC领域的小菜鸡</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">31</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">15</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">44</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.nanfeng.ink/2020/05/21/%E8%81%AA%E6%98%8E%E7%9A%84%E5%AD%A6%E4%B9%A0Vim%EF%BC%88%E4%B8%8A%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="南风">
      <meta itemprop="description" content="陌上人如玉，公子世无双">
    </span>
	<meta name="referrer" content="no-referrer" />
    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="西洲渡">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          聪明的学习Vim（上）
        </h1>

        <div class="post-meta">



			
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-21 09:58:58" itemprop="dateCreated datePublished" datetime="2020-05-21T09:58:58+08:00">2020-05-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7%E7%AF%87/" itemprop="url" rel="index"><span itemprop="name">工具篇</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇文章转载的GitHub上一个很火的项目<br><a target="_blank" rel="noopener" href="https://github.com/iggredible/Learn-Vim">英文版本</a></p>
<h1 id="Vim-语法"><a href="#Vim-语法" class="headerlink" title="Vim 语法"></a>Vim 语法</h1><p>刚接触Vim时很容易被Vim许多复杂的命令吓到，如果你看到一个Vim的用户使用<code>gUfV</code>或<code>1GdG</code>，你可能不能立刻想到这些命令是在做什么。这一章中，我将把Vim命令的结构拆分成一个简单的语法规则进行讲解。</p>
<p>这一章将是本书中最重要的一章，一旦你理解了Vim命令的语法结构，你将能够和Vim”说话”。注意，在这一章中当我讨论Vim语言时，我讨论并不是<br>Vimscript(Vim自带的插件编写和自定义设置的语言)，这里我讨论的是Vim中normal模式的下的命令的通用规则。</p>
<h2 id="如何学习一门语言"><a href="#如何学习一门语言" class="headerlink" title="如何学习一门语言"></a>如何学习一门语言</h2><p>我并不是一个英语为母语的人，当我13岁移民到美国时我学习的英语，我会通过做三件事情建立我的语言能力：</p>
<ol>
<li>学习语法规则</li>
<li>扩展我的词汇量</li>
<li>练习，练习，练习</li>
</ol>
<p>同样的，为了说好Vim语言，你需要学习语法规则，增加词汇量，并且不断练习直到你可以把执行命令变成肌肉记忆。</p>
<h2 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h2><p>你只需要知道一个Vim语言的语法规则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">verb + noun # 动词 + 名词</span><br></pre></td></tr></table></figure>


<p>这就类似与在英语中的祈使句：</p>
<ul>
<li>Eat(verb) a donut(noun)</li>
<li>Kick(verb) a ball(noun)</li>
<li>Learn(verb) the Vim Editor(noun)</li>
</ul>
<p>现在你需要的就是用Vim中基本的动词和名字来建立你的词汇表</p>
<h2 id="词汇表"><a href="#词汇表" class="headerlink" title="词汇表"></a>词汇表</h2><h3 id="名词-动作-Motion"><a href="#名词-动作-Motion" class="headerlink" title="名词(动作 Motion)"></a>名词(动作 Motion)</h3><p>我们这里将<strong>动作</strong>作为名词，<strong>动作</strong>用来在Vim中到处移动，他们也是Vim中的名词。下面列出了一些常见的<strong>动作</strong>的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">h	左</span><br><span class="line">j	下</span><br><span class="line">k	上</span><br><span class="line">l	右</span><br><span class="line">w	向前移动到下一个单词的开头</span><br><span class="line">&#125;	跳转到下一个段落</span><br><span class="line">$	跳转到当前行的末尾</span><br></pre></td></tr></table></figure>


<p>在之后的章节你将学习更多的关于<strong>动作</strong>的内容，所以如果你不理解上面这些<strong>动作</strong>也不必担心。</p>
<h3 id="动词-操作符-Operator"><a href="#动词-操作符-Operator" class="headerlink" title="动词(操作符 Operator)"></a>动词(操作符 Operator)</h3><p>根据<code>:h operator</code>，Vim共有16个<strong>操作符</strong>，然而根据我的经验，学习这3个<strong>操作符</strong>在80%的情况下就已经够用了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y	yank(复制)</span><br><span class="line">d	delete(删除)</span><br><span class="line">c	change 删除文本，将删除的文本存到寄存器中，进入插入模式</span><br></pre></td></tr></table></figure>


<p>现在你已经知道了基本的动词和名词，我们来用一下我们的语法规则。假设你有下面这段文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const learn = &quot;Vim&quot;;</span><br></pre></td></tr></table></figure>


<ul>
<li>复制当前位置到行尾的所有内容：<code>y$</code></li>
<li>删除当前位置到下一个单词的开头：<code>dw</code></li>
<li>修改当前位置到这个段落的结尾：<code>c&#125;</code></li>
</ul>
<p><strong>动作</strong>也接受数字作为参数(这个部分我将在下个章节展开)，如果你需要向上移动3行，你可以用<code>3k</code>代替按3次<code>k</code></p>
<ul>
<li>向左拷贝2个字符：<code>y2h</code></li>
<li>删除后两个单词：<code>d2w</code></li>
<li>修改后面两行：<code>c2j</code></li>
</ul>
<p>目前，你也许需要想很久才能完成一个简单的命令，不过我刚开始时也是这样，我也经历过类似的挣扎的阶段但是不久我的速度就快了起来，你也一样。</p>
<p>作为补充，行级的<strong>操作符</strong>在文本编辑中和其他的<strong>操作符</strong>一样，Vim允许你通过按两次命令执行行级的操作，例如<code>dd</code>，<code>yy</code>，<code>cc</code>来执行删除，复制或修改整个行。</p>
<p>我希望这些内容能够对你有用，但是到目前为止还没有结束，Vim有另一种类型的名词：文本对象(text object)</p>
<h2 id="更多名词-文本对象"><a href="#更多名词-文本对象" class="headerlink" title="更多名词(文本对象)"></a>更多名词(文本对象)</h2><p>想象一下你现在正在某个被括号包围的文本中例如<code>(hello Vim)</code>，你现在想要删掉括号中的所有内容，你会怎样快速的完成它？是否有一种方法能够把括号中内容作为整体删除呢？</p>
<p>答案是有的。文本通常是结构化的，特别是代码经常被放置在小括号、中括号、大括号、引号等当中。Vim提供了一种处理这种结构的文本对象的方法。</p>
<p>文本对象可以被<strong>操作符</strong>使用，这里有两类文本对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i + object  内部文本对象</span><br><span class="line">a + object  外部文本对象</span><br></pre></td></tr></table></figure>


<p><strong>内部文本对象</strong>选中的部分不包含包围文本对象的空白或括号等，<strong>外部文本对象</strong>则包括了包围内容的空白或括号等对象。外部对象总是比内部对象选中的内容更多，因此如果你的光标位于一对括号内部，例如<code>(hello Vim)</code>中：</p>
<ul>
<li>删除括号内部的内容但保留括号：<code>di(</code></li>
<li>删除括号以及内部的内容：<code>da(</code></li>
</ul>
<p>让我们看一些别的例子，假设你有这样一段Javascript的函数，你的光标停留在”Hello”上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const hello = function() &#123;</span><br><span class="line">    console.log(&quot;Hello Vim&quot;);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>删除整个”Hello Vim”：<code>di(</code></li>
<li>删除整个函数(被{}包含)：<code>di&#123;</code></li>
<li>删除”Hello”这个词：<code>diw</code></li>
</ul>
<p>文本对象很强大因为你可以在一个位置指向不同的对象，能够删除一对括号、函数体或整个单词的文本对象中的内容。此外，当你看到<code>di(</code>，<code>di&#123;</code>和<code>diw</code>时，你也可以很好的意识到他们表示的是什么。</p>
<p>让我们来看最后一个例子。假设你有这样一些html的标签的文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;h1&gt;Header1&lt;/h1&gt;</span><br><span class="line">  &lt;p&gt;Paragraph1&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Paragraph2&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>


<p>如果你的光标位于”Header1”文本上：</p>
<ul>
<li>删除”Header1”：<code>dit</code></li>
<li>删除<code>&lt;h1&gt;Header1&lt;/h1&gt;</code>：<code>dat</code></li>
</ul>
<p>如果你的光标在”div”文本上：</p>
<ul>
<li>删除<code>h1</code>和所有<code>p</code>标签的行：<code>dit</code></li>
<li>删除所有文本：<code>dat</code></li>
<li>删除”div”：<code>di&lt;</code></li>
</ul>
<p>下面列举的一些通常见到的文本对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">w     一个单词</span><br><span class="line">p     一个段落</span><br><span class="line">s     一个句子</span><br><span class="line">(或)  一对()</span><br><span class="line">&#123;或&#125;  一对&#123;&#125;</span><br><span class="line">[或]  一对[]</span><br><span class="line">&lt;或&gt;  一对&lt;&gt;</span><br><span class="line">t     XML标签</span><br><span class="line">&quot;     一对&quot;&quot;</span><br><span class="line">&#x27;     一对&#x27;&#x27;</span><br><span class="line">`     一对``</span><br></pre></td></tr></table></figure>


<p>你可以通过<code>:h text-objects</code>了解更多</p>
<h2 id="结合性和语法"><a href="#结合性和语法" class="headerlink" title="结合性和语法"></a>结合性和语法</h2><p>在学习Vim的语法之后，让我们来讨论一下Vim中的结合性以及为什么在文本编辑器中这是一个强大的功能。</p>
<p>结合性意味着你有很多可以组合起来完成更复杂命令的普通命令，就像你在编程中可以通过一些简单的抽象建立更复杂的抽象，在Vim中你可以通过简单的命令的组合执行更复杂的命令。Vim语法正是Vim中命令的可结合性的体现。</p>
<p>Vim的结合性最强大之处体现在它和外部程序结合时，Vim有一个<strong>过滤操作符</strong><code>!</code>可以用外部程序过滤我们的文本。假设你有下面这段混乱的文本并且你想把它用tab格式化的更好看的一些：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Id|Name|Cuteness</span><br><span class="line">01|Puppy|Very</span><br><span class="line">02|Kitten|Ok</span><br><span class="line">03|Bunny|Ok</span><br></pre></td></tr></table></figure>


<p>这件事情通过Vim命令不太容易完成，但是你可以通过终端提供的命令<code>column</code>很快的完成它，当你的光标位于”Id”上时，运行<code>!&#125;column -t -s &quot;|&quot;</code>，你的文本就变得整齐了许多：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Id  Name    Cuteness</span><br><span class="line">01  Puppy   Very</span><br><span class="line">02  Kitten  Ok</span><br><span class="line">03  Bunny   Ok</span><br></pre></td></tr></table></figure>


<p>让我们分解一下上面那条命令，动词是<code>!</code>(<strong>过滤操作符</strong>)，名词是<code>&#125;</code>(到下一个段落)。<strong>过滤操作符</strong><code>!</code>接受终端命令作为另一个参数，因此我把<code>column -t -s &quot;|&quot;</code>传给它。我不想详细描述<code>column</code>是如何工作的，但是总之它格式化了文本。</p>
<p>假设你不止想格式化你的文本，还想只展示<code>Ok</code>结尾的行，你知道<code>awk</code>命令可以做这件事情，那么你可以这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!&#125;column -t -s &quot;|&quot; | awk &#x27;NR &gt; 1 &amp;&amp; /Ok/&#123;print $0&#125;&#x27;</span><br></pre></td></tr></table></figure>


<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">02  Kitten  Ok</span><br><span class="line">03  Bunny   Ok</span><br></pre></td></tr></table></figure>


<p>666！管道竟然在Vim中也能起作用。</p>
<p>这就是Vim的结合性的强大之处。你知道的<strong>操作符</strong>，<strong>动作</strong>，终端命令越多，你组建复杂操作的能力成倍增长。</p>
<p>换句话说，假设你只知道四个<strong>动作</strong>：<code>w, $, &#125;, G</code>和删除操作符(<code>d</code>)，你可以做8件事：按四种方式移动(<code>w, $, &#125;, G</code>)和删除4种文本对象(<code>dw, d$, d&#125;, dG</code>)。如果有一天你学习了小写变大写的<strong>操作符</strong>(<code>gU</code>)，你的Vim工具箱中多的不是1种工具，而是4种：<code>gUw, gU$, gU&#125;, gUG</code>。现在你的Vim工具箱中就有12种工具了。如果你知道10个<strong>动作</strong>和5个<strong>操作符</strong>，那么你就有60种工具(50个操作+10个移动)。另外，行号动作(<code>nG</code>)给你了<code>n</code>种<strong>动作</strong>，其中<code>n</code>是你文件中的行数(例如前往第5行，<code>5G</code>)。搜索动作(<code>/</code>)实际上给你带来无限数量的<strong>动作</strong>因为你可以搜索任何内容。你知道多少终端命令，外部命令操作符(<code>!</code>)就给你了多少种过滤工具。使用Vim这种能够组合的工具，所有你知道的东西都可以被串起来完成更复杂的操作。你知道的越多，你就越强大。</p>
<p>这种具有结合性的行为也正符合Unix的哲学：_一个命令做好一件事_。<strong>动作</strong>只需要做一件事：前往X。<strong>操作符</strong>只需要做一件事：完成Y。通过结合一个<strong>操作符</strong>和一个<strong>动作</strong>，你就获得了YX：在X上完成Y。</p>
<p>甚至，<strong>动作</strong>和<strong>操作符</strong>都是可拓展的，你可以自己创造<strong>动作</strong>和<strong>操作符</strong>去丰富你的Vim工具箱，<code>Vim-textobj-user</code>有一系列自定义的文本对象。</p>
<p>另外，如果你不知道我刚才使用的<code>column</code>和<code>awk</code>命令也没有关系，重要的是Vim可以和终端命令很好的结合起来。</p>
<h2 id="聪明地学习语法"><a href="#聪明地学习语法" class="headerlink" title="聪明地学习语法"></a>聪明地学习语法</h2><p>你刚刚学完Vim唯一的语法规则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">verb + noun</span><br></pre></td></tr></table></figure>


<p>我学Vim中最大的”AHA moment”之一是当我刚学完大写命令(<code>gU</code>)时，想要把一个单词变成大写，我本能的运行了<code>gUiW</code>，它居然成功了，我光标所在的单词都大写了。我正是从那是开始理解Vim的。我希望你也会在不久之后有你自己的”AHA moment”，如果之前没有的话。</p>
<p>这一章的目标是向你展现Vim中的<code>verb+noun</code>模式，因此之后你就可以像学习一门新的语言一样渐进的学习Vim而不是死记每个命令的组合。</p>
<p>学习这种模式并且理解其中的含义，这是聪明的学习方式。</p>
<h1 id="在文件中移动"><a href="#在文件中移动" class="headerlink" title="在文件中移动"></a>在文件中移动</h1><p>一开始，通过键盘移动会让你感觉特别慢特别不自在，但是不要放弃！一旦你习惯了它，比起鼠标你可以更快的在文件中去到任何地方。</p>
<p>这一章，你将学习必要的移动以及如何高效的使用它们。 记住，这一章所讲的并不是Vim的全部移动命令，我们的目标是介绍有用的移动来快速提高效率。 如果你需要学习更多的移动命令，查看<code>:h motion.txt</code>。</p>
<h2 id="字符导航"><a href="#字符导航" class="headerlink" title="字符导航"></a>字符导航</h2><p>最基本的移动单元是上下左右移动一个字符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">h   左</span><br><span class="line">j   下</span><br><span class="line">k   上</span><br><span class="line">l   右</span><br></pre></td></tr></table></figure>


<p>你也可以通过方向键进行移动，如果你只是初学者，使用任何你觉得最舒服的方法都没有关系。</p>
<p>我更喜欢<code>hjkl</code>因为我的右手可以保持在键盘上的默认姿势，这样做可以让我更快的敲到周围的键。 为了习惯它，我实际上在刚开始的时候通过<code>~/.vimrc</code>关闭了方向键：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">noremap &lt;Up&gt; &lt;NOP&gt;</span><br><span class="line">noremap &lt;Down&gt; &lt;NOP&gt;</span><br><span class="line">noremap &lt;Left&gt; &lt;NOP&gt;</span><br><span class="line">noremap &lt;Right&gt; &lt;NOP&gt;</span><br></pre></td></tr></table></figure>


<p>也有一些插件可以帮助改掉这个坏习惯，其中有一个叫<a target="_blank" rel="noopener" href="https://github.com/takac/vim-hardtime">vim-hardtime</a>。 让我感到惊讶的是，我只用了几天就习惯了使用<code>hjkl</code>。</p>
<p>另外，如果你想知道为什么Vim使用<code>hjkl</code>进行移动，_这实际上是因为Bill Joy写VI用的Lear-Siegler ADM-3A终端没有方向键，而是把当做方向键_。</p>
<p>如果你想移动到附近的某个地方，比如从一个单词的一个部分移动到另一个部分，我会使用<code>h</code>和<code>l</code>。 如果我需要在可见的范围内上下移动几行，我会使用<code>j</code>和<code>k</code>。 如果我想去更远的地方，我倾向于使用其他移动命令。</p>
<h2 id="相对行号"><a href="#相对行号" class="headerlink" title="相对行号"></a>相对行号</h2><p>我觉得设置<code>number</code>和<code>relativenumber</code>非常有用，你可以在<code>~/.vimrc</code>中设置:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set relativenumber number</span><br></pre></td></tr></table></figure>


<p>这将会展示当前行号和其他行相对当前行的行号。</p>
<p>为什么这个功能有用呢？这个功能能够帮助我知道我离我的目标位置差了多少行，有了它我可以很轻松的知道我的目标行在我下方12行，因此我可以使用<code>12j</code>去前往。 否则，如果我在69行，我的目标是81行，我需要去计算81-69=12行，这太费劲了，当我需要去一个地方时，我需要思考的部分越少越好。</p>
<p>这是一个100%的个人偏好，你可以尝试<code>relativenumber</code>/<code>norelativenumber</code>，<code>number</code>/<code>nonumber</code> 然后选择自己觉得最有用的。</p>
<h2 id="对移动计数"><a href="#对移动计数" class="headerlink" title="对移动计数"></a>对移动计数</h2><p>在继续之前，让我们讨论一下”计数”参数。 一个移动可以接受一个数字前缀作为参数，上面我提到的你可以通过<code>12j</code>向下移动12行，其中<code>12j</code>中的<code>12</code>就是计数数字。</p>
<p>你使用带计数的移动的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[计数] + 移动</span><br></pre></td></tr></table></figure>


<p>你可以把这个应用到所有移动上，如果你想向右移动9个字符，你可以使用<code>9l</code>来代替按9次<code>l</code>。 当你学到了更多的动作时，你都可以试试给定计数参数。</p>
<h2 id="单词导航"><a href="#单词导航" class="headerlink" title="单词导航"></a>单词导航</h2><p>我们现在移动一个更长的单元：单词(word)。 你可以通过<code>w</code>移动到下一个单词的开始，通过<code>e</code>移动到下一个单词的结尾，通过<code>b</code>移动到上一个单词的开始，通过<code>ge</code>移动到前一个单词的结尾。</p>
<p>另外，为了和上面说的单词(word)做个区分，还有一种移动的单元：词组(WORD)。 你可以通过<code>W</code>移动到下一个词组的开始，通过<code>E</code>移动到下一个词组的结尾，通过<code>B</code>移动到前一个词组的开头，通过<code>gE</code>移动到前一个词组的结尾。 为了方便记忆，所以我们选择了词组和单词这两个词，相似但有些区分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">w		移动到下一个单词的开头</span><br><span class="line">W		移动到下一个词组的开头</span><br><span class="line">e		移动到下一个单词的结尾</span><br><span class="line">E		移动到下一个词组的结尾</span><br><span class="line">b		移动到前一个单词的开头</span><br><span class="line">B		移动到前一个词组的开头</span><br><span class="line">ge	移动到前一个单词的结尾</span><br><span class="line">gE	移动到前一个词组的结尾</span><br></pre></td></tr></table></figure>


<p>词组和单词到底有什么相同和不同呢？单词和词组都按照非空字符被分割，一个单词指的是一个只包含<code>a-zA-Z0-9</code>字符串，一个词组指的是一个包含除了空字符(包括空格，tab，EOL)以外的字符的字符串。 你可以通过<code>:h word</code>和<code>:h WORD</code>了解更多。</p>
<p>例如，假如你有下面这段内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const hello = &quot;world&quot;;</span><br></pre></td></tr></table></figure>


<p>当你光标位于这行的开头时，你可以通过<code>l</code>走到行尾，但是你需要按21下，使用<code>w</code>，你需要6下，使用<code>W</code>只需要4下。 单词和词组都是短距离移动的很好的选择。</p>
<p>然而，之后你可以通过当前行导航只按一次从<code>c</code>移动到<code>;</code>。</p>
<h2 id="当前行导航"><a href="#当前行导航" class="headerlink" title="当前行导航"></a>当前行导航</h2><p>当你在进行编辑的时候，你经常需要水平地在一行中移动，你可以通过<code>0</code>跳到本行第一个字符，通过<code>$</code>跳到本行最后一个字符。 另外，你可以使用<code>^</code>跳到本行第一个非空字符，通过<code>g_</code>跳到本行最后一个非空字符。 如果你想去当前行的第n列，你可以使用<code>n|</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0		跳到本行第一个字符</span><br><span class="line">^		跳到本行第一个非空字符</span><br><span class="line">g_  跳到本行最后一个非空字符</span><br><span class="line">$		跳到本行最后一个字符</span><br><span class="line">n|  跳到本行第n列</span><br></pre></td></tr></table></figure>


<p>你也可以在本行通过<code>f</code>和<code>t</code>进行行内搜索，<code>f</code>和<code>t</code>的区别在于<code>f</code>会停在第一个匹配的字母上，<code>t</code>会停在第一个匹配的字母前。 因此如果你想要搜索并停留在”h”上，使用<code>fh</code>。 如果你想搜索第一个”h”并停留在它的前一个字母上，可以使用<code>th</code>。 如果你想去下一个行内匹配的位置，使用<code>;</code>，如果你想去前一个行内匹配的位置，使用<code>,</code>。</p>
<p>如果想向前搜索”h”，可以使用<code>Fh</code>，使用<code>;</code>，保持相同的搜索方向搜索下一个匹配的字母。 注意，<code>;</code>不是总是向后搜索，<code>;</code>表示的是上一次搜索的方向，因此如果你使用的<code>F</code>，那么使用<code>;</code>时将会向前搜索使用<code>,</code>时向后搜索。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f   在同一行向后搜索第一个匹配</span><br><span class="line">F   在同一行向前搜索第一个匹配</span><br><span class="line">t   在同一行向后搜索第一个匹配，并停在匹配前</span><br><span class="line">T   在同一行向前搜索第一个匹配，并停在匹配前</span><br><span class="line">;   在同一行重复最近一次搜索</span><br><span class="line">,   在同一行向相反方向重复最近一次搜索</span><br></pre></td></tr></table></figure>


<p>回到上一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const hello = &quot;world&quot;;</span><br></pre></td></tr></table></figure>


<p>当你的光标位于行的开头时，你可以通过按一次键<code>$</code>去往行尾的最后一个字符”;”。 如果想去往”world”中的”w”，你可以使用<code>fw</code>。 一个建议是，在行内目标附近通过寻找重复出现最少的字母例如”j”，”x”，”z”来前往行中的该位置更快。</p>
<h2 id="句子和段落导航"><a href="#句子和段落导航" class="headerlink" title="句子和段落导航"></a>句子和段落导航</h2><p>接下来两个移动的单元是句子和段落。</p>
<p>首先我们来聊聊句子。 一个句子的定义是以<code>.!?</code>和跟着的一个换行符或空格，tab结尾的。 你可以通过<code>)</code>和<code>(</code>跳到下一个和上一个句子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(   跳到前一个句子</span><br><span class="line">)   跳到下一个句子</span><br></pre></td></tr></table></figure>


<p>让我们来看一些例子，你觉得哪些字段是句子哪些不是? 可以尝试在Vim中用<code>(</code>和<code>)</code>感受一下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I am a sentence. I am another sentence because I end with a period. I am still a sentence when ending with an exclamation point! What about question mark? I am not quite a sentence because of the hyphen - and neither semicolon ; nor colon :</span><br><span class="line"></span><br><span class="line">There is an empty line above me.</span><br></pre></td></tr></table></figure>


<p>另外，如果你的Vim中遇到了无法将一个以<code>.</code>结尾的字段并且后面跟着一个空行的这种情况判断为一个句子的问题，你可能处于<code>compatible</code>的模式。 运行<code>:set nocompatible</code>可以修复。 在Vi中，一个句子是以<strong>两个</strong>空格结尾的，你应该总是保持的<code>nocompatible</code>的设置。</p>
<p>接下来，我们将讨论什么是段落。 一个段落可以从一个空行之后开始，也可以从段落选项中字符对所指定的段落宏的每个集合开始。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;   跳转到上一个段落</span><br><span class="line">&#125;   跳转到下一个段落</span><br></pre></td></tr></table></figure>


<p>如果你不知道什么是段落宏，不用担心，重要的是一个段落总是以一个空行开始和结尾， 在大多数时候总是对的。</p>
<p>我们来看这个例子。 你可以尝试着使用<code>&#125;</code>和<code>&#123;</code>进行导航，也可以试一试<code>()</code>这样的句子导航。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Hello. How are you? I am great, thanks!</span><br><span class="line">Vim is awesome.</span><br><span class="line">It may not easy to learn it at first...- but we are in this together. Good luck!</span><br><span class="line"></span><br><span class="line">Hello again.</span><br><span class="line"></span><br><span class="line">Try to move around with ), (, &#125;, and &#123;. Feel how they work.</span><br><span class="line">You got this.</span><br></pre></td></tr></table></figure>


<p>你可以通过<code>:h setence</code>和<code>:h paragraph</code>了解更多。</p>
<h2 id="匹配导航"><a href="#匹配导航" class="headerlink" title="匹配导航"></a>匹配导航</h2><p>程序员经常编辑含有代码的文件，这种文件内容会包含大量的小括号，中括号和大括号，并且可能会把你搞迷糊你当前到底在哪对括号里。 许多编程语言都用到了小括号，中括号和大括号，你可能会迷失于其中。 如果你在它们中的某一对括号中，你可以通过<code>%</code>跳到其中一个括号或另一个上(如果存在)。 你也可以通过这种方法弄清你是否各个括号都成对匹配了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%    Navigate to another match, usually works for (), [], &#123;&#125;</span><br></pre></td></tr></table></figure>


<p>我们来看一段Scheme代码示例因为它用了大量的小括号。 你可以在括号中用<code>%</code>移动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(define (fib n)</span><br><span class="line">  (cond ((= n 0) 0)</span><br><span class="line">        ((= n 1) 1)</span><br><span class="line">        (else</span><br><span class="line">          (+ (fib (- n 1)) (fib (- n 2)))</span><br><span class="line">        )))</span><br></pre></td></tr></table></figure>


<p>我个人喜欢使用类似<a target="_blank" rel="noopener" href="https://github.com/frazrepo/vim-rainbow">vim-rainbow</a>这样的可视化指示插件来作为<code>%</code>的补充。 通过<code>:h %</code>了解更多。</p>
<h2 id="行号导航"><a href="#行号导航" class="headerlink" title="行号导航"></a>行号导航</h2><p>你可以通过<code>nG</code>调到行号为<code>n</code>的行，例如如果你想跳到第7行，你可以使用<code>7G</code>，跳到第一行使用<code>gg</code>或<code>1G</code>，跳到最后一行使用<code>G</code>。</p>
<p>有时你不知道你想去的位置的具体行号，但是知道它大概在整个文件的70%左右的位置，你可以使用<code>70%</code>跳过去，可以使用<code>50%</code>跳到文件的中间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gg      跳转到第一行</span><br><span class="line">G       跳转到最后一行</span><br><span class="line">nG      跳转到第n行</span><br><span class="line">n%      跳到文件的n%</span><br></pre></td></tr></table></figure>


<p>另外，如果你想看文件总行数，可以用<code>CTRL-g</code>查看。</p>
<h2 id="窗格导航"><a href="#窗格导航" class="headerlink" title="窗格导航"></a>窗格导航</h2><p>为了移动到当前窗格的顶部，中间，底部，你可以使用<code>H</code>，<code>M</code>和<code>L</code>。</p>
<p>你也可以给<code>H</code>和<code>L</code>传一个数字前缀。 如果你输入<code>10H</code>你会跳转到窗格顶部往下数10行的位置，如果你输入<code>3L</code>，你会跳转到距离当前窗格的底部一行向上数3行的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">H   跳转到屏幕的顶部</span><br><span class="line">M   跳转到屏幕的中间</span><br><span class="line">L   跳转到屏幕的底部</span><br><span class="line">nH  跳转到距离顶部n行的位置</span><br><span class="line">nL  跳转到距离底部n行的位置</span><br></pre></td></tr></table></figure>


<h2 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h2><p>在文件中滚动，你有三种速度可以选择： 滚动一整页(<code>CTRL-F</code>/<code>CTRL-B</code>)，滚动半页(<code>CTRL-D</code>/<code>CTRL-U</code>)，滚动一行<code>CTRL-E</code>/<code>CTRL-Y</code>)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-e    向下滚动一行</span><br><span class="line">Ctrl-d    向下滚动半屏</span><br><span class="line">Ctrl-f    向下滚动一屏</span><br><span class="line">Ctrl-y    向上滚动一行</span><br><span class="line">Ctrl-u    向上滚动半屏</span><br><span class="line">Ctrl-b    向上滚动一屏</span><br></pre></td></tr></table></figure>


<p>你也可以相对当前行进行滚动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zt    将当前行置于屏幕顶部附近</span><br><span class="line">zz    将当前行置于屏幕中央</span><br><span class="line">zb    将当前行置于屏幕底部</span><br></pre></td></tr></table></figure>


<h2 id="搜索导航"><a href="#搜索导航" class="headerlink" title="搜索导航"></a>搜索导航</h2><p>通常，你已经知道这个文件中有一个字段，你可以通过搜索导航非常快速的定位你的目标。 你可以通过<code>/</code>向下搜索，也可以通过<code>?</code>向上搜索一个字段。 你可以通过<code>n</code>重复最近一次搜索，<code>N</code>向反方向重复最近一次搜索。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/   向后搜索一个匹配</span><br><span class="line">?   向前搜素一个匹配</span><br><span class="line">n   重复上一次搜索(和上一次方向相同)</span><br><span class="line">N   重复上一次搜索(和上一次方向相反)</span><br></pre></td></tr></table></figure>


<p>假设你有一下文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let one = 1;</span><br><span class="line">let two = 2;</span><br><span class="line">one = &quot;01&quot;;</span><br><span class="line">one = &quot;one&quot;;</span><br><span class="line">let onetwo = 12;</span><br></pre></td></tr></table></figure>


<p>你可以通过<code>/let</code>搜索”let”，然后通过<code>n</code>快速的重复搜索下一个”let”，如果需要向相反方向搜索，可以使用<code>N</code>。 如果你用<code>?let</code>搜索，会得到一个向前的搜索，这时你使用<code>n</code>，它会继续向前搜索，就和<code>?</code>的方向一致。(<code>N</code>将会向后搜索”let”)。</p>
<p>你可以通过<code>:set hlsearch</code>设置搜索高亮。 这样，当你搜索<code>/let</code>，它将高亮文件中所有匹配的字段。 另外，如果你通过<code>:set incsearch</code>设置了增量搜索，它将在你输入时不断匹配的输入的内容。 默认情况下，匹配的字段会一直高亮到你搜索另一个字段，这有时候很烦人，如果你希望取消高亮，可以使用<code>:nohlsearch</code>。 因为我经常使用这个功能，所以我会设置一个映射：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nnoremap &lt;esc&gt;&lt;esc&gt; :noh&lt;return&gt;&lt;esc&gt;</span><br></pre></td></tr></table></figure>


<p>你可以通过<code>*</code>快速的向下搜索光标下的文本，通过<code>#</code>快速向前搜索光标下的文本。 如果你的光标位于一个字符串”one”上，按下<code>*</code>相当于<code>/\&lt;one\&gt;</code>。<br><code>/\&lt;one\&gt;</code>中的<code>\&lt;</code>和<code>\&gt;</code>表示整词匹配，使得一个更长的包含”one”的单词不会被匹配上，也就是说它会匹配”one”，但不会匹配”onetwo”。 如果你的光标在”one”上并且你想向后搜索完全或部分匹配的单词，例如”one”和”onetwo”，你可以用<code>g*</code>替代<code>*</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*   向后查找光标所在的完整单词</span><br><span class="line">#   向前查找光标所在的完整单词</span><br><span class="line">g*  向后搜索光标所在的单词</span><br><span class="line">g#  向前搜索光标所在的单词</span><br></pre></td></tr></table></figure>


<h2 id="位置标记"><a href="#位置标记" class="headerlink" title="位置标记"></a>位置标记</h2><p>你可以通过标记保存当前位置并在之后回到这个位置，就像文本编辑中的书签。 你可以通过<code>mx</code>设置一个标记，其中<code>x</code>可以是<code>a-zA-Z</code>。 有两种办法能回到标记的位置： 用``x<code>精确回到(行和列)，或者用</code>‘x`回到行级位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ma    用a标签标记一个位置</span><br><span class="line">`a    精确回到a标签的位置(行和列)</span><br><span class="line">&#x27;a    跳转到a标签的行</span><br></pre></td></tr></table></figure>


<p><code>a-z</code>的标签和<code>A-Z</code>的标签存在一个区别，小写字母是局部标签，大写字母是全局标签(也称文件标记)。</p>
<p>我们首先说说局部标记。 每个buffer可以有自己的一套局部标记，如果打开了两个文件，我可以在第一个文件中设置标记”a”(<code>ma</code>)，然后在另一个文件中设置另一个标记”a”(<code>ma</code>)。</p>
<p>不像你可以在每个buffer中设置一套局部标签，你只能设置一套全局标签。 如果你在<code>myFile.txt</code>中设置了标签<code>mA</code>，下一次你在另一个文件中设置<code>mA</code>时，A标签的位置会被覆盖。 全局标签有一个好处就是，即使你在不同的项目红，你也可以跳转到任何一个全局标签上，全局标签可以帮助你在文件间切换。</p>
<p>使用<code>:marks</code>查看所有标签，你也许会注意到除了<code>a-zA-Z</code>以外还有别的标签，其中有一些例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;   在当前buffer中跳转回到上一次跳转前的最后一行</span><br><span class="line">``  在当前buffer中跳转回到上一次跳转前的最后一个位置</span><br><span class="line">`[  跳转到上一次修改或拷贝的文本的开头</span><br><span class="line">`]  跳转到上一次修改或拷贝的文本的结尾</span><br><span class="line">`&lt;  跳转到最近一次可视模式下选择的部分的开头</span><br><span class="line">`&gt;  跳转到最近一次可视模式下选择的部分的结尾</span><br><span class="line">`0  跳转到退出Vim前编辑的最后一个文件</span><br></pre></td></tr></table></figure>


<p>除了上面列举的，还有更多标记，我不会在这一一列举因为我觉得它们很少用到，不过如果你很好奇，你可以通过<code>: marks</code>查看。</p>
<h2 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h2><p>最后，我们聊聊Vim中的跳转你通过任意的移动可以在不同文件中或者同一个的文件的不同部分间跳转。 然而并不是所有的移动都被认为是一个跳转。 使用<code>j</code>向下移动一行就不被看做一个跳转，即使你使用<code>10j</code>向下移动10行，也不是一个跳转。 但是你通过<code>10G</code>去往第10行被算作一个跳转。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x27;   跳转到标记的行</span><br><span class="line">`   跳转到标记的位置(行和列)</span><br><span class="line">G   跳转到行</span><br><span class="line">/   向后搜索</span><br><span class="line">?   向前搜索</span><br><span class="line">n   重复上一次搜索，相同方向</span><br><span class="line">N   重复上一次搜索，相反方向</span><br><span class="line">%   查找匹配</span><br><span class="line">(   跳转上一个句子</span><br><span class="line">)   跳转下一个句子</span><br><span class="line">&#123;   跳转上一个段落</span><br><span class="line">&#125;   跳转下一个段落</span><br><span class="line">L   跳转到当前屏幕的最后一行</span><br><span class="line">M   跳转到当前屏幕的中间</span><br><span class="line">H   跳转到当前屏幕的第一行</span><br><span class="line">[[  跳转到上一个小节</span><br><span class="line">]]  跳转到下一个小节</span><br><span class="line">:s  替换</span><br><span class="line">:tag  跳转到tag定义</span><br></pre></td></tr></table></figure>


<p>我不建议你把上面这个列表记下来，一个大致的规则是，任何大于一个单词或超过当前行导航的移动都可能是一个跳转。 Vim保留了你移动前位置的记录，你可以通过<code>:jumps</code>查看这个列表，如果想了解更多，可以查看<code>:h jump-motions</code>。</p>
<p>为什么跳转有用呢? 因为你可以在跳转列表中通过<code>Ctrl-o</code>和<code>Ctrl-i</code>在记录之间向上或向下跳转到对应位置。 你可以在不同文件中进行跳转，这将是我之后会讲的部分。</p>
<h2 id="聪明地学习导航"><a href="#聪明地学习导航" class="headerlink" title="聪明地学习导航"></a>聪明地学习导航</h2><p>如果你是Vim的新手，这有很多值得你学，我不期望任何人能够立刻记住每样知识点，做到不用思考就能执行这需要一些时间。</p>
<p>我想，最好的开始的办法就是从一些少量的必要的移动开始记。 我推荐你从<code>h,j,k,l,w,b,G,/,?,n</code>开始，学习10个移动并且很达到很舒服使用它们的状态花不了很多时间。</p>
<p>为了让你更擅长导航，我有两个建议：</p>
<ol>
<li>注意重复的动作。 如果你发现你自己在重复的使用<code>l</code>，你可以去找一个方法让你前进的更快，然后你会发现你可以用<code>w</code>在单词间移动。 如果你发现你自己的重复的使用<code>w</code>，你可以看看是否有一种方法能让你直接到行尾，然后你会想到可以用<code>$</code>。 如果你可以口语化的表达你的需求，Vim中大概就会有一种方法去完成它。</li>
<li>当你学习任何一个新的移动时，多需要花一定的时间直到你可以不经过思考直接完成它。</li>
</ol>
<p>最后，为了提高效率你不需要知道所有的Vim的命令，大多数Vim用户也都不知道，你只需要学习当下能够帮助你完成任务的命令。</p>
<p>慢慢来，导航技巧是Vim中很重要的技巧，每天学一点并且把它学好。</p>
<h1 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h1><p>输入模式是大部分文本编辑器的默认模式，在这个模式下，所敲即所得。</p>
<p>在这一章节中，你将能够学到如何利用Vim输入模式中的特性来提升你的输入效率。</p>
<h2 id="进入输入模式的方法"><a href="#进入输入模式的方法" class="headerlink" title="进入输入模式的方法"></a>进入输入模式的方法</h2><p>我们有很多方式从普通模式进入输入模式，下面列举出了其中的一些方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">i    从光标之前的位置开始输入文本</span><br><span class="line">I    从当前行第一个非空字符之前的位置之前开始输入文本</span><br><span class="line">a    在光标之后的位置追加文本</span><br><span class="line">A    在当前行的末尾追加文本</span><br><span class="line">o    在光标位置下方新起一行并开始输入文本</span><br><span class="line">O    在光标位置的上方新起一行并开始输入文本</span><br><span class="line">s    删除当前光标位置的字符并开始输入文本</span><br><span class="line">S    删除当前行并开始输入文本</span><br><span class="line">gi   从当前缓冲区上次结束输入模式的地方开始输入文本</span><br><span class="line">gI   在当前行的第一列的位置开始输入文本</span><br></pre></td></tr></table></figure>


<p>值得注意的是这些命令的小写/大写模式，每一个小写命令都有一个与之对应的大写命令。如果你是初学者，不用担心记不住以上整个命令列表，可以从 <code>i</code> 和 <code>a</code>两条命令开始，这两条命令足够在入门阶段使用了，之后再逐渐地掌握更多其他的命令。</p>
<h2 id="退出输入模式的方法"><a href="#退出输入模式的方法" class="headerlink" title="退出输入模式的方法"></a>退出输入模式的方法</h2><p>下面列出了一些从输入模式退出到普通模式的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;esc&gt;     退出输入模式进入普通模式</span><br><span class="line">Ctrl-[    退出输入模式进入普通模式</span><br><span class="line">Ctrl-c    与 Ctrl-[ 和 &lt;esc&gt;功能相同, 但是不检查缩写</span><br></pre></td></tr></table></figure>


<p>我发现<code>esc</code>键在键盘上太远了，很难够到，所以我在我的机器上将<code>caps lock</code> 映射成了<code>esc</code>键。 如果你搜索Bill Joy（Vi的作者）的ADM-3A 键盘， 你会发现<code>esc</code>键并不是像现在流行的键盘布局一样在键盘的最左上方，而是在<code>q</code>键的左边，所以我认为将<code>caps lock</code> 映射成<code>esc</code>键是合理的。</p>
<p>另一个Vim用户中常见的习惯是用以下的配置方法在输入模式中把<code>esc</code>映射到<code>jj</code>或者<code>jk</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inoremap jj &lt;esc&gt;</span><br><span class="line">inoremap jk &lt;esc&gt;</span><br></pre></td></tr></table></figure>


<h2 id="重复输入模式"><a href="#重复输入模式" class="headerlink" title="重复输入模式"></a>重复输入模式</h2><p>你可以在进入输入模式之前传递一个计数参数. 比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10i</span><br></pre></td></tr></table></figure>


<p>如果你输入“hello world!”然后退出输入模式， Vim将重复这段文本10次。这个方法对任意一种进入输入模式的方式都有效（如：<code>10I</code>, <code>11a</code>, <code>12o</code>）</p>
<h2 id="在输入模式中删除大块文本"><a href="#在输入模式中删除大块文本" class="headerlink" title="在输入模式中删除大块文本"></a>在输入模式中删除大块文本</h2><p>当你输入过程中出现一些输入错误时，一直重复地用<code>backspace</code>来删除的话会非常地繁琐。更为合理的做法是切换到普通模式并使用<code>d</code>来删除错误。或者，你能用以下命令在输入模式下就删除一个或者多个字符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-h    删除一个字符</span><br><span class="line">Ctrl-w    删除一个单词</span><br><span class="line">Ctrl-u    删除一整行</span><br></pre></td></tr></table></figure>


<p>此外，这些快捷键也支持在 命令行模式 和 Ex模式 中使用（命令行模式和Ex模式将会在之后的章节中介绍）</p>
<h1 id="用寄存器进行输入"><a href="#用寄存器进行输入" class="headerlink" title="用寄存器进行输入"></a>用寄存器进行输入</h1><p>寄存器就像是内存里的暂存器一样，可供存储和取出文本。在输入模式下，可以使用快捷键<code>Ctrl-r</code>加上寄存器的标识来从任何有标识的寄存器输入文本。有很多标识可供使用，但是在这一章节中你只需要知道以（a-z)命名的寄存器是可以使用的就足够了。</p>
<p>让我们在一个具体的例子中展示寄存器的用法，首先你需要复制一个单词到寄存器a中，这一步可以用以下这条命令来完成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;ayiw</span><br></pre></td></tr></table></figure>


<ul>
<li><code>&quot;a</code> 告诉Vim你下一个动作的目标地址是寄存器a</li>
<li><code>yiw</code> 复制一个内词（inner word），可以回顾Vim语法章节查看具体语法。</li>
</ul>
<p>现在寄存器a存放着你刚复制的单词。在输入模式中，使用以下的快捷键来粘贴存放在寄存器a中文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-r a</span><br></pre></td></tr></table></figure>


<p>Vim中存在很多种类型的寄存器，我会在后面的章节中介绍更多他们的细节。</p>
<h2 id="页面滚动"><a href="#页面滚动" class="headerlink" title="页面滚动"></a>页面滚动</h2><p>你知道在输入模式中也是可以进行页面滚动的吗？在输入模式下，如果你使用快捷键<code>Ctrl-x</code>进入<code>Ctrl-x</code>子模式，你可以进行一些额外操作，页面滚动正是其中之一。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-x Ctrl-y    向上滚动页面</span><br><span class="line">Ctrl-x Ctrl-e    向下滚动页面</span><br></pre></td></tr></table></figure>


<h2 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h2><p>Vim在进入<code>Ctrl-x</code>子模式后（和页面滚动一样），有一个自带的自动补全功能。尽管它不如intellisense或者其他的语言服务器协议（LSP）一样好用，但是也算是一个锦上添花的内置功能了。</p>
<p>下面列出了一些适合入门时学习的自动补全命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-x Ctrl-l	   补全一整行</span><br><span class="line">Ctrl-x Ctrl-n	   从当前文件中补全文本</span><br><span class="line">Ctrl-x Ctrl-i	   从引用（include）的文件中补全文本</span><br><span class="line">Ctrl-x Ctrl-f	   补全一个文件名</span><br></pre></td></tr></table></figure>


<p>当你出发自动补全时，Vim会显示一个选项弹窗，可以使用<code>Ctrl-n</code>和<code>Ctrl-p</code>来分别向上和向下浏览选项。</p>
<p>Vim也提供了两条不需要进入<code>Ctrl-x</code>模式就能使用的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-n             使用下一个匹配的单词进行补全</span><br><span class="line">Ctrl-p             使用上一个匹配的单词进行补全</span><br></pre></td></tr></table></figure>


<p>通常Vim会关注所有缓冲区（buffer）中的文本作为自动补全的文本来源。如果你打开了一个缓冲区，其中一行是”Chocolate donuts are the best”：</p>
<ul>
<li>当你输入”Choco”然后使用快捷键<code>Ctrl-x Ctrl-l</code>， Vim会进行匹配并输出这一整行的文本。</li>
<li>当你输入”Choco”然后使用快捷键<code>Ctrl-p</code>，Vim会进行匹配并输出”Chocolate”这个单词。</li>
</ul>
<p>Vim的自动补全是一个相当大的话题，以上只是冰山一角，想要进一步学习的话可以使用<code>:h ins-completion</code>命令进行查看。</p>
<h2 id="执行普通模式下的命令"><a href="#执行普通模式下的命令" class="headerlink" title="执行普通模式下的命令"></a>执行普通模式下的命令</h2><p>你知道Vim可以在输入模式下执行普通模式的命令吗？</p>
<p>在输入模式下， 如果你按下<code>Ctrl-o</code>，你就会进入到<code>insert-normal</code>（输入-普通）子模式。如果你关注一下左下角的模式指示器，通常你将看到<code>-- INSERT --</code> ，但是按下<code>Ctrl-o</code>后就会变为<code>-- (insert) --</code>。 在这一模式下，你可以执行一条普通模式的命令，比如你可以做以下这些事：</p>
<p><strong>设置居中以及跳转</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-o zz       居中窗口</span><br><span class="line">Ctrl-o H/M/L    跳转到窗口的顶部/中部/底部</span><br><span class="line">Ctrl-o &#x27;a       跳转到标志&#x27;a处</span><br></pre></td></tr></table></figure>


<p><strong>重复文本</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-o 100ihello    输入 &quot;hello&quot; 100 次</span><br></pre></td></tr></table></figure>


<p><strong>执行终端命令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-o !! curl https://google.com    运行curl命令</span><br><span class="line">Ctrl-o !! pwd                        运行pwd命令</span><br></pre></td></tr></table></figure>


<p><strong>快速删除</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-o dtz    从当前位置开始删除文本，直到遇到字母&quot;z&quot;</span><br><span class="line">Ctrl-o D      从当前位置开始删除文本，直到行末</span><br></pre></td></tr></table></figure>


<h2 id="聪明地学习输入模式"><a href="#聪明地学习输入模式" class="headerlink" title="聪明地学习输入模式"></a>聪明地学习输入模式</h2><p>如果你和我一样是从其他文本编辑器转到Vim的，你或许也会觉得一直待在输入模式下很有诱惑力，但是我强烈反对你在没有输入文本时，却仍然待在输入模式下。应该养成当你的双手没有在输入时，就退出到普通模式的好习惯。</p>
<p>当你需要进行输入时，先问问自己将要输入的文本是否已经存在。如果存在的话，试着复制或者移动这段文本而不是手动输入它。再问问自己是不是非得进入输入模式，试试能不能尽可能地使用自动补全来进行输入。尽量避免重复输入同一个单词。</p>
<h1 id="点命令"><a href="#点命令" class="headerlink" title="点命令"></a>点命令</h1><p>在编辑文本时，我们应该尽可能地避免重复的动作。在这一章节中，你将会学习如何使用点命令来重放上一个修改操作。点命令是最简单的命令，然而又是减少重复操作最为有用的命令。</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>正如这个命令的名字一样，你可以通过按下<code>.</code>键来使用点命令。</p>
<p>比如，如果你想将下面文本中的所有”let“替换为”const”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let one = &quot;1&quot;;</span><br><span class="line">let two = &quot;2&quot;;</span><br><span class="line">let three = &quot;3&quot;;</span><br></pre></td></tr></table></figure>


<p>首先，使用<code>/let</code>来进行匹配。接着，使用<code>cwconst&lt;esc&gt;</code>来将”let”替换成”const”。第三步，使用<code>n</code>来找到下一个匹配的位置。最后，使用点命令(<code>.</code>)来重复之前的操作。持续地使用<code>n . n .</code>直到每一个匹配的词都被替换。</p>
<p>在这个例子里面，点命令重复的是<code>cwconst&lt;esc&gt;</code>这一串命令，它能够帮你将需要8次输入的命令简化到只需要敲击一次键盘。</p>
<h2 id="什么才算是修改操作？"><a href="#什么才算是修改操作？" class="headerlink" title="什么才算是修改操作？"></a>什么才算是修改操作？</h2><p>如果你查看点命令的定义的话(<code>:h .</code>),文档中说点命令会重复上一个修改操作，那么什么才算是一个修改操作呢？</p>
<p>当你使用普通模式下的命令来更新（添加，修改或者删除）当前缓冲区中的内容时，你就是在执行一个修改操作了。其中的例外是使用命令行命令进行的修改（以<code>：</code>开头的命令），这些命令不算作修改操作。</p>
<p>在第一个例子中，你看到的<code>cwconst&lt;esc&gt;</code>就是一个修改操作。现在假设你有以下这么一个句子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pancake, potatoes, fruit-juice,</span><br></pre></td></tr></table></figure>


<p>我们来删除从这行开始的位置到第一个逗号出现的位置。你可以使用<code>df,</code>来完成这个操作,使用<code>.</code>来重复两次直到你将整个句子删除。</p>
<p>让我们再来试试另一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pancake, potatoes, fruit-juice,</span><br></pre></td></tr></table></figure>


<p>这一次你只需要删除所有的逗号，不包括逗号前面的词。我们可以使用<code>f,</code>来找到第一个逗号，再使用<code>x</code>来删除光标下的字符。然后使用用<code>.</code>来重复两次，很简单对不对？等等！这样做行不通(只会重复删除光标下的一个字符，而不是删除逗号)！为什么会这样呢？</p>
<p>在Vim里，修改操作是不包括移动操作（motions）的，因为动作不会更新缓冲区的内容。当你运行<code>f,x</code>，你实际上是在执行两个独立的操作：<code>f,</code>命令只移动光标，而<code>x</code>更新缓冲区的内容，只有后者算作修改动作。和之前例子中的<code>df,</code>进行一下对比的话，你会发现<code>df,</code>中的<code>f,</code>告诉删除操作<code>d</code>哪里需要删除，是整个删除命令<code>df,</code>的一部分。</p>
<p>让我们想想办法完成这个任务。在你运行<code>f,</code>并执行<code>x</code>来删除第一个逗号后，使用<code>;</code>来继续匹配<code>f</code>的下一个目标（下一个逗号）。之后再使用<code>.</code>来重复修改操作，删除光标下的字符。重复<code>; . ; .</code>直到所有的逗号都被删除。完整的命令即为<code>f,x;.;.</code>。</p>
<p>再来试试下一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pancake</span><br><span class="line">potatoes</span><br><span class="line">fruit-juice</span><br></pre></td></tr></table></figure>


<p>我们的目标是给每一行的结尾加上逗号。从第一行开始，我们执行命令<code>A,&lt;esc&gt;j</code>来给结尾加上逗号并移动到下一行。现在我们知道了<code>j</code>是不算作修改操作的，只有<code>A,</code>算作修改操作。你可以使用<code>j . j .</code>来移动并重复修改操作。完整的命令是<code>A,&lt;esc&gt;j</code>。</p>
<p>从你按下输入命令（A）开始到你退出输入模式（）之间的所有输入都算作是一整个修改操作。Vim不仅允许你控制需要添加的文本的内容，还允许你控制在什么位置添加文本。你可以在选择在这些位置进行输入：光标位置前（<code>i</code>）,光标位置之后（<code>a</code>）,在下方插入一行（<code>o</code>），在上方插入一行（<code>O</code>），在当前行的末尾(<code>A</code>),或者在当前行的开始位置(<code>I</code>)。如果你想复习一下相关内容的话，可以看看输入模式（Insert Mode）这一章节。</p>
<h2 id="重复多行修改操作"><a href="#重复多行修改操作" class="headerlink" title="重复多行修改操作"></a>重复多行修改操作</h2><p>假设你有如下的文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let one = &quot;1&quot;;</span><br><span class="line">let two = &quot;2&quot;;</span><br><span class="line">let three = &quot;3&quot;;</span><br><span class="line">const foo = &quot;bar&quot;;</span><br><span class="line">let four = &quot;4&quot;;</span><br><span class="line">let five = &quot;5&quot;;</span><br><span class="line">let six = &quot;6&quot;;</span><br><span class="line">let seven = &quot;7&quot;;</span><br><span class="line">let eight = &quot;8&quot;;</span><br><span class="line">let nine = &quot;9&quot;;</span><br></pre></td></tr></table></figure>


<p>你的目标是删除除了含有”foo”那一行以外的所有行。首先，使用<code>d2j</code>删除前三行。之后跳过”foo”这一行，在其下一行使用点命令两次来删除剩下的六行。完整的命令是<code>d2jj..</code>。</p>
<p>这里的修改操作是<code>d2j</code>，<code>2j</code>不是一个移动操作，而是整个删除命令的一部分。</p>
<p>我们再来看看下一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zlet zzone = &quot;1&quot;;</span><br><span class="line">zlet zztwo = &quot;2&quot;;</span><br><span class="line">zlet zzthree = &quot;3&quot;;</span><br><span class="line">let four = &quot;4&quot;;</span><br></pre></td></tr></table></figure>


<p>我们的目标是删除所有的’z’。首先，在块可视化模式下使用<code>Ctrl-vjj</code>来选中前三行的第一个’z’字母。如果你对块可视化模式不熟悉的话也不用担心，我会在下一章节中进行介绍。在选中前三行的第一个’z’后，使用<code>d</code>来删除它们。接着用<code>w</code>移动到下一个z字母上，使用<code>..</code>重复两次之前选中加删除的动作。完整的命令为<code>Ctrl-vjjdw..</code>。</p>
<p>你删除一列上的三个’z‘的操作(<code>Ctrl-vjjd</code>)被看做一整个修改操作。可视化模式中的选择操作可以用来选中多行，作为修改动作的一部分。</p>
<h2 id="在修改中包含移动操作"><a href="#在修改中包含移动操作" class="headerlink" title="在修改中包含移动操作"></a>在修改中包含移动操作</h2><p>让我们来重新回顾一下本章中的第一个例子。这个例子中我们使用了<code>/letcwconst&lt;esc&gt;</code>紧接着<code>n . n .</code>将下面的文本中的’let’都替换成了’const’。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let one = &quot;1&quot;;</span><br><span class="line">let two = &quot;2&quot;;</span><br><span class="line">let three = &quot;3&quot;;</span><br></pre></td></tr></table></figure>


<p>其实还有更快的方法来完成整个操作。在删除的时候，并不使用<code>w</code>,而是使用<code>gn</code>。</p>
<p><code>gn</code>是向前搜索和上一个搜索的模式（本例中为<code>/let</code>）匹配的位置，并且自动对匹配的文本进行可视化模式下的选取的移动操作。想要对下一个匹配的位置进行替换的话，你不再需要先移动在重复修改操作（<code>n . n .</code>），而是简单地使用<code>. .</code>就能完成。你不需要再进行移动操作了，因为找到下一个匹配的位置并进行选中成为了修改操作的一部分了。完整的命令为<code>/letdgn..</code></p>
<p>当你在编辑文本时，应该时刻关注像<code>gn</code>命令这种能一下子做好几件事的移动操作。</p>
<h2 id="聪明地学习点命令"><a href="#聪明地学习点命令" class="headerlink" title="聪明地学习点命令"></a>聪明地学习点命令</h2><p>点命令的强大之处在于使用仅仅1次键盘敲击代替好几次敲击。对于<code>x</code>这种只需一次敲击键盘就能完成的修改操作来说，点命令或许不会带来什么收益。但是如果你的上一个修改操作是像<code>cgnconst&lt;esc&gt;</code>这种复杂命令的话，使用点命令来替代就有非常可观的收益了。</p>
<p>在进行编辑时，思考一下你正将进行的操作是否是可以重复的。举个例子，如果我需要删除接下来的三个单词，是使用<code>d3w</code>更划算，还是<code>dw</code>再使用<code>.</code>两次更划算？之后还会不会再进行删除操作？如果是这样的话，使用<code>dw</code>好几次确实比<code>d3w</code>更加合理，因为<code>dw</code>更加有复用性。在编辑时应该养成“修改操作驱动”的观念。</p>
<p>点命令非常简单但又功能强大，帮助你开始自动化处理简单的任务。在后续的章节中，你将会学习到如何使用Vim的宏命令来自动化处理更多复杂的操作。但是首先，还是让我们来学习一下如何使用寄存器来存取文本吧。</p>
<h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p>学习Vim中的寄存器就像第一次学习线性代数一样，除非你学习了他们，否则你会觉得自己根本不需要它们。</p>
<p>你可能已经在复制或删除文本并用<code>p</code>或<code>P</code>粘贴它们到别处的时候使用过Vim的寄存器了。但是，你知道Vim总共有10种不同类型的寄存器吗？</p>
<p>在这一章节中，我会介绍Vim的所有寄存器类型，以及如何有效地使用它们。</p>
<h2 id="寄存器的10种类型"><a href="#寄存器的10种类型" class="headerlink" title="寄存器的10种类型"></a>寄存器的10种类型</h2><p>下面是Vim所拥有的10种寄存器类型：</p>
<ol>
<li>匿名寄存器（<code>&quot;&quot;</code>）</li>
<li>编号寄存器(<code>&quot;0-9</code>).</li>
<li>小删除寄存器 (<code>&quot;-</code>).</li>
<li>命名寄存器 (<code>&quot;a-z</code>).</li>
<li>只读寄存器 (<code>&quot;:</code>, <code>&quot;.</code>,and <code>&quot;%</code>).</li>
<li>Buffer交替文件寄存器 (<code>&quot;#</code>).</li>
<li>表达式寄存器 (<code>&quot;=</code>).</li>
<li>选取和拖放寄存器(<code>&quot;*</code> and <code>&quot;+</code>).</li>
<li>黑洞寄存器 (<code>&quot;_</code>).</li>
<li>搜索模式寄存器 (<code>&quot;/</code>).</li>
</ol>
<h2 id="寄存器命令"><a href="#寄存器命令" class="headerlink" title="寄存器命令"></a>寄存器命令</h2><p>以下是一些存值到寄存器中操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y    复制</span><br><span class="line">c    删除文本并进入输入模式</span><br><span class="line">d    删除文本</span><br></pre></td></tr></table></figure>


<p>其实还有更多的寄存器写入操作（比如<code>s</code>或<code>x</code>），但是上面列出的是最常用的一些。根据经验看来，如果一个操作删除了文本，那么很有可能这个操作将移除的文本存入寄存器中了。</p>
<p>To put (paste) texts from registers, you can use:</p>
<p>想要从寄存器中取出（粘贴）文本，你可以用以下的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p    在光标位置之后粘贴文本</span><br><span class="line">P    在光标位置之前粘贴文本</span><br></pre></td></tr></table></figure>


<p><code>p</code>和<code>P</code>都可以接受计数和一个寄存器标志作为参数。比如，想要把最近复制的文本粘贴10次的话可以用<code>10p</code>。想粘贴寄存器”a”中的文本，可以用<code>&quot;ap</code>。想将寄存器“a”中的文本粘贴10次的话，可以使用<code>10&quot;ap</code>。</p>
<p>从某个特定寄存器中读取文本的通用语法是<code>&quot;x</code>，其中<code>x</code>是这个寄存器的标识。</p>
<h2 id="在输入模式中使用寄存器"><a href="#在输入模式中使用寄存器" class="headerlink" title="在输入模式中使用寄存器"></a>在输入模式中使用寄存器</h2><p>在这一章节中你学到的东西在输入模式中也同样适用。想要获取寄存器”a”中的文本，通常可以使用<code>&quot;ap</code>来进行。不过当你在输入模式下时，你需要运行<code>Ctrl-r a</code>。在输入模式下使用寄存器的语法是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-r x</span><br></pre></td></tr></table></figure>


<p>其中<code>x</code>是寄存器标识。既然你现在已经知道如何存储和访问寄存器了，让我们学点更深入的吧。</p>
<h2 id="匿名寄存器-quot-quot"><a href="#匿名寄存器-quot-quot" class="headerlink" title="匿名寄存器(&quot;&quot;)"></a>匿名寄存器(<code>&quot;&quot;</code>)</h2><p>想从匿名寄存器中获取文本，可以使用<code>&quot;&quot;p</code>。 匿名寄存器默认存储着你最近一次复制，修改或删除的文本。如果再进行另一次复制，修改或删除，Vim会自动替换匿名寄存器中的文本。匿名寄存器和电脑上粘贴板的功能很接近。</p>
<p>默认情况下，<code>p</code>(或者<code>P</code>)是和匿名寄存器相关联的（从现在起我将使用<code>p</code>而不是<code>&quot;&quot;p</code>来指代匿名寄存器）。</p>
<h2 id="编号寄存器-quot-0-9"><a href="#编号寄存器-quot-0-9" class="headerlink" title="编号寄存器(&quot;0-9)"></a>编号寄存器(<code>&quot;0-9</code>)</h2><p>编号寄存器会自动以升序来进行填充。一共有两种不同的编号寄存器：复制寄存器(<code>0</code>)和其他编号寄存器(<code>1-9</code>)。让我们先来讨论复制寄存器。</p>
<h3 id="复制寄存器-quot-0"><a href="#复制寄存器-quot-0" class="headerlink" title="复制寄存器 (&quot;0)"></a>复制寄存器 (<code>&quot;0</code>)</h3><p>如果你使用<code>yy</code>来复制一整行文本，事实上Vim会将文本存放两个寄存器中：</p>
<ol>
<li>匿名寄存器 (<code>p</code>).</li>
<li>复制寄存器 (<code>&quot;0p</code>).</li>
</ol>
<p>在你又复制其他不同的文本后，Vim会自动替换匿名寄存器和复制寄存器中的内容。其他的任何操作都不会被存放在<code>0</code>号寄存器中。这可以为你提供方便，因为除非你再进行另一次复制，否则你已经复制的内容会一直在寄存器中，无论你进行多少次修改和删除。</p>
<p>比如，如果你：</p>
<ol>
<li>复制一整行 (<code>yy</code>)</li>
<li>删除一整行(<code>dd</code>)</li>
<li>再删除另一行 (<code>dd</code>)</li>
</ol>
<p>复制寄存器中的文本仍然是第一步中复制的文本。</p>
<p>如果你:</p>
<ol>
<li>复制一整行 (<code>yy</code>)</li>
<li>删除一整行 (<code>dd</code>)</li>
<li>复制另一行 (<code>yy</code>)</li>
</ol>
<p>复制寄存器中的内容则是第三步中复制的内容。</p>
<p>还有一个小技巧，在输入模式下，你可以使用<code>Ctrl-r 0</code>快速地粘贴你刚才复制的内容。</p>
<h3 id="编号寄存器-quot-1-9"><a href="#编号寄存器-quot-1-9" class="headerlink" title="编号寄存器 (&quot;1-9)"></a>编号寄存器 (<code>&quot;1-9</code>)</h3><p>当你修改或者删除至少一整行的文本时，这部分文本会按时间顺序被存储在1-9号编号寄存器中。（编号越小时间距离越近）</p>
<p>比如，你有以下这些文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">line three</span><br><span class="line">line two</span><br><span class="line">line one</span><br></pre></td></tr></table></figure>


<p>当你的光标在文本“line three”上时,使用<code>dd</code>来一行一行地删除这些文本。在所有文本都已经删除后，1号寄存器中的内容应该是”line one”（时间上最近的文本）， 2号寄存器则包含”line two”(时间上第二近的文本)，3号寄存器中则包含”line three”（最早删除的文本）。普通模式下可以使用<code>&quot;1p</code>来获取1号寄存器中的内容。</p>
<p>编号寄存器的编号在使用点命令时会自动增加。比如，如果你的1号编号寄存器（<code>&quot;1</code>）中的内容为”line one”， 2号寄存器（<code>&quot;2</code>）为”line two”, 三号寄存器（<code>&quot;3</code>）,你可以使用以下的技巧来连续地粘贴他们：</p>
<ul>
<li>使用<code>&quot;1p</code>来粘贴1号寄存器中的内容。</li>
<li>使用<code>.</code> (点命令)来粘贴2号寄存器（<code>&quot;2</code>）中的内容。</li>
<li>使用<code>.</code> (点命令)来粘贴3号寄存器（<code>&quot;3</code>）中的内容。</li>
</ul>
<p>在连续地使用点命令时，Vim会自动的增加编号寄存器的编号。这个技巧对于所有的编号寄存器都适用。如果你从5号寄存器开始(<code>&quot;5P</code>), 点命令<code>.</code>会执行<code>&quot;6P</code>,再次使用<code>.</code>则会执行<code>&quot;7P</code>,等等。</p>
<p>小型的删除比如单词删除（<code>dw</code>)或者单词修改(<code>cw</code>)不会被存储在编号寄存器中，它们被存储在小删除寄存器(<code>&quot;-</code>)中，我将在接下来的一小节讨论小删除寄存器。</p>
<h2 id="小删除寄存器-quot"><a href="#小删除寄存器-quot" class="headerlink" title="小删除寄存器(&quot;-)"></a>小删除寄存器(<code>&quot;-</code>)</h2><p>不足一行的修改或者删除都不会被存储在0-9号编号寄存器中，而是会被存储在小删除寄存器 (<code>&quot;-</code>)中。</p>
<p>比如:</p>
<ol>
<li>删除一个单词 (<code>diw</code>)</li>
<li>删除一行文本 (<code>dd</code>)</li>
<li>删除一行文本 (<code>dd</code>)</li>
</ol>
<p><code>&quot;-p</code> 会给你第一步中删除的单词。</p>
<p>另一个例子:</p>
<ol>
<li>删除一个单词(<code>diw</code>)</li>
<li>删除一行文本 (<code>dd</code>)</li>
<li>删除一个单词 (<code>diw</code>)</li>
</ol>
<p><code>&quot;-p</code> 会给出第三步中删除的单词。类似地, <code>&quot;1p</code> 会给出第二步中删除的一整行文本。不幸的是我们没有办法获取第一步中删除的单词，因为小删除寄存器只能存储一个文本。然而，如果你想保存第一步中删除的文本，你可以使用命名寄存器来完成。</p>
<h2 id="命名寄存器-quot-a-z"><a href="#命名寄存器-quot-a-z" class="headerlink" title="命名寄存器 (&quot;a-z)"></a>命名寄存器 (<code>&quot;a-z</code>)</h2><p>命名寄存器是Vim中用法最丰富的寄存器。a-z命名寄存器可以存储复制的，修改的和被删除的文本。不像之前介绍的3种寄存器一样，它们会自动将文本存储到寄存器中，你需要显式地告诉Vim你要使用命名寄存器，你拥有完整的控制权。</p>
<p>为了复制一个单词到寄存器”a”中，你可以使用命令<code>&quot;ayiw</code>。</p>
<ul>
<li><code>&quot;a</code>告诉Vim下一个动作（删除/修改/复制）会被存储在寄存器”a”中</li>
<li><code>yiw</code>复制这个单词</li>
</ul>
<p>为了从寄存器”a”中获取文本，可以使用命令<code>&quot;ap</code>。你可以使用以26个字母命名的寄存器来存储26个不同的文本。</p>
<p>有时你可能会想要往已有内容的命名寄存器中继续添加内容，这种情况下，你可以追加文本而不是全部重来。你可以使用大写版本的命名寄存器来进行文本的追加。比如，假设你的”a”寄存器中已经存有文本”Hello”，如果你想继续添加”world”到寄存器”a”中，你可以先找到文本”world”然后使用<code>&quot;Aiw</code>来进行复制,即可完成追加。</p>
<h2 id="只读寄存器-quot-quot-quot"><a href="#只读寄存器-quot-quot-quot" class="headerlink" title="只读寄存器(&quot;:, &quot;., &quot;%)"></a>只读寄存器(<code>&quot;:</code>, <code>&quot;.</code>, <code>&quot;%</code>)</h2><p>Vim有三个只读寄存器：<code>.</code>,<code>:</code>和<code>%</code>，它们的用法非常简单：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.    存储上一个输入的文本</span><br><span class="line">:    存储上一次执行的命令</span><br><span class="line">%    存储当前文件的文件名</span><br></pre></td></tr></table></figure>


<p>如果你写入”Hello Vim”,之后再运行<code>&quot;.p</code>就会打印出文本”Hello Vim”。如果你想要获得当前文件的文件名，可以运行命令<code>&quot;%p</code>。如果你运行命令<code>:s/foo/bar/g</code>，再运行<code>&quot;:p</code>的话则会打印出文本”s/foo/bar/g”。</p>
<h2 id="Buffer交替文件寄存器-quot"><a href="#Buffer交替文件寄存器-quot" class="headerlink" title="Buffer交替文件寄存器 (&quot;#)"></a>Buffer交替文件寄存器 (<code>&quot;#</code>)</h2><p>在Vim中，<code>#</code>通常代表交替文件。交替文件指的是你上一个打开的文件，想要插入交替文件的名字的话，可以使用命令<code>&quot;#p</code>。</p>
<h2 id="表达式寄存器-quot"><a href="#表达式寄存器-quot" class="headerlink" title="表达式寄存器 (&quot;=)"></a>表达式寄存器 (<code>&quot;=</code>)</h2><p>Vim有一个表达式寄存器，<code>&quot;=</code>,用于计算表达式的结果。表达式是Vim中非常宏大的一个话题，所以我只会在这里介绍一些基础知识，我将会在之后的章节中进一步讲解更多关于表达式的细节。</p>
<p>你可以使用以下命令计算数学表达式<code>1+1</code>的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;=1+1&lt;Enter&gt;p</span><br></pre></td></tr></table></figure>


<p>在这里，你在告诉Vim你正在使用表达式寄存器<code>&quot;=</code>，你的表达式是（<code>1+1</code>），你还需要输入<code>p</code>来的到结果。正如之前所提到的，你也可以在输入模式中访问寄存器。想要在输入模式中计算数学表达式的值，你可以使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-r =1+1</span><br></pre></td></tr></table></figure>


<p>你可以使用<code>@</code>来从任何寄存器中获取表达式并用表达式寄存器计算其值。如果你希望从寄存器”a”中获取文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;=@a</span><br></pre></td></tr></table></figure>


<p>之后输入<code>&lt;enter&gt;</code>，再输入<code>p</code>。类似地，想在输入模式中得到寄存器”a”中的值可以使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-r =@a</span><br></pre></td></tr></table></figure>


<p>你也能使用表达式寄存器来计算Vim脚本的值。如果你使用<code>:let i = 1</code>定义一个变量<code>i</code>,你可以用<code>&quot;=i</code>获取到它的值，按下回车，再按下<code>p</code>。想在输入模式中获取到这个值的话可以运行命令<code>Ctrl-r=i</code>。</p>
<p>假设你有一个方程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function! HelloFunc()</span><br><span class="line">	return &quot;Hello Vim Script!&quot;</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>


<p>你可以通过调用这个方程获取它的值。想要在普通模式中调用这个方程，你可以使用：<code>&quot;=HelloFunc()</code>, 按下回车再按下<code>p</code>。而在输入模式下可以使用<code>Ctrl-r =HelloFunc()</code>。</p>
<h2 id="选取和拖放寄存器-quot-quot"><a href="#选取和拖放寄存器-quot-quot" class="headerlink" title="选取和拖放寄存器 (&quot;*, &quot;+)"></a>选取和拖放寄存器 (<code>&quot;*</code>, <code>&quot;+</code>)</h2><p>你难道不觉得有些时候你需要从某些外部的程序中复制一些文本并粘贴到Vim中吗，或者反过来操作？有了Vim的选取和拖放寄存器你就能办到。Vim有两个选取寄存器：<code>quotestar</code> (<code>&quot;*</code>) 和 <code>quoteplus</code> (<code>&quot;+</code>)。你可以用它们来访问从外部程序中复制的文本。</p>
<p>如果你在运行一个外部程序（比如Chrome浏览器），然后你使用<code>Ctrl-c</code>(或者<code>Cmd-c</code>,取决于你的操作系统)复制了一部分文本，通常你是没有办法在Vim里使用<code>p</code>来粘贴这部分文本的。但是，Vim的两个寄存器<code>&quot;+</code>和<code>&quot;*</code>都是和你系统的粘贴板相连接的，所以你可以使用<code>&quot;+p</code>和<code>&quot;*p</code>来粘贴这些文本。反过来，如果你使用<code>&quot;+yiw</code>或者<code>&quot;*yiw</code>在Vim中复制了一些文本，你可以使用<code>Ctrl-v</code>（或者<code>Cmd-v</code>）。值得注意的是这个方法只在你的Vim开启了<code>+clipboard</code>选项时才有用，可以在命令行中运行<code>vim --version</code>查看这一选项。如果你看见<code>-clipboard</code>的话，则需要安装一下支持Vim粘贴板的配置。</p>
<p>你也许会想如果<code>&quot;*</code>和<code>&quot;+</code>能办到的事完全相同，那为什么Vim需要两个不同的寄存器呢？一些机器使用的是X11窗口系统，这一系统有3个类型的选项：首选，次选和粘贴板。如果你的机器使用的是X11的话,Vim使用的是<code>quotestar</code> (<code>&quot;*</code>)寄存器作为X11的首选选项，并使用 <code>quoteplus</code> (<code>&quot;+</code>)作为粘贴板选项。这只在你的Vim配置里开启了<code>xterm_clipboard</code> 选项时才有效（<code>vim --version</code>中的<code>+xterm_clipboard</code>）。如果你的的Vim配置中没有 <code>xterm_clipboard</code>也不是什么大问题。这只是意味着<code>quotestar</code> 和<code>quoteplus</code>两个寄存器是可以互相替代的。</p>
<p>我发觉使用<code>=*p</code>或者<code>=+p</code>的话比较麻烦，为了使Vim仅使用<code>p</code>就能粘贴从外部程序复制的文本，你可以在你的<code>vimrc</code>配置文件中加入下面一行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set clipboard=unnamed</span><br></pre></td></tr></table></figure>


<p>现在当我从外部程序中复制文本时，我可以使用匿名寄存器<code>p</code>来进行粘贴。我也可以在Vim中复制文本后在外部程序中使用<code>Ctrl-v</code>来粘贴。如果你的Vim开启了 <code>+xterm_clipboard</code>设置，你或许会想同时也使用<code>unnamed</code>和<code>unnamedplus</code>的粘贴板选项。</p>
<h2 id="黑洞寄存器-quot"><a href="#黑洞寄存器-quot" class="headerlink" title="黑洞寄存器 (&quot;_)"></a>黑洞寄存器 (<code>&quot;_</code>)</h2><p>你每次删除或修改文本的时候，这部分文本都会自动保存在Vim的寄存器中。有些时候你并不希望把什么东西都往寄存器里存，这该怎么办到呢？</p>
<p>你可以使用黑洞寄存器（<code>&quot;_</code>）。想要删除一行并且不将其存储在任何寄存器中时，可以使用<code>&quot;_dd</code>命令，它是和 <code>/dev/null</code> 类似的寄存器。</p>
<h2 id="搜索模式寄存器-quot"><a href="#搜索模式寄存器-quot" class="headerlink" title="搜索模式寄存器 (&quot;/)"></a>搜索模式寄存器 (<code>&quot;/</code>)</h2><p>为了粘贴你的上一个搜索询问（<code>/</code> 或 <code>?</code>），你可以使用搜索模式寄存器(<code>&quot;/</code>)。使用命令 <code>&quot;/p</code>就能粘贴上一个搜索的条目。</p>
<h2 id="查看所有的寄存器"><a href="#查看所有的寄存器" class="headerlink" title="查看所有的寄存器"></a>查看所有的寄存器</h2><p>你可以使用<code>:register</code>命令来查看你的所有寄存器。如果你只想查看”a”,”1”和”-“寄存器的内容的话则可以使用命令<code>:register a 1 -</code>。</p>
<p>有一个Vim的插件叫做 <a target="_blank" rel="noopener" href="https://github.com/junegunn/vim-peekaboo">vim-peekaboo</a> ,可以让你查看到寄存器的内容，在普通模式下输入<code>&quot;</code>或<code>@</code> 即可，或者在输入模式中输入<code>Ctrl-r</code>。我发现这个插件相当的有用，因为大多数时候我是记不住我的寄存器中的内容的。值得一试！</p>
<h2 id="执行寄存器"><a href="#执行寄存器" class="headerlink" title="执行寄存器"></a>执行寄存器</h2><p>命名寄存器不只可以用来存放文本，你还可以借助<code>@</code>来执行宏命令。我会在下一章节中介绍宏命令。如果你将文本”Hello Vim”存放在寄存器”a”中，并且之后你在同一个寄存器里记录了一个宏命令 (<code>qa&#123;macro-commands&#125;q</code>),那么这个宏命令将会覆盖之前存储的文本”Hello Vim”（你可以使用<code>@a</code>来执行寄存器中存储的宏命令）。</p>
<h2 id="清除寄存器"><a href="#清除寄存器" class="headerlink" title="清除寄存器"></a>清除寄存器</h2><p>从技术上来说，我们没有必要来清除任何寄存器，因为你下一个使用来存储文本的寄存器会自动覆盖该寄存器中之前的内容。然而，你可以通过记录一个空的宏命令来快速地清除任何命名寄存器。比如，如果你运行<code>qaq</code>，Vim就会在寄存器”a”中记录一个空的宏命令。还有一种方法就是运行命令<code>:call setreg(&#39;a&#39;,&#39;&#39;)</code>,其中’a’代表的就是寄存器”a”。还有一种清除寄存器的方法就是使用表达式<code>:let @a = &#39;&#39;</code>来将寄存器的值设为空的字符串。</p>
<h2 id="获取寄存器中的内容"><a href="#获取寄存器中的内容" class="headerlink" title="获取寄存器中的内容"></a>获取寄存器中的内容</h2><p>你可以使用<code>:put</code>命令来粘贴任何寄存器的内容。比如，如果你运行命令<code>:put a</code>,Vim就会打印出寄存器”a”的内容，这和<code>&quot;ap</code>非常像，唯一的区别在于在普通模式下命令<code>p</code>在当前光标位置之后打印寄存器的内容，而<code>:put</code>新起一行来打印寄存器的内容。</p>
<h2 id="聪明地学习寄存器"><a href="#聪明地学习寄存器" class="headerlink" title="聪明地学习寄存器"></a>聪明地学习寄存器</h2><p>恭喜你成功地坚持到了最后！这一章有非常多的内容需要消化。如果你感觉被新的知识淹没，你要知道你并不孤单，当我最初开始学习Vim寄存器时也有这种感觉。</p>
<p>我并不认为你必须现在就记得所有的知识点。为了提高我们的生产效率，你可以从使用以下三类寄存器开始：</p>
<ol>
<li>匿名寄存器(<code>&quot;&quot;</code>).</li>
<li>命名寄存器 (<code>&quot;a-z</code>).</li>
<li>编号寄存器 (<code>&quot;0-9</code>).</li>
</ol>
<p>既然匿名寄存器是默认和<code>p</code>或<code>P</code>，你只需要学习两个寄存器：命名寄存器和编号寄存器。之后如果你需要用到其他的寄存器时你再逐渐地学习其他寄存器的用法，不用急，慢慢来。</p>
<p>普通人的短期记忆都是有极限的，大概每次只能记住7个信息。这就是为什么在我的日常编辑中，我只用3到7个命名寄存器的原因，我没有办法记住整整26个寄存器的内容。我通常从寄存器”a”开始用，之后用寄存器”b”,以字母表升序的顺序来使用。尝试一下各种方法，看看哪种最适合你。</p>
<p>Vim寄存器非常强大，合理使用的话能够避免你输入数不清的重复文本。但是现在，是时候学习一下宏命令了。</p>
<h1 id="宏命令"><a href="#宏命令" class="headerlink" title="宏命令"></a>宏命令</h1><p>在编辑文件的时候，你会发现有时候你在反复地做一些相同的动作。如果你仅做一次，并在需要的时候调用这些动作岂不是会更好吗。通过 Vim 的宏命令，你可以将一些动作记录到 Vim 寄存器。</p>
<p>在本章中，你将会学习到如何通过宏命令自动完成一些普通的任务（另外，看你的文件在自动编辑是一件很酷的事情）。</p>
<h2 id="基本宏命令"><a href="#基本宏命令" class="headerlink" title="基本宏命令"></a>基本宏命令</h2><p>宏命令的基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">qa                     开始记录动作到寄存器 a</span><br><span class="line">q (while recording)    停止记录</span><br></pre></td></tr></table></figure>


<p>你可以使用小写字母 （a-z）去存储宏命令。并通过如下的命令去调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@a    Execute macro from register a</span><br><span class="line">@@    Execute the last executed macros</span><br></pre></td></tr></table></figure>


<p>假设你有如下的文本，你打算将每一行中的所有字母都变为大写。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">vim</span><br><span class="line">macros</span><br><span class="line">are</span><br><span class="line">awesome</span><br></pre></td></tr></table></figure>


<p>将你的光标移动到 “hello” 栏的行首，并执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qa0gU$jq</span><br></pre></td></tr></table></figure>


<p>上面命令的分解如下：</p>
<ul>
<li><code>qa</code> 开始记录一个宏定义并存储在 a 寄存器。</li>
<li><code>0</code> 移动到行首。</li>
<li><code>gU$</code> 将从光标到行尾的字母变为大写。</li>
<li><code>j</code> 移动到下一行。</li>
<li><code>q</code> 停止记录。</li>
</ul>
<p>调用 <code>@a</code> 去执行该宏命令。就像其他的宏命令一样，你也可以为该命令加一个计数。例如，你可以通过 <code>3@a</code> 去执行 <code>a</code> 命令3次。你也可以执行 <code>3@@</code> 去执行上一次执行过的宏命令3次。</p>
<h2 id="安全保护"><a href="#安全保护" class="headerlink" title="安全保护"></a>安全保护</h2><p>在执行遇到错误的时候，宏命令会自动停止。假如你有如下文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a. chocolate donut</span><br><span class="line">b. mochi donut</span><br><span class="line">c. powdered sugar donut</span><br><span class="line">d. plain donut</span><br></pre></td></tr></table></figure>


<p>你想将每一行的第一个词变为大写，你可以使用如下的宏命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qa0W~jq</span><br></pre></td></tr></table></figure>


<p>上面命令的分解如下：</p>
<ul>
<li><code>qa</code> 开始记录一个宏定义并存储在 a 寄存器。</li>
<li><code>0</code> 移动到行首。</li>
<li><code>W</code> 移动到下一个单词。</li>
<li><code>~</code> 将光标选中的单词变为大写。</li>
<li><code>j</code> 移动到下一行。</li>
<li><code>q</code> 停止记录。</li>
</ul>
<p>我喜欢对宏命令进行很多次的调用，所以我通常使用 <code>99@a</code> 命令去执行该宏命令99次。当 Vim 在最后一行执行 <code>j</code> 命令的时候，会发现已经没有下一行可以继续，遇到执行的错误，因此宏命令会停止。</p>
<p>实际上，遇到错误自动停止运行是一个很好的特性。否则，Vim 会继续执行该命令99次，尽管它已经执行到最后一行了。</p>
<h2 id="命令行执行宏"><a href="#命令行执行宏" class="headerlink" title="命令行执行宏"></a>命令行执行宏</h2><p>在正常模式执行 <code>@a</code> 并不是宏命令调用的唯一方式。你也可以在命令行执行 <code>：normal @a</code> 。<code>：normal</code> 会将任何用户添加的参数作为命令去执行。例如添加 <code>@a</code>，和在 normal mode 执行 <code>@a</code> 的效果是一样的。</p>
<p><code>:normal</code> 命令也支持范围参数。你可以在选择的范围内去执行宏命令。如果你只想在第二行和第三行执行宏命令，你可以执行 <code>：2,3 normal @a</code>。我会在后续的章节中介绍更多关于在命令行中执行的命令。</p>
<h2 id="在多个文件中执行宏命令"><a href="#在多个文件中执行宏命令" class="headerlink" title="在多个文件中执行宏命令"></a>在多个文件中执行宏命令</h2><p>假如你有很多的 <code>.txt</code> 文件，每一个文件包含不同的内容。并且你只想将包含有 “donut” 单词的行的第一个单词变为大写。那么，该如何在很多文件中特定的行执行执行变该操作呢？</p>
<p>第一个文件:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># savory.txt</span><br><span class="line">a. cheddar jalapeno donut</span><br><span class="line">b. mac n cheese donut</span><br><span class="line">c. fried dumpling</span><br></pre></td></tr></table></figure>


<p>第二个文件:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># sweet.txt</span><br><span class="line">a. chocolate donut</span><br><span class="line">b. chocolate pancake</span><br><span class="line">c. powdered sugar donut</span><br></pre></td></tr></table></figure>


<p>第三个文件:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># plain.txt</span><br><span class="line">a. wheat bread</span><br><span class="line">b. plain donut</span><br></pre></td></tr></table></figure>


<p>你可以这么做:</p>
<ul>
<li><code>:args *.txt</code> 查找当前目录下的所有 <code>.txt</code> 文件。</li>
<li><code>:argdo g/donut/normal @a</code> 在所有 <code>:args</code> 中包含的文件里执行一个全局命令 <code>g/donut/normal @a</code>。</li>
<li><code>:argdo update</code> 在所有 <code>:args</code> 中包含的文件里执行 <code>update</code> 命令会将修改后的内容保存下来。</li>
</ul>
<p>如果你对全局命令 <code>:g/donut/normal @a</code> 不是很了解的话，该命令会在包含有 <code>/donut/</code> 中的所有行执行<code>normal @a</code> 命令。我会在后面的章节中介绍全局命令。</p>
<h2 id="递归执行宏命令"><a href="#递归执行宏命令" class="headerlink" title="递归执行宏命令"></a>递归执行宏命令</h2><p>你可以递归地执行宏命令，通过在记录宏命令时调用相同的宏来实现。假如你有如下文本，你希望改变第一个单词的大小写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a. chocolate donut</span><br><span class="line">b. mochi donut</span><br><span class="line">c. powdered sugar donut</span><br><span class="line">d. plain donut</span><br></pre></td></tr></table></figure>


<p>如下命令会递归地执行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qaqqa0W~j@aq</span><br></pre></td></tr></table></figure>


<p>上面命令的分解如下：</p>
<ul>
<li><code>qaq</code> 记录一个空白的宏命令到 “a” 。把宏命令记录在一个空白的命令中是必须的，因为你不会想将该命令包含有任何其他的东西。</li>
<li><code>qa</code> 开始录入宏命令到寄存器 “a”。</li>
<li><code>0</code> 移动到行首。</li>
<li><code>W</code> 移动到下一个单词。</li>
<li><code>~</code> 改变光标选中的单词的大小写。</li>
<li><code>j</code> 移动到下一行。</li>
<li><code>@a</code> 执行宏命令 “a”。当你记录该宏命令时，<code>@a</code> 应该是空白的，因为你刚刚调用了 <code>qaq</code>。</li>
<li><code>q</code> 停止记录。</li>
</ul>
<p>现在，让我们调用 <code>@a</code> 来查看 Vim 如何递归的调用该宏命令。</p>
<p>宏命令是如何知道何时停止呢？当宏执行到最后一行并尝试 <code>j</code> 命令时，发现已经没有下一行了，就会停止执行。</p>
<h2 id="增添一个已知宏"><a href="#增添一个已知宏" class="headerlink" title="增添一个已知宏"></a>增添一个已知宏</h2><p>如果你想在一个已经录制好的宏定义中添加更多的操作，与其重新录入它，不如选择修改它。在寄存器一章中，你学习了如何使用一个已知寄存器的大写字母来添加一个新的寄存器。为了在寄存器“a”中添加更多的操作，你可以使用“A”。假设你不仅希望将第一个单词变为大写，也希望在每一行末尾添加一个句点。</p>
<p>假设当前寄存器“a”中有如下的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0W~</span><br></pre></td></tr></table></figure>


<p>你可以这样做:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qAA.&lt;esc&gt;q</span><br></pre></td></tr></table></figure>


<p>分解如下:</p>
<ul>
<li><code>qA</code> 开始在寄存器 “A” 中记录宏命令。</li>
<li><code>A.&lt;esc&gt;</code> 在行的末尾（<code>A</code>）假如一个句点，并且退出插入模式。</li>
<li><code>q</code> 停止记录宏命令。</li>
</ul>
<p>现在，当你执行 <code>@a</code> 时，它会跳到行的第一个字符（<code>0</code>），跳到下一个单词（<code>W</code>），改变光标选中的字母的大小写（<code>~</code>），移动到最后一行并且转到插入模式（<code>A</code>），写入一个句点（<code>.</code>），退出插入模式（<code>&lt;esc&gt;</code>）。</p>
<h2 id="修改一个已知宏"><a href="#修改一个已知宏" class="headerlink" title="修改一个已知宏"></a>修改一个已知宏</h2><p>在已存在的宏定义的末尾添加新的动作是一个很好的功能，但假如你希望在一个宏命令的中间添加动作该怎么做呢？本节，我会向你展示如何修改一个宏。</p>
<p>假设，在改变第一个单词的大小写和在末尾加入一个句点之间，你想要在单词 “donut” 之前加入 “deep fried”（因为唯一比甜甜圈好的东西就是炸甜甜圈）。</p>
<p>我会重新使用上一节使用过的文本:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a. chocolate donut</span><br><span class="line">b. mochi donut</span><br><span class="line">c. powdered sugar donut</span><br><span class="line">d. plain donut</span><br></pre></td></tr></table></figure>


<p>首先，让我们通过 <code>:put a</code> 调用一个已经录制好的宏命令（假设你已经有了上一节中使用过的宏命令）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0W~A.^[</span><br></pre></td></tr></table></figure>


<p><code>^[</code> 是什么意思呢？不记得了吗，你之前执行过 <code>0W~A.&lt;esc&gt;</code>。 <code>^[</code> 是 Vim 的内部指令，表示 <code>&lt;esc&gt;</code>。通过这些指定的键值组合，Vim 知道这些是内部代码的一些替代。一些常见的内部指令具有类似的替代，例如 <code>&lt;esc&gt;</code>，<code>&lt;backspace&gt;</code>，<code>&lt;enter&gt;</code>。还有一些其他的键值组合，但这不是本章的内容。</p>
<p>回到宏命令，在改变大小写之后的键后面（<code>~</code>），让我们添加（<code>$</code>）来移动光标到行末，回退一个单词（<code>b</code>），进入插入模式（<code>i</code>），输入“deep fried ”（别忽略“fried ” 后面的这个空格），之后退出插入模式（<code>&lt;esc&gt;</code>）。</p>
<p>完整的命令如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0W~$bideep fried &lt;esc&gt;A.^[</span><br></pre></td></tr></table></figure>


<p>这里有一个问题，Vim 不能理解 <code>&lt;esc&gt;</code>。所以你需要将其替换为内部代码的形式。在插入模式，在按下<code>&lt;esc&gt;</code>后按下 <code>Ctrl-v</code>，Vim 会打印 <code>^[</code>。 <code>Ctrl-v</code> 是一个插入模式的操作符，可以逐字地插入一个非数字字符。你的宏命令应该如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0W~$bideep fried ^[A.^[</span><br></pre></td></tr></table></figure>


<p>为了在寄存器“a”中添加修改后的指令，你可以通过在一个已知寄存器中添加一个新入口的方式来实现。在一行的行首，执行 <code>&quot;ay$</code>。这将会告诉 Vim 你打算使用寄存器 “a” （<code>&quot;a</code>） 来存储从当前位置到行末的文本（<code>y$</code>）。</p>
<p>现在，但你执行 <code>@a</code> 时，你的宏命令会自动改变第一个单词的大小写，在“donut”前面添加“deep fried”，之后在行末添加“.”。</p>
<p>另一个修改宏命令的方式是通过命令行解析。执行 <code>:let @a=&quot;</code>，之后执行 <code>Ctrl-r Ctrl-r a</code>，这会将寄存器“a”的命令逐字打印出来。最后，别忘记在闭合的引号（<code>&quot;</code>）。如果你希望在编辑命令行表达式时插入内部码来使用特定的字符，你可以使用 <code>Ctrl-v</code>。</p>
<h2 id="拷贝宏"><a href="#拷贝宏" class="headerlink" title="拷贝宏"></a>拷贝宏</h2><p>你可以很轻松的将一个寄存器的内容拷贝到另一个寄存器。例如，你可以使用 <code>:let @z = @a</code> 将寄存器“a” 中的命令拷贝到寄存器“z”。 <code>@a</code> 表示寄存器“a”中存储的内容，你现在执行 <code>@z</code>，将会执行和 <code>@a</code> 一样的指令。</p>
<p>我发现对常用的宏命令创建冗余是很有用的。在我的工作流程中，我通常在前7个字母（a-g）上创建宏命令，并且我经常不加思索地把它们替换了。因此，如果我将很有用的宏命令移动到了字母表的末尾，就不用担心我在无意间把他们替换了。</p>
<h2 id="连续执行宏命令"><a href="#连续执行宏命令" class="headerlink" title="连续执行宏命令"></a>连续执行宏命令</h2><p>Vim 可以连续和同时运行宏命令，假设你有如下的文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123; FUNC1 &#125; from &quot;library1&quot;;</span><br><span class="line">import &#123; FUNC2 &#125; from &quot;library2&quot;;</span><br><span class="line">import &#123; FUNC3 &#125; from &quot;library3&quot;;</span><br><span class="line">import &#123; FUNC4 &#125; from &quot;library4&quot;;</span><br><span class="line">import &#123; FUNC5 &#125; from &quot;library5&quot;;</span><br></pre></td></tr></table></figure>


<p>假如你希望把所有的 “FUNC” 字符变为小写，那么宏命令为如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qa0f&#123;gui&#123;jq</span><br></pre></td></tr></table></figure>


<p>分解如下：</p>
<ul>
<li><code>qa</code> 开始记录宏命令到 “a” 寄存器。</li>
<li><code>0</code>移动到第一行。</li>
<li><code>f&#123;</code> 查找第一个 “{” 字符。</li>
<li><code>gui&#123;</code> 把括号内的文本（<code>i&#123;</code>）变为小写（<code>gu</code>）。</li>
<li><code>j</code> 移动到下一行。</li>
<li><code>q</code> 停止记录宏命令。</li>
</ul>
<p>现在，执行 <code>99@a</code> 在剩余的行修改。然而，假如在你的文本里有如下 import 语句会怎么样呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; FUNC1 &#125; from &quot;library1&quot;;</span><br><span class="line">import &#123; FUNC2 &#125; from &quot;library2&quot;;</span><br><span class="line">import &#123; FUNC3 &#125; from &quot;library3&quot;;</span><br><span class="line">import foo from &quot;bar&quot;;</span><br><span class="line">import &#123; FUNC4 &#125; from &quot;library4&quot;;</span><br><span class="line">import &#123; FUNC5 &#125; from &quot;library5&quot;;</span><br></pre></td></tr></table></figure>


<p>执行 <code>99@a</code>，会只在前三行执行。而最后两行不会被执行，因为在执行第四行（包含“foo”）时会遇到错误而停止。然而这种情况你希望继续向下执行。你可以移动到包含（“FUNC4”）的一行，并重新调用该命令。但是假如你希望仅调用一次命令就完成所有操作呢？你可以并行地执行宏命令。</p>
<p>如本章前面所说，可以使用 <code>:normal</code> 去执行宏命令，（例如： <code>:3,5 normal @a</code> 会在 3-5行执行 a 寄存器中的宏命令）。如果执行 <code>:1,$ normal @a</code>，会在所有除了包含有 “foo” 的行执行，而且它不会出错。</p>
<p>尽管本质上来说，Vim 并不是在并行地执行宏命令，但表面上看，它是并行运行的。 Vim 会独立地在从第一行开始（<code>1,$</code>）每一行执行 <code>@a</code> 。由于 Vim 独立地在每一行执行命令，每一行都不会知道有一行（包含“foo”）会遇到执行错误。</p>
<h2 id="聪明地学习宏命令"><a href="#聪明地学习宏命令" class="headerlink" title="聪明地学习宏命令"></a>聪明地学习宏命令</h2><p>你在编辑器里做的很多事都是重复的。为了更好地编辑文件，请乐于发现这些重复性的行为。执行宏命令或者点命令，而不是做相同的动作两次。几乎所有你在 Vim 所作的事情都可以变为宏命令。</p>
<p>刚开始的时候，我发现宏命令时很棘手的，但是请不要放弃。有了足够的练习，你可以找到这种文本自动编辑的快乐。</p>
<p>使用某种助记符去帮助你记住宏命令是很有帮助的。如果你有一个创建函数（function）的宏命令，你可以使用 “f” 寄存器去录制它。如果你有一个宏命令去操作数字，那么使用寄存器 “n” 去记住它是很好的。用你想执行的操作时想起的第一个字符给你的宏命令命名。另外，我发现 “q” 是一个很好的宏命令的寄存器，因为执行 “qq” 去调用宏命令是很快速而简单的。最后，我喜欢按照字母表的顺序去添加我的宏命令，例如从 <code>qa</code> 到 <code>qb</code> 再到 <code>qc</code>。去寻找最适合你的方法吧。</p>
<h1 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h1><p>对于任何一个现代的软件来说，撤销都是一个很基本的特性。 Vim 的撤销系统不仅支持撤销和取消撤销任何修改，而且支持改动时间线功能。 在本章中，你将会学会如何执行撤销和 取消撤销文本，浏览撤销分支，反复撤销, 以及浏览改动时间线。</p>
<h2 id="Undo，Redo，和-UNDO"><a href="#Undo，Redo，和-UNDO" class="headerlink" title="Undo，Redo，和 UNDO"></a>Undo，Redo，和 UNDO</h2><p>对于一个基本的 undo 操作，你可以执行 <code>u</code> 或者 <code>:undo</code>。<br>假设你有如下文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one</span><br></pre></td></tr></table></figure>


<p>以及另一个文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br></pre></td></tr></table></figure>


<p>如果你执行 <code>u</code>，Vim 会删除 “two”。<br>Vim 是如何知道应该恢复多少修改呢？ 答案是，Vim每次仅恢复一次修改，这有点类似于点命令的操作（和 点命令不同之处在于，命令行命令也会被算作一次修改）。</p>
<p>为了取消上一次的撤销，执行 <code>Ctrl-R</code> 或者 <code>:redo</code>。例如上面的例子中，当你执行撤销来删除 “two” 以后，你可以执行 <code>Ctrl-R</code> 来恢复被删除掉的文本。</p>
<p>Vim 也有另一个命令 <code>U</code> 可以实现 UNDO 的功能，执行这个命令会撤销所有最新的修改。<br>那么，<code>U</code> 和 <code>u</code> 的区别是什么呢？首先，<code>U</code> 会删除 <em>所有的</em> 最新的修改，而 <code>u</code> 一次仅删除一次修改。 其次，执行<code>u</code> 不会被算作一次修改，而执行 <code>U</code> 则会被算作一次修改。</p>
<p>让我们会的之前的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br></pre></td></tr></table></figure>


<p>修改第二行的内容为 “three” (<code>ciwthree&lt;esc&gt;</code>):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">three</span><br></pre></td></tr></table></figure>


<p>再次修改第二行的例子为 “four” (<code>ciwfour&lt;esc&gt;</code>):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">four</span><br></pre></td></tr></table></figure>


<p>此时，如果你按下 <code>u</code>，你会看到 “three”。如果你再次按下 <code>u</code>，你会看到 “two”。然而，在第二行任为 “four” 的时候，如果你按下 <code>U</code>，你会看到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one</span><br></pre></td></tr></table></figure>


<p>执行 <code>U</code> 会跳过中间所有修改，直接恢复到文件最初的状态（第二行为空）。另外，由于 UNO 实际上是执行了一个新的修改，因此你可以 UNDO 执行过的 UNDO。 执行 <code>U</code> 后 再次执行 <code>U</code> 会撤销 自己。假如你连续执行 <code>U</code>，那么你将看到第二行的文本不停地出现和消失。</p>
<p>就我个人而言，我几乎不会使用 <code>U</code>，因为很难记住文本最初的样子。如果非说在什么场景下使用 <code>U</code>，那就是在我意外地执行了 <code>Shift-u</code>。</p>
<p>Vim 可以通过变量 <code>undolevels</code> 来选择最多可执行 undo 的次数。你可以通过 <code>:echo &amp;undolevels</code> 来查看当前的配置。我一般设置为 1000。如果你也想设置为 1000 的话，你可以执行 <code>:set undolevels=1000</code>。不用担心，你可以设置它为任何一个你想设置的值。</p>
<h2 id="断点插入操作"><a href="#断点插入操作" class="headerlink" title="断点插入操作"></a>断点插入操作</h2><p>在上文中我提到，<code>u</code> 每次恢复一个修改，类似于点命令。在每次进入 插入模式和退出插入模式之间的任何修改都被定义为一次修改。</p>
<p>如果你执行 <code>ione two three&lt;esc&gt;</code> 之后，按下 <code>u</code>，Vim 会同时删除 “one two three”，因为这是一笔修改。如果你每次只输入较短的文本，那这是可接受的；可假设你在一次插入模式中输入了大量的文本，而后退出了插入模式，可很快你意识到这中间有部分错误。此时，如果你按下 <code>u</code>，你会丢失上一次输入的所有内容。 因此，假设你按下 <code>u</code> 只删除你上一次输入的一部分文本岂不是会更好。</p>
<p>幸运的是，你可以拆分它。当你在插入模式时，按下 <code>Ctrl-G u</code> 会生成一个断点。例如，如果你执行 <code>ione &lt;Ctrl-G u&gt;two &lt;Ctrl-G u&gt;three&lt;esc&gt;</code>，之后你按下<code>u</code>，你仅会失去文本 “three”，再次执行 <code>u</code>，会删除 “two”。当你想要输入一长段内容时，应该有选择性地执行断点插入操作。在每一句话的末尾，两个段落的中间，或者每一行代码结束时插入断点是一个很好的选择，这可以帮助你快速从错误中恢复出来。</p>
<p>在执行删除操作后插入断点也非常有用，例如通过 <code>Ctrl-W</code> 删除光标前的单词，以及 <code>Ctrl-U</code>删除光标前的所有文本。一个朋友建议我使用如下的映射：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inoremap &lt;c-u&gt; &lt;c-g&gt;u&lt;c-u&gt;</span><br><span class="line">inoremap &lt;c-w&gt; &lt;c-g&gt;u&lt;c-w&gt;</span><br></pre></td></tr></table></figure>


<p>通过上述命令，你可以很轻松地恢复被删除的文本。</p>
<h2 id="撤销树"><a href="#撤销树" class="headerlink" title="撤销树"></a>撤销树</h2><p>Vim 将每一次修改存储在一个撤销树中。如果你打开一个空白文件:</p>
<p>插入一段话：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one</span><br></pre></td></tr></table></figure>


<p>插入一段话：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br></pre></td></tr></table></figure>


<p>undo:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one</span><br></pre></td></tr></table></figure>


<p>插入一段不同的话：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">three</span><br></pre></td></tr></table></figure>


<p>再次 undo</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one</span><br></pre></td></tr></table></figure>


<p>插入另一段话：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">four</span><br></pre></td></tr></table></figure>


<p>现在如果你执行 undo:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one</span><br></pre></td></tr></table></figure>


<p>如果你再次执行 undo 操作：</p>
<p>文本 “one” 也会丢失。对于大部分编辑器来说，找回文本 “two” 和 “three” 都是不可能的事情，但是对于 Vim 来说却不是这样。执行 <code>g+</code>，你会得到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one</span><br></pre></td></tr></table></figure>


<p>再次执行 <code>g+</code> ，你将会看到一位老朋友:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br></pre></td></tr></table></figure>


<p>让我们继续执行 <code>g+</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">three</span><br></pre></td></tr></table></figure>


<p>再一次执行 <code>g+</code> :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">four</span><br></pre></td></tr></table></figure>


<p>在 Vim 中，你每一次执行 <code>u</code> 去做一次修改时，Vim都会通过创建一个“撤销分支”来保存下之前的文本内容。在本例中，你先输入“two”, 执行 <code>u</code>，输入“three”，执行 <code>u</code>，然后输入“three”，此时，撤销树已经包含了至少两个叶子节点，主节点包含文本“three”（最新），分支节点包含文本“two”。假如你执行了另一次撤销操作并且输入了“four”，那么此时会生成三个节点，一个主节点包含文本“four”, 以及另外两个节点分别存储了“three”和“two”。</p>
<p>为了在几个不同的节点状态间进行切换，你可以执行 <code>g+</code> 去获取一个较新的状态，以及执行 <code>g-</code> 去获取一个教旧的状态。 <code>u</code>， <code>Ctrl-R</code>， <code>g+</code>， 和 <code>g-</code> 之间的区别是，<code>u</code> and <code>Ctrl-R</code> 只可以在 <em>main</em> 节点之间进行切换，而<code>g+</code> 和 <code>g-</code> 可以在 <em>所有</em> 节点之间进行切换。</p>
<p>Undo 树并不可以很轻松地可视化。我发现一个插件 <a target="_blank" rel="noopener" href="https://github.com/simnalamburt/vim-mundo">vim-mundo</a> 对于理解 undo 树很有帮助。花点时间去与它玩耍吧。</p>
<h2 id="保持撤销状态"><a href="#保持撤销状态" class="headerlink" title="保持撤销状态"></a>保持撤销状态</h2><p>当你通过 Vim 打开一个文件，并且立即按下 <code>u</code>，Vim 很可能会显示 “_Already at oldest change_” 的警告。 Vim 可以通过 <code>:wundo</code> 保持一份你的 undo 历史记录。</p>
<p>创建一个文件 <code>mynumbers.txt</code>. 输入:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one</span><br></pre></td></tr></table></figure>


<p>插入另一行文件 (确保你要么退出并重新进入插入模式，要么创建了断点):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br></pre></td></tr></table></figure>


<p>插入新的一行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br></pre></td></tr></table></figure>


<p>现在，创建你的撤销记录文件。 语法为 <code>:wundo myundofile</code>。 如果你需要覆盖一个已存在的文件，在 <code>wundo</code> 之后添加 <code>!</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:wundo! mynumbers.undo</span><br></pre></td></tr></table></figure>


<p>退出 Vim。</p>
<p>此时，在目录下，应该有<code>mynumbers.txt</code> 和 <code>mynumbers.undo</code> 两个文件。再次打开 <code>mynumbers.txt</code> 文件并且按下 <code>u</code>，这是没有响应的。因为自打开文件后，你没有执行任何的修改。现在，通过执行 <code>:rundo</code> 来加载 undo 历史。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:rundo mynumbers.undo</span><br></pre></td></tr></table></figure>


<p>此时，如果你按下 <code>u</code>，Vim 会删除 “three”。再次按下 <code>u</code>可以删除 “two”。这就好像你从来没有关闭过 Vim 一样。</p>
<p>如果你想要自动加载 undo 历史文件，你可以通过在你的 <code>.vimrc</code> 文件中添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set undodir=~/.vim/undo_dir</span><br><span class="line">set undofile</span><br></pre></td></tr></table></figure>


<p>我认为将所有的 undo 文件集中保存在一个文件夹中最好，例如在 <code>~/.vim</code> 目录下。 <code>undo_dir</code> 是随意的。 <code>set undofile</code> 告诉 Vim 打开 <code>undofile</code> 这个特性，因为该特性默认是关闭的。现在，无论你何时保存，Vim 都会自动创建和保存撤销的历史记录（在使用<code>undo_dir</code>目录前，请确保你已经创建了它）。</p>
<h2 id="时间旅行"><a href="#时间旅行" class="headerlink" title="时间旅行"></a>时间旅行</h2><p>是谁说时间旅行不存在。 Vim 可以通过 <code>:earlier</code> 命令将文本恢复为之前的状态。</p>
<p>假如有如下文本:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one</span><br></pre></td></tr></table></figure>


<p>之后你输入了另一行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br></pre></td></tr></table></figure>


<p>如果你输入 “two” 的时间少于10秒，那么你可以通过如下命令恢复到 “two” 还没被输入前的状态:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:earlier 10s</span><br></pre></td></tr></table></figure>


<p>你可以使用 <code>:undolist</code> 去查看之前所做的修改。 <code>:earlier</code> 可以加上分钟 (<code>m</code>), 小时 (<code>h</code>), and 天 (<code>d</code>) 作为参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:earlier 10s    恢复到10秒前的状态</span><br><span class="line">:earlier 10m    恢复到10分钟前的状态</span><br><span class="line">:earlier 10h    恢复到10小时前的状态</span><br><span class="line">:earlier 10d    恢复到10天前的状态</span><br></pre></td></tr></table></figure>


<h2 id="聪明地学习撤销操作"><a href="#聪明地学习撤销操作" class="headerlink" title="聪明地学习撤销操作"></a>聪明地学习撤销操作</h2><p><code>u</code> 和 <code>Ctrl-R</code> 是两个不可缺少的 Vim 参数。请先学会它们。在我的工作流中，我并不使用 UNDO，然而我认为承认它存在是很好的。下一步，学会如何使用<code>:earlier</code> 和 <code>:later</code>，以及时间参数。在这之后，请花些时间理解 undo 树。 插件 <a target="_blank" rel="noopener" href="https://github.com/simnalamburt/vim-mundo">vim-mundo</a> 对我的帮助很大。单独输入本章中展示的文本，并且查看撤销树的每一次改变。一旦你掌握它，你看待撤销系统的眼光一定不同。</p>
<p>在本章之前，你学习了如何在项目内查找任何文本，配合撤销，你可以在时间维度上查找任何一个文本。你现在可以通过位置和写入时间找到任何一个你想找的文本。你已经对 Vim 无所不能了。</p>
<h1 id="可视模式"><a href="#可视模式" class="headerlink" title="可视模式"></a>可视模式</h1><p>您可能知道您可以高亮显示文本块并对其进行更改。 Vim也可以使用可视模式。 Vim有三种不同的可视模式可供使用。在本章中，您将学习如何使用每种可视模式来有效地处理文本块。</p>
<h2 id="三种可视模式"><a href="#三种可视模式" class="headerlink" title="三种可视模式"></a>三种可视模式</h2><p>这三种模式是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v         角色可视模式</span><br><span class="line">V         逐行可视模式</span><br><span class="line">Ctrl-v    逐块可视模式</span><br></pre></td></tr></table></figure>


<p>如果您有文字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br></pre></td></tr></table></figure>


<p>逐字符可视模式用于选择单个字符。在第一行的第一个字符上按<code>v</code>。然后使用<code>j</code>跳转至下一行。它高亮显示从”one”到光标位置的所有文本。现在，如果您按<code>gU</code>，Vim将高亮显示的字符转为大写。</p>
<p>逐行可视模式适用于整行。按<code>V</code>并观看Vim选择光标的所在行。就像逐字符可视模式一样，如果您运行<code>gU</code>，Vim将高亮显示的字符转为大写。</p>
<p>逐块可视模式适用于行和列。与其他两种模式相比，它为您提供了更大的移动自由度。按<code>Ctrl-V</code>。 Vim像逐个字符可视模式一样高亮显示光标下的字符，除了可以在下一行之前不高亮显示每个字符直到行的末尾，它可以转到下一行而不高亮显示当前行的整个字符。尝试用<code>h/j/k/l</code>移动，并观察光标的移动。</p>
<p>在Vim窗口的左下方，您会看到显示<code>-- VISUAL --</code>，<code>-- VISUAL LINE --</code>或<code>-- VISUAL BLOCK --</code>以提示您所处的可视模式。</p>
<p>当您处于可视模式时，可以通过按<code>v</code>，<code>V</code>或<code>Ctrl-V</code>键切换到另一种可视模式。例如，如果您处于逐行可视模式，并且想要切换为逐块可视模式，请运行<code>Ctrl-V</code>。试试吧！</p>
<p>有三种退出可视模式的方法：<code>esc</code>，<code>Ctrl-C</code>和与当前可视模式相同的键。</p>
<p>后者的意思是，如果您当前处于逐行可视模式(<code>V</code>)，则可以通过再次按<code>V</code>退出它。如果您处于字符可视模式，则可以通过按<code>v</code>退出它。如果您处于逐块可视模式，请按<code>Ctrl-V</code>。</p>
<p>实际上，还有另一种进入可视模式的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gv    转到上一个可视模式</span><br></pre></td></tr></table></figure>


<p>它将在与上次相同的高亮显示的文本块上启动相同的可视模式。</p>
<h2 id="可视模式导航"><a href="#可视模式导航" class="headerlink" title="可视模式导航"></a>可视模式导航</h2><p>在可视模式下，您可以使用Vim动作扩展高亮显示的文本块。</p>
<p>让我们使用之前使用的相同文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br></pre></td></tr></table></figure>


<p>这次让我们从”two”行开始。按<code>v</code>进入字符可视模式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">[t]wo</span><br><span class="line">three</span><br></pre></td></tr></table></figure>


<p>按<code>j</code>，Vim将高亮显示从”two”行到”three”行的第一个字符的所有文本。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">[two</span><br><span class="line">t]hree</span><br></pre></td></tr></table></figure>


<p>假设您刚刚意识到还需要高亮显示”one”行，因此按<code>k</code>。令您沮丧的是，它现在排除了”three”。按<code>k</code>实际上会还原高亮，而不是使其高亮。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">[t]wo</span><br><span class="line">three</span><br></pre></td></tr></table></figure>


<p>有没有一种方法可以自由地扩展视觉选择范围，以向您想要的任何方向发展？</p>
<p>答案是肯定的。让我们稍微备份一下高亮显示”two”和”three”行的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">[two</span><br><span class="line">t]hree    &lt;-- 光标</span><br></pre></td></tr></table></figure>


<p>视觉高光跟随光标移动。如果要将其向上扩展到行”one”，则需要在光标位于字母”two”而不是”three”上时向上移动光标。现在，您的光标在”three”行上。要移动它，用<code>o</code>或<code>O</code>切换光标位置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">[two     &lt;-- 光标</span><br><span class="line">t]hree</span><br></pre></td></tr></table></figure>


<p>现在，当您按<code>k</code>时，它不再缩小选择，而是向上扩展。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[one</span><br><span class="line">two</span><br><span class="line">t]hree</span><br></pre></td></tr></table></figure>


<h2 id="可视模式语法"><a href="#可视模式语法" class="headerlink" title="可视模式语法"></a>可视模式语法</h2><p>可视模式是Vim的一种模式。成为一种模式意味着同一键的工作方式可能不同于另一种模式。幸运的是，可视模式与普通模式共享许多常用键。</p>
<p>例如，如果您有以下文字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br></pre></td></tr></table></figure>


<p>用逐行可视模式(<code>V</code>)高亮显示”one”和”two”行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[one</span><br><span class="line">two]</span><br><span class="line">three</span><br></pre></td></tr></table></figure>


<p>按下<code>d</code>键将删除选择，类似于普通模式。请注意，普通模式的语法规则动词+名词不适用。仍然存在相同的动词(<code>d</code>)，但在可视模式下没有名词。可视模式下的语法规则是名词+动词，其中名词是高亮显示的文本。首先选择文本块，然后进行操作。</p>
<p>在普通模式下，有一些命令不需要移动，例如<code>x</code>删除光标下方的单个字符，<code>rx</code>替换光标下方的字符为<code>x</code>。在可视模式下，这些命令现在将应用于整个高亮显示的文本，而不是单个字符。返回高亮显示的文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[one</span><br><span class="line">two]</span><br><span class="line">three</span><br></pre></td></tr></table></figure>


<p>运行<code>x</code>会删除所有高亮显示的文本。</p>
<p>您可以使用此行为在markdown文本中快速创建标题。假设您在markdown文件中有一个文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Chapter One</span><br></pre></td></tr></table></figure>


<p>您需要快速将此标题转换为标题。首先，您使用<code>yy</code>复制文本，然后使用<code>p</code>粘贴文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Chapter One</span><br><span class="line">Chapter One</span><br></pre></td></tr></table></figure>


<p>现在转到第二行，以逐行可视模式选择它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Chapter One</span><br><span class="line">[Chapter One]</span><br></pre></td></tr></table></figure>


<p>在markdown中，您可以通过在文本下方添加一系列<code>=</code>来创建标题，因此您可以通过运行<code>r=</code>来替换整个高亮显示的文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Chapter One</span><br><span class="line">===========</span><br></pre></td></tr></table></figure>


<p>要了解有关可视模式下的运算符的更多信息，请查看<code>:h visual-operators</code>。</p>
<h2 id="可视模式和Ex命令"><a href="#可视模式和Ex命令" class="headerlink" title="可视模式和Ex命令"></a>可视模式和Ex命令</h2><p>您可以有选择地在高亮显示的文本块上应用Ex命令。如果您具有以下表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const one = &quot;one&quot;;</span><br><span class="line">const two = &quot;two&quot;;</span><br><span class="line">const three = &quot;three&quot;;</span><br></pre></td></tr></table></figure>


<p>您只需要用”let”替换”const”的前两行。用_任何_可视模式高亮显示前两行，然后运行替代命令<code>:s/const/let/g</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let one = &quot;one&quot;;</span><br><span class="line">let two = &quot;two&quot;;</span><br><span class="line">const three = &quot;three&quot;;</span><br></pre></td></tr></table></figure>


<p>请注意，我说过您可以使用_任何_可视模式执行此操作。您不必高亮显示整个行即可在该行上运行Ex命令。只要您在每行上至少选择一个字符，就会应用Ex命令。</p>
<h2 id="跨多行编辑"><a href="#跨多行编辑" class="headerlink" title="跨多行编辑"></a>跨多行编辑</h2><p>您可以使用逐块可视模式在Vim中跨多行编辑文本。如果需要在每行末尾添加分号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const one = &quot;one&quot;</span><br><span class="line">const two = &quot;two&quot;</span><br><span class="line">const three = &quot;three&quot;</span><br></pre></td></tr></table></figure>


<p>将光标放在第一行上：<br>-运行逐块可视模式，并向下两行(<code>Ctrl-V jj</code>)。<br>-高亮显示到行尾(<code>$</code>)。<br>-附加(<code>A</code>) ，然后键入”;”。<br>-退出可视模式(<code>esc</code>)。</p>
<p>您应该看到附加的 “;” 在每一行上。顺便说一下，在逐块可视模式下，要进入插入模式，可以使用<code>A</code>在光标后输入文本，也可以使用<code>I</code>在光标前输入文本。请勿将它们与正常模式下的<code>A</code>和<code>I</code>混淆。</p>
<p>另外，您也可以使用<code>:normal</code>命令：</p>
<p>-高亮显示所有3行(<code>vjj</code>)。<br>-输入<code>:normal! A;</code>。</p>
<p>记住，<code>:normal</code>命令执行普通模式命令。您可以指示它运行<code>A;</code>来添加文本”;”在该行的末尾。</p>
<h2 id="递增数字"><a href="#递增数字" class="headerlink" title="递增数字"></a>递增数字</h2><p>Vim有<code>Ctrl-X</code>和<code>Ctrl-A</code>命令来减少和增加数字。与可视模式一起使用时，可以跨多行递增数字。</p>
<p>如果您具有以下HTML元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app-1&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-1&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-1&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-1&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-1&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>


<p>有多个具有相同名称的id是一个不好的做法，因此让我们对其进行递增以使其唯一：<br>-将光标移动到_第二个_”1”。<br>-启动逐块可视模式，并向下移动3行(<code>Ctrl-V 3j</code>)。这高亮显示剩余的”1”s。<br>-运行<code>g Ctrl-A</code>。</p>
<p>您应该看到以下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app-1&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-2&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-3&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-4&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-5&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>


<p><code>g Ctrl-A</code>在多行上递增数字。 <code>Ctrl-X/Ctrl-A</code>也可以增加字母。如果您运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set nrformats+=alpha</span><br></pre></td></tr></table></figure>


<p><code>nrformats</code>选项指示Vim将哪个基数视为<code>Ctrl-A</code>和<code>Ctrl-X</code>递增和递减的“数字”。通过添加<code>alpha</code>，现在将字母字符视为数字。如果您具有以下HTML元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app-a&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-a&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-a&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-a&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-a&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>


<p>将光标放在第二个”app-a”上。使用与上述相同的技术(<code>Ctrl-V 3j</code> 然后 <code>g Ctrl-A</code>)增加ID。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app-a&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-b&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-c&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-d&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-e&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>


<h2 id="选择最后一个可视模式区域"><a href="#选择最后一个可视模式区域" class="headerlink" title="选择最后一个可视模式区域"></a>选择最后一个可视模式区域</h2><p>您了解到<code>gv</code>可以快速高亮显示上一个可视模式。您还可以使用以下两个特殊标记转到最后一个可视模式的开始和结束位置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`&lt;    转到上一个可视模式高亮显示的最后一个位置</span><br><span class="line">`&gt;    转到上一个可视模式高亮显示的第一位</span><br></pre></td></tr></table></figure>


<p>我要你观察一些东西。之前，我提到过您可以在高亮显示的文本上有选择地执行Ex命令，例如：<code>:s/const/let/g</code>。当您这样做时，您应该看到以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:`&lt;,`&gt;s/const/let/g</span><br></pre></td></tr></table></figure>


<p>您实际上是在使用标记作为范围来执行<code>s/const/let/g</code>命令。您随时可以随时编辑这些标记。相反，如果您需要从高亮显示的文本的开头到文件的末尾进行替换，则只需将命令行更改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:`&lt;,$s/const/let/g</span><br></pre></td></tr></table></figure>


<h2 id="从插入模式进入可视模式"><a href="#从插入模式进入可视模式" class="headerlink" title="从插入模式进入可视模式"></a>从插入模式进入可视模式</h2><p>您也可以从插入模式进入可视模式。在插入模式下进入字符可视模式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ctrl-O v</span><br></pre></td></tr></table></figure>


<p>回想一下，在插入模式下运行<code>Ctrl-O</code>可以使您执行普通模式命令。在正常模式命令挂起模式下，运行<code>v</code>进入逐字可视模式。请注意，在屏幕的左下方，它显示为<code>--(insert) VISUAL--</code>。该技巧适用于任何可视模式运算符：<code>v</code>，<code>V</code>，和<code>Ctrl-V</code>。</p>
<h2 id="选择模式"><a href="#选择模式" class="headerlink" title="选择模式"></a>选择模式</h2><p>Vim具有类似于可视模式的模式，称为_选择模式_。与可视模式一样，它也具有三种不同的模式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gh         逐字符选择模式</span><br><span class="line">gH         逐行选择模式</span><br><span class="line">gCtrl-h    逐块选择模式</span><br></pre></td></tr></table></figure>


<p>选择模式比Vim的可视模式更接近常规编辑器的文本高亮显示行为。</p>
<p>在常规编辑器中，高亮显示文本块并键入字母（例如字母”y”）后，它将删除高亮显示的文本并插入字母”y”。</p>
<p>如果您使用逐行选择模式(<code>gH</code>)高亮显示一行文本并键入”y”，它将删除高亮显示的文本并插入字母”y”，这与常规文本编辑器非常相似。</p>
<p>将此行为与可视模式进行对比：如果您使用逐行可视模式(<code>V</code>)高亮显示一行文本并键入”y”，则高亮显示的文本不会被删除，而是由文字字母”y”代替。仅将其拉动并存储在拉动寄存器<code>&quot;0</code>中。</p>
<p>我个人从未使用过选择模式，但是很高兴知道它的存在。</p>
<h2 id="以聪明的方式学习可视模式"><a href="#以聪明的方式学习可视模式" class="headerlink" title="以聪明的方式学习可视模式"></a>以聪明的方式学习可视模式</h2><p>可视模式是Vim高亮显示文本的过程。</p>
<p>如果发现使用可视模式操作的频率比正常模式操作的频率高得多，请当心。我认为这是一种反模式。运行可视模式操作所需的击键次数要多于普通模式下的击键次数。如果您需要删除一个内部单词，那么为什么只用三个按键(<code>diw</code>)就可以使用四个按键<code>viwd</code>（在视觉上高亮显示一个内部单词然后删除）呢？后者更为直接和简洁。当然，有时会使用适当的可视模式，但总的来说，更倾向于直接的方法。</p>
<h1 id="搜索和替换"><a href="#搜索和替换" class="headerlink" title="搜索和替换"></a>搜索和替换</h1><p>本章涵盖两个独立但相关的概念:搜索和替代。很多时候，您要搜索的文本并不简单，你必须寻找一个共同的模式。通过学习如何在搜索和替换中使用有意义的模式而不是文字，您将能够快速定位任何文本。</p>
<p>附带说明一下，在本章中，当谈论搜索时，我将主要使用<code>/</code>。您可以使用<code>/</code>进行的所有操作也可以使用<code>?</code>完成。</p>
<h2 id="智能区分大小写"><a href="#智能区分大小写" class="headerlink" title="智能区分大小写"></a>智能区分大小写</h2><p>尝试匹配搜索词的大小写可能会很棘手。如果要搜索文本”Learn Vim”，则很容易错误键入一个字母的大小写，并得到错误的搜索结果。如果可以匹配任何情况，会不会更轻松，更安全？这是选项<code>ignorecase</code>闪亮的地方。只需在 vimrc 中添加<code>setignorecase</code>，所有搜索词就不区分大小写。现在，您不必再执行<code>/Learn Vim</code>了。 <code>/learn vim</code>将起作用。</p>
<p>但是，有时您需要搜索特定于案例的短语。一种方法是用 <code>set ignorecase</code> 关闭<code>ignorecase</code>选项，但是每次需要搜索区分大小写的短语时，都要打开和关闭很多工作。</p>
<p>是否有一种设置可以让您在大多数时间进行不区分大小写的搜索，但又知道在需要时进行区分大小写的搜索？原来有办法。</p>
<p>如果搜索模式_至少包含一个大写字符_，Vim 有一个<code>smartcase</code>选项来覆盖<code>ignorecase</code>。当您输入所有小写字符时，您可以将”ignorecase”和”smartcase”结合使用以执行不区分大小写的搜索，而输入一个或多个大写字符时则执行区分大小写的搜索。</p>
<p>在您的 vimrc 中，添加:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set ignorecase smartcase</span><br></pre></td></tr></table></figure>


<p>如果您有这些文字:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">HELLO</span><br><span class="line">Hello</span><br></pre></td></tr></table></figure>


<p>您可以使用搜索词的大小写来控制不区分大小写:</p>
<ul>
<li><code>/hello</code> 匹配”hello”，”HELLO”和”Hello”。</li>
<li><code>/HELLO</code> 仅匹配”HELLO”。</li>
<li><code>/Hello</code> 仅匹配”Hello”。</li>
</ul>
<p>有一个缺点。 如果只需要搜索小写字符串怎么办？<br>当您执行<code>/hello</code>时，Vim 将始终匹配其大写变体。<br>如果您不想匹配它们怎么办？您可以在搜索词前使用<code>\C</code>模式来告诉 Vim，<br>后续搜索词将区分大小写。如果执行<code>/\Chello</code>，它将严格匹配”hello”，而不是”HELLO”或”Hello”。</p>
<h2 id="一行中的第一个和最后一个字符"><a href="#一行中的第一个和最后一个字符" class="headerlink" title="一行中的第一个和最后一个字符"></a>一行中的第一个和最后一个字符</h2><p>您可以使用<code>^</code>匹配行中的第一个字符，并使用<code>$</code>匹配行中的最后一个字符。</p>
<p>如果您有以下文字:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello hello</span><br></pre></td></tr></table></figure>


<p>您可以使用<code>/^hello</code>来定位第一个”hello”。 ^后面的字符必须是一行中的第一个字符。 要定位最后一个”hello”，请运行<code>/hello$</code>。 $之前的字符必须是一行中的最后一个字符。</p>
<p>如果您有以下文字:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello hello friend</span><br></pre></td></tr></table></figure>


<p>运行<code>/hello$</code>将匹配不到任何内容，因为”friend”是该行的最后一项，而不是”hello”。</p>
<h2 id="重复搜索"><a href="#重复搜索" class="headerlink" title="重复搜索"></a>重复搜索</h2><p>您可以使用”//“重复上一个搜索。如果您只是搜索<code>/hello</code>，则运行<code>//</code>等同于运行<code>/hello</code>。此快捷键可以为您节省一些按键操作，尤其是在您搜索了很长时间的情况下。还记得您还可以使用”n”和”N”分别以相同方向和相反方向重复上一次搜索。</p>
<p>如果您想快速回忆起_n_个最后一个搜索字词怎么办？您可以先遍历<code>/</code>，然后按“向上”/“向下”箭头键（或<code>Ctrl-N</code>/<code>Ctrl-P</code>），快速遍历搜索历史，直到找到所需的搜索词。要查看所有搜索历史，可以运行<code>:history/</code>。</p>
<p>在搜索过程中到达文件末尾时，Vim 会引发错误:<code>&quot;搜索未找到匹配项的底部:&lt;your-search&gt;&quot;</code>(<code>&quot;Search hit the BOTTOM without match for: &lt;your-search&gt;&quot;</code>)。有时，这可以防止过度搜索，但是有时您又想将搜索重新循环到顶部。您可以使用<code>set wrapscan</code>选项使 Vim 在到达文件末尾时在文件顶部进行搜索。要关闭此功能，请执行<code>set nowrapscan</code>。</p>
<h2 id="搜索替代词"><a href="#搜索替代词" class="headerlink" title="搜索替代词"></a>搜索替代词</h2><p>通常一次搜索多个单词。 如果您需要搜索”hello vim”或”hola vim”，而不是”salve vim”或”bonjour vim”，则可以使用||管道替代语法。</p>
<p>给予这样一段文本:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello vim</span><br><span class="line">hola vim</span><br><span class="line">salve vim</span><br><span class="line">bonjour vim</span><br></pre></td></tr></table></figure>


<p>要同时匹配”hello”和”hola”，可以执行<code>/hello\|hola</code>。 您必须转义（<code>\</code>）管道（<code>|</code>）运算符，否则 Vim 将按字面意义搜索字符串”|”。</p>
<p>如果您不想每次都输入<code>\|</code>，则可以在搜索开始时使用<code>魔术</code>语法（<code>\v</code>）:<code>/\vhello|hola</code>。 我不会在本章中介绍“魔术”，但是有了”\v”，您就不必再转义特殊字符了。 要了解有关<code>\v</code>的更多信息，请随时查看<code>:h \v</code>。</p>
<h2 id="设置比赛的开始和结束"><a href="#设置比赛的开始和结束" class="headerlink" title="设置比赛的开始和结束"></a>设置比赛的开始和结束</h2><p>也许您需要搜索作为复合词一部分的文本。 如果您有这些文字:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">11vim22</span><br><span class="line">vim22</span><br><span class="line">11vim</span><br><span class="line">vim</span><br></pre></td></tr></table></figure>


<p>如果您需要选择”vim”，但仅当它以”11”开头并以”22”结束时，可以使用<code>\zs</code>（开始匹配）和<code>\ze</code>（结束匹配）运算符。 执行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/11\zsvim\ze22</span><br></pre></td></tr></table></figure>


<p>Vim 仍然必须匹配整个模式”11vim22”，但是仅突出显示介于<code>\zs</code>和<code>\ze</code>之间的模式。 另一个例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foobar</span><br><span class="line">foobaz</span><br></pre></td></tr></table></figure>


<p>如果需要在”foobaz”中搜索”foo”，而不是在”foobar”中搜索，请运行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/foo\zebaz</span><br></pre></td></tr></table></figure>


<h2 id="搜索范围字符"><a href="#搜索范围字符" class="headerlink" title="搜索范围字符"></a>搜索范围字符</h2><p>到目前为止，您所有的搜索字词都是文字搜索。在现实生活中，您可能必须使用通用模式来查找文本。最基本的模式是字符范围”[]”。</p>
<p>如果您需要搜索任何数字，则可能不想输入<code>/0\|1\|2\|3\|4\|5\|6\|7\|8\|9\|0</code>每一次。相反，请使用<code>/[0-9]</code>来匹配一位数字。 “0-9”表达式表示 Vim 尝试匹配的数字范围 0-9，因此，如果要查找 1 到 5 之间的数字，请使用”/[1-5]”。</p>
<p>数字不是 Vim 可以查找的唯一数据类型。您也可以执行<code>/[a-z]</code>来搜索小写字母，而<code>/[A-Z]</code>来搜索大写字母。</p>
<p>您可以将这些范围组合在一起。如果您需要搜索数字 0-9 以及从 a 到 f（十六进制）的小写字母和大写字母，可以执行<code>/[0-9a-fA-F]</code>。</p>
<p>要进行否定搜索，可以在字符范围括号内添加”^”。要搜索非数字，请运行<code>/[^0-9]</code>。 Vim 可以匹配任何字符，只要它不是数字即可。请注意，范围括号内的插入符号（<code>^</code>）与行首插入符号（例如:<code>/^hello</code>）不同。如果插入号在一对方括号之外，并且是搜索词中的第一个字符，则表示“一行中的第一个字符”。如果插入符号在一对方括号内，并且是方括号内的第一个字符，则表示否定搜索运算符。 <code>/^abc</code>匹配行中的第一个”abc”，而<code>/[^abc]</code>匹配除”a”，”b”或”c”以外的任何字符。</p>
<h2 id="搜索重复字符"><a href="#搜索重复字符" class="headerlink" title="搜索重复字符"></a>搜索重复字符</h2><p>如果需要在此文本中搜索两位数:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1aa</span><br><span class="line">11a</span><br><span class="line">111</span><br></pre></td></tr></table></figure>


<p>您可以使用<code>/[0-9][0-9]</code>来匹配两位数字字符，但是该方法不可缩放。 如果您需要匹配二十个数字怎么办？ 打字 20 次[[0-9]]并不是一种有趣的体验。 这就是为什么您需要一个<code>count</code>参数。</p>
<p>您可以将<code>count</code>传递给您的搜索。 它具有以下语法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;n,m&#125;</span><br></pre></td></tr></table></figure>


<p>顺便说一句，当在 Vim 中使用它们时，这些“计数”花括号需要被转义。 count 运算符放在您要递增的单个字符之后。</p>
<p>这是<code>count</code>语法的四种不同变体: -<code>&#123;n&#125;</code>是完全匹配。 <code>/[0-9]\&#123;2\&#125;</code>匹配两个数字:”11”和”111”中的”11”。 -<code>&#123;n,m&#125;</code>是范围匹配。 <code>/[0-9]\&#123;2,3\&#125;</code>匹配 2 到 3 位数字:”11”和”111”。 -<code>&#123;,m&#125;</code>是符合条件的。 <code>/[0-9]\&#123;,3\&#125;</code>最多匹配 3 个数字:”1”，”11”和”111”。 -<code>&#123;n,&#125;</code>是至少匹配项。 <code>/[0-9]\&#123;2,\&#125;</code>至少匹配 2 个或多个数字:”11”和”111”。</p>
<p>计数参数<code>\&#123;0,\&#125;</code>（零或多个）和<code>\&#123;1,\&#125;</code>（一个或多个）是常见的搜索模式，Vim 为它们提供了特殊的运算符:<code>*</code>和<code>+</code>（ <code>+</code>需要被转义，而<code>*</code> 可以正常运行而无需转义）。 如果执行<code>/[0-9]*</code>，则与<code>/[0-9]\&#123;0,\&#125;</code>相同。 它搜索零个或多个数字。 它将匹配“”，”1”，”123”。 顺便说一句，它也将匹配非数字，例如”a”，因为在技术上，字母”a”中的数字为零。 在使用”*”之前，请仔细考虑。 如果执行<code>/[0-9]\+</code>，则与<code>/[0-9]\&#123;1,\&#125;</code>相同。 它搜索一个或多个数字。 它将匹配”1”和”12”。</p>
<h2 id="预定义范围"><a href="#预定义范围" class="headerlink" title="预定义范围"></a>预定义范围</h2><p>Vim 为常见字符（例如数字和字母）提供了预定义范围。 我不会在这里逐一介绍，但可以在<code>:h /character-classes</code>中找到完整列表。 这是有用的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\d    数字[0-9]</span><br><span class="line">\D    非数字[^ 0-9]</span><br><span class="line">\s    空格字符（空格和制表符）</span><br><span class="line">\S    非空白字符（除空格和制表符外的所有字符）</span><br><span class="line">\w    文字字符[0-9A-Za-z_]</span><br><span class="line">\l    小写字母[a-z]</span><br><span class="line">\u    大写字符[A-Z]</span><br></pre></td></tr></table></figure>


<p>您可以像使用范围字符一样使用它们。 要搜索任何一位数字，可以使用<code>/\d</code>以获得更简洁的语法，而不使用<code>/[0-9]</code>。</p>
<h2 id="更多搜索示例"><a href="#更多搜索示例" class="headerlink" title="更多搜索示例"></a>更多搜索示例</h2><h3 id="在一对相似字符之间捕获文本"><a href="#在一对相似字符之间捕获文本" class="headerlink" title="在一对相似字符之间捕获文本"></a>在一对相似字符之间捕获文本</h3><p>如果要搜索由双引号引起来的短语:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;Vim is awesome!&quot;</span><br></pre></td></tr></table></figure>


<p>运行这个:</p>
<p><code>/&quot;[^&quot;]\+&quot;</code></p>
<p>让我们分解一下:</p>
<ul>
<li><code>&quot;</code> 是字面双引号。它匹配第一个双引号。</li>
<li><code>[^&quot;]</code> 表示除双引号外的任何字符，只要不是双引号，它就与任何字母数字和空格字符匹配。</li>
<li><code>\+</code>表示一个或多个。由于 Vim 的前面是<code>[^&quot;]</code>，因此 Vim 查找一个或多个不是双引号的字符。</li>
<li><code>&quot;</code> 是字面双引号。它与右双引号匹配。</li>
</ul>
<p>当看到第一个<code>“</code>时，它开始模式捕获。Vim 在一行中看到第二个双引号时，它匹配第二个<code>&quot;</code>模式并停止模式捕获。同时，两个“”之间的所有非“”字符都被<code>[^&quot;]\+</code> 模式捕获，在这种情况下，短语”Vim is awesome!”。由一对类似的定界符包围的词组:要捕获由单引号引起来的词组，可以使用<code>/&#39;[^&#39;]\+&#39;</code>。</p>
<h3 id="捕获电话号码"><a href="#捕获电话号码" class="headerlink" title="捕获电话号码"></a>捕获电话号码</h3><p>如果要匹配以连字符(<code>-</code>)分隔的美国电话号码，例如<code>123-456-7890</code>，则可以使用:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/\v\d\&#123;3\&#125;-\d\&#123;3\&#125;-\d\&#123;4\&#125;</span><br></pre></td></tr></table></figure>


<p>美国电话号码由一组三位数字组成，其后是另外三位数字，最后是四位数字。 让我们分解一下:</p>
<ul>
<li><code>\d\&#123;3\&#125;</code>与精确重复三次的数字匹配</li>
<li><code>-</code>是字面的连字符</li>
</ul>
<p>此模式还可用于捕获任何重复的数字，例如 IP 地址和邮政编码。</p>
<p>这涵盖了本章的搜索部分。 现在开始替代。</p>
<h2 id="基本替代"><a href="#基本替代" class="headerlink" title="基本替代"></a>基本替代</h2><p>Vim 的替代命令是一个有用的命令，用于快速查找和替换任何模式。 替换语法为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:s/old-pattern/new-pattern/</span><br></pre></td></tr></table></figure>


<p>让我们从一个基本用法开始。 如果您有以下文字:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim is good</span><br></pre></td></tr></table></figure>


<p>让我们用”awesome”代替”good”，因为 Vim 很棒。 运行<code>:s/good/awesome/.</code>您应该看到:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim is awesome</span><br></pre></td></tr></table></figure>


<h2 id="重复最后一次替换"><a href="#重复最后一次替换" class="headerlink" title="重复最后一次替换"></a>重复最后一次替换</h2><p>您可以使用普通命令<code>&amp;</code>或运行<code>:s</code>来重复最后一个替代命令。 如果您刚刚运行<code>:s/good/awesome/</code>，则运行<code>&amp;</code>或<code>:s</code>都会重复执行。</p>
<p>另外，在本章前面，我提到您可以使用”//“来重复先前的搜索模式。 此技巧可用于替代命令。 如果<code>/good</code>是最近完成的，并且将第一个替换模式参数留为空白，例如在<code>:s//awesome/</code>中，则与运行<code>:s/good/awesome/</code>相同。</p>
<h2 id="替代范围"><a href="#替代范围" class="headerlink" title="替代范围"></a>替代范围</h2><p>就像许多 Ex 命令一样，您可以将 range 参数传递给替代命令。 语法为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:[range]s/old/new/</span><br></pre></td></tr></table></figure>


<p>如果您具有以下表达式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let one = 1;</span><br><span class="line">let two = 2;</span><br><span class="line">let three = 3;</span><br><span class="line">let four = 4;</span><br><span class="line">let five = 5;</span><br></pre></td></tr></table></figure>


<p>要将第三行到第五行中的”let”替换为”const”，您可以执行以下操作:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:3,5s/let/const/</span><br></pre></td></tr></table></figure>


<p>替代命令的范围语法与搜索（<code>&#123;n,m&#125;</code>）中的计数语法相似，但有细微差别。 这是通过范围的一些变化:</p>
<ul>
<li><code>:,3/let/const/</code> - 如果逗号前没有给出任何内容，则表示当前行。 从当前行替换为第 3 行。</li>
<li><code>:1,s/let/const/</code> - 如果逗号后没有给出任何内容，则它也代表当前行。 从第 1 行替换为当前行。</li>
<li><code>:3s/let/const/</code> - 如果仅给出一个值作为范围（不带逗号），则仅在该行进行替换。</li>
</ul>
<p>在 Vim 中，<code>%</code>通常表示整个文件。 如果运行<code>:%s/let/const/</code>，它将在所有行上进行替换。</p>
<h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p>接下来的几节将介绍基本的正则表达式。 强大的模式知识对于掌握替代命令至关重要。</p>
<p>如果您具有以下表达式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let one = 1;</span><br><span class="line">let two = 2;</span><br><span class="line">let three = 3;</span><br><span class="line">let four = 4;</span><br><span class="line">let five = 5;</span><br></pre></td></tr></table></figure>


<p>要在数字周围添加一对双引号:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/\d/&quot;\0&quot;/</span><br></pre></td></tr></table></figure>


<p>结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let one = &quot;1&quot;;</span><br><span class="line">let two = &quot;2&quot;;</span><br><span class="line">let three = &quot;3&quot;;</span><br><span class="line">let four = &quot;4&quot;;</span><br><span class="line">let five = &quot;5&quot;;</span><br></pre></td></tr></table></figure>


<p>让我们分解一下命令:</p>
<ul>
<li><code>:%s</code> 定位整个文件以执行替换。</li>
<li><code>\d</code> 是 Vim 的数字预定义范围(<code>[0-9]</code>)。</li>
<li><code>&quot;\0&quot;</code> 双引号是文字双引号。 <code>\0</code>是一个特殊字符，代表“整个匹配模式”。 此处匹配的模式是单个数字<code>\d</code>。 在第一行，”\0”的值为”1”。 在第二行，值为”2”。 在第三行，值为”3”，依此类推。</li>
</ul>
<p>另外，<code>&amp;</code>也代表<code>\0</code>之类的“整个匹配模式”。 <code>:s/\d/&quot;&amp;&quot;/</code>也可以。</p>
<p>让我们考虑另一个例子。 给出以下表达式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">one let = &quot;1&quot;;</span><br><span class="line">two let = &quot;2&quot;;</span><br><span class="line">three let = &quot;3&quot;;</span><br><span class="line">four let = &quot;4&quot;;</span><br><span class="line">five let = &quot;5&quot;;</span><br></pre></td></tr></table></figure>


<p>您需要用变量名交换所有的”let”。 为此，请运行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/\(\w\+\) \(\w\+\)/\2 \1/</span><br></pre></td></tr></table></figure>


<p>上面的命令包含太多的反斜杠，很难阅读。 使用<code>\v</code>运算符更方便:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/\v(\w+) (\w+)/\2 \1/</span><br></pre></td></tr></table></figure>


<p>结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let one = &quot;1&quot;;</span><br><span class="line">let two = &quot;2&quot;;</span><br><span class="line">let three = &quot;3&quot;;</span><br><span class="line">let four = &quot;4&quot;;</span><br><span class="line">let five = &quot;5&quot;;</span><br></pre></td></tr></table></figure>


<p>太好了！ 让我们分解该命令:</p>
<ul>
<li><code>:%s</code> 定位文件中的所有行</li>
<li><code>(\w+) (\w+)</code>对模式进行分组。<code>\w</code>是 Vim 预定义的单词字符范围(<code>[0-9A-Za-z_]</code>)之一。 包围在其中的<code>（）</code>捕获一个单词字符匹配。 请注意两个分组之间的空间。 <code>(\w+) (\w+)</code> 分为两组。 在第一行上，第一组捕获“one”，第二组捕获“two”。</li>
<li><code>\2 \1</code> 以相反的顺序返回捕获的组。 <code>\2</code>包含捕获的字符串”let”，而<code>\1</code>包含字符串”one”。 使<code>\2 \1</code>返回字符串”let one”。</li>
</ul>
<p>回想一下<code>\0</code>代表整个匹配的模式。 您可以使用<code>( )</code>将匹配的字符串分成较小的组。 每个组都由<code>\1</code>, <code>\2</code>, <code>\3</code>等表示。</p>
<p>让我们再举一个例子来巩固这一匹配组的概念。 如果您有以下数字:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">123</span><br><span class="line">456</span><br><span class="line">789</span><br></pre></td></tr></table></figure>


<p>要颠倒顺序，请运行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/\v(\d)(\d)(\d)/\3\2\1/</span><br></pre></td></tr></table></figure>


<p>结果是:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">321</span><br><span class="line">654</span><br><span class="line">987</span><br></pre></td></tr></table></figure>


<p>每个<code>(\d)</code>匹配并分组每个数字。 在第一行上，第一个<code>(\d)</code>的值为”1”，第二个<code>(\d)</code>的值为”2”，第三个<code>(\d)</code>的值为”3”。 它们存储在变量<code>\1</code>，<code>\2</code>和<code>\3</code>中。 在替换的后半部分，新模式<code>\3\2\1</code>在第一行上产生”321”值。</p>
<p>如果您运行了它，则:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/\v(\d\d)(\d)/\2\1/</span><br></pre></td></tr></table></figure>


<p>您将获得不同的结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">312</span><br><span class="line">645</span><br><span class="line">978</span><br></pre></td></tr></table></figure>


<p>这是因为您现在只有两个组。 被<code>(\d\d)</code>捕获的第一组存储在<code>\1</code>内，其值为”12”。 由<code>(\d)</code>捕获的第二组存储在<code>\2</code>内部，其值为”3”。 然后，<code>\2\1</code>返回”312”。</p>
<h2 id="替代标志"><a href="#替代标志" class="headerlink" title="替代标志"></a>替代标志</h2><p>如果您有以下句子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chocolate pancake, strawberry pancake, blueberry pancake</span><br></pre></td></tr></table></figure>


<p>要将所有 pancakes 替换为 donut，您不能只运行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:s/pancake/donut</span><br></pre></td></tr></table></figure>


<p>上面的命令将仅替换第一个匹配项，从而为您提供:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chocolate donut, strawberry pancake, blueberry pancake</span><br></pre></td></tr></table></figure>


<p>有两种解决方法。 首先，您可以运行两次替代命令。 其次，您可以向其传递全局(<code>g</code>)标志来替换一行中的所有匹配项。</p>
<p>让我们谈谈全局标志。 运行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:s/pancake/donut/g</span><br></pre></td></tr></table></figure>


<p>Vim 迅速执行命令，将所有煎饼替换为甜甜圈。 全局命令是替代命令接受的几个标志之一。 您在替代命令的末尾传递标志。 这是有用的标志的列表:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&amp;    重用上一个替代命令中的标志。 必须作为第一个标志传递。</span><br><span class="line">g    替换行中的所有匹配项。</span><br><span class="line">c    要求替代确认。</span><br><span class="line">e    防止替换失败时显示错误消息。</span><br><span class="line">i    执行不区分大小写的替换</span><br><span class="line">I    执行区分大小写的替换</span><br></pre></td></tr></table></figure>


<p>我上面没有列出更多标志。 要了解所有标志，请查看<code>:h s_flags</code>。</p>
<p>顺便说一句，重复替换命令（<code>&amp;</code>和<code>:s</code>）不保留标志。 运行<code>&amp;</code>只会重复<code>:s/pancake/donut/</code>而没有<code>g</code>。 要使用所有标志快速重复最后一个替代命令，请运行<code>:&amp;&amp;</code>。</p>
<h2 id="更改定界符"><a href="#更改定界符" class="headerlink" title="更改定界符"></a>更改定界符</h2><p>如果您需要用长路径替换 URL:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://mysite.com/a/b/c/d/e</span><br></pre></td></tr></table></figure>


<p>要用单词”hello”代替它，请运行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:s/https:\/\/mysite.com\/a\/b\/c\/d\/e/hello/</span><br></pre></td></tr></table></figure>


<p>但是，很难说出哪些正斜杠（<code>/</code>）是替换模式的一部分，哪些是分隔符。 您可以使用任何单字节字符（除字母，数字或<code>“</code>，<code>|</code>和<code>\</code>之外的字符）来更改定界符。让我们将它们替换为<code>+</code>。上面的替换命令可以重写为 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:s+https:\/\/mysite.com\/a\/b\/c\/d\/e+hello+</span><br></pre></td></tr></table></figure>


<p>现在，更容易看到分隔符在哪里。</p>
<h2 id="特殊替换"><a href="#特殊替换" class="headerlink" title="特殊替换"></a>特殊替换</h2><p>您还可以修改要替换的文本的大小写。 给出以下表达式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let one = &quot;1&quot;;</span><br><span class="line">let two = &quot;2&quot;;</span><br><span class="line">let three = &quot;3&quot;;</span><br><span class="line">let four = &quot;4&quot;;</span><br><span class="line">let five = &quot;5&quot;;</span><br></pre></td></tr></table></figure>


<p>要大写变量“one”，“two”，“three”等，请运行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%s/\v(\w+) (\w+)/\1 \U\2/</span><br></pre></td></tr></table></figure>


<p>你会得到:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let ONE = &quot;1&quot;;</span><br><span class="line">let TWO = &quot;2&quot;;</span><br><span class="line">let THREE = &quot;3&quot;;</span><br><span class="line">let FOUR = &quot;4&quot;;</span><br><span class="line">let FIVE = &quot;5&quot;;</span><br></pre></td></tr></table></figure>


<p>这是该命令的细分:</p>
<ul>
<li><code>(\w+) (\w+)</code>捕获前两个匹配的组，例如”let”和”one”。</li>
<li><code>\1</code>返回第一个组的值”let”</li>
<li><code>\U\2</code>大写(<code>\U</code>)第二组(<code>\2</code>)。</li>
</ul>
<p>该命令的窍门是表达式<code>\U\2</code>。<code>\U</code>指示以下字符大写。</p>
<p>让我们再举一个例子。 假设您正在编写 Vim 书籍，并且需要将一行中每个单词的首字母大写。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim is the greatest text editor in the whole galaxy</span><br></pre></td></tr></table></figure>


<p>您可以运行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:s/\&lt;./\u&amp;/g</span><br></pre></td></tr></table></figure>


<p>结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vim Is The Greatest Text Editor In The Whole Galaxy</span><br></pre></td></tr></table></figure>


<p>细目如下:</p>
<ul>
<li><code>:s</code> 替换当前行</li>
<li><code>\&lt;.</code> 由两部分组成:<code>\&lt;</code>匹配单词的开头和<code>.</code>匹配任何字符。 “&lt;”运算符使以下字符成为单词的第一个字符。 由于<code>.</code>是下一个字符，因此它将匹配任何单词的第一个字符。</li>
<li><code>\u&amp;</code> 将后续符号<code>&amp;</code>大写。 回想一下，<code>&amp;</code>（或<code>\0</code>）代表整个比赛。 它与拒绝单词的第一个字符匹配。</li>
<li><code>g</code>全局标志。 没有它，此命令将仅替换第一个匹配项。 您需要替换此行上的每个匹配项。</li>
</ul>
<p>要了解替换的特殊替换符号（如<code>\u</code>和<code>\U</code>）的更多信息，请查看<code>:h sub-replace-special</code>。</p>
<h2 id="替代模式"><a href="#替代模式" class="headerlink" title="替代模式"></a>替代模式</h2><p>有时您需要同时匹配多个模式。 如果您有以下问候:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello vim</span><br><span class="line">hola vim</span><br><span class="line">salve vim</span><br><span class="line">bonjour vim</span><br></pre></td></tr></table></figure>


<p>您仅需在包含单词”hello”或”hola”的行上用”friend”代替”vim”。 执行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/\v(hello|hola) vim)/\1 friend/g</span><br></pre></td></tr></table></figure>


<p>结果:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello friend</span><br><span class="line">hola friend</span><br><span class="line">salve vim</span><br><span class="line">bonjour vim</span><br></pre></td></tr></table></figure>


<p>这是细分:</p>
<ul>
<li><code>%s</code> 在文件的每一行上运行替代命令。</li>
<li><code>(hello|hola)</code> 匹配*”hello”或”hola”并将其视为一个组。</li>
<li><code>vim</code> 是字面意思”vim”。</li>
<li><code>\1</code> 是第一个匹配组，它是文本”hello”或”hola”。</li>
<li><code>friend</code> 是字面的“朋友”。</li>
</ul>
<h2 id="跨多个文件替换"><a href="#跨多个文件替换" class="headerlink" title="跨多个文件替换"></a>跨多个文件替换</h2><p>最后，让我们学习如何在多个文件中替换短语。对于本节，假设您有两个文件: <code>food.txt</code> 和 <code>animal.txt</code>.</p>
<p><code>food.txt</code>内:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">corn dog</span><br><span class="line">hot dog</span><br><span class="line">chili dog</span><br></pre></td></tr></table></figure>


<p><code>animal.txt</code>内:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">large dog</span><br><span class="line">medium dog</span><br><span class="line">small dog</span><br></pre></td></tr></table></figure>


<p>假设您的目录结构如下所示:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">├── food.txt</span><br><span class="line">├── animal.txt</span><br></pre></td></tr></table></figure>


<p>首先，在<code>:args</code>内同时捕获”food.txt”和”animal.txt”。回顾前面的章节，<code>:args</code>可用于创建文件名列表。在 Vim 内部有几种方法可以做到这一点:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:args *.txt                  捕获当前位置的所有txt文件</span><br><span class="line">:args food.txt animal.txt    仅捕获索引和服务器js文件</span><br><span class="line">:args **/*.txt               捕获每个txt文件</span><br><span class="line">:args **                     捕获一切</span><br></pre></td></tr></table></figure>


<p>您也可以在 Vim 外部运行上述命令，将文件作为 Vim 的_ arguments _传递（因此称为”args”命令）。 从终端运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim food.txt animal.txt</span><br></pre></td></tr></table></figure>


<p>当 Vim 启动时，您将在<code>:args</code>中找到<code>food.txt</code>和<code>animal.txt</code>。</p>
<p>无论哪种方式，当您运行<code>:args</code>时，您都应该看到:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[food.txt] animal.txt</span><br></pre></td></tr></table></figure>


<p>要转到列表中的下一个或上一个参数，请输入<code>:next</code>或<code>:previous</code>。 现在所有相关文件都存储在参数列表中，您可以使用<code>:argdo</code>命令执行多文件替换。 执行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:argdo %s/dog/chicken/</span><br></pre></td></tr></table></figure>


<p>这将对<code>:args</code>列表中的所有文件进行替换。 最后，使用以下命令保存更改的文件:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:argdo update</span><br></pre></td></tr></table></figure>


<p><code>:args</code>和<code>:argdo</code>是在多个文件之间应用命令行命令的有用工具。 与其他命令一起尝试！</p>
<h2 id="用宏替换多个文件"><a href="#用宏替换多个文件" class="headerlink" title="用宏替换多个文件"></a>用宏替换多个文件</h2><p>另外，您也可以跨多个带有宏的文件运行替代命令。 让我们从将相关文件放入 args 列表开始。 执行:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:args animal.txt food.txt</span><br><span class="line">qq</span><br><span class="line">:%s/dog/chicken/g</span><br><span class="line">:wnext</span><br><span class="line">q</span><br><span class="line">99@q</span><br></pre></td></tr></table></figure>


<p>以下是步骤的细分:</p>
<ul>
<li><code>:args animal.txt food.txt</code> 会将相关文件列出到<code>:args</code>列表中。</li>
<li><code>qq</code> 启动”q”寄存器中的宏。</li>
<li><code>:%s/dog/chicken/g</code>在当前文件的所有行上用”chicken”替换”dog”。</li>
<li><code>:wnext</code> 写入（保存）文件，然后转到<code>args</code>列表中的下一个文件。就像同时运行<code>:w</code>和<code>:next</code>一样。</li>
<li><code>q</code> 停止宏录制。</li>
<li><code>99@q</code> 执行宏九十九次。 Vim 遇到第一个错误后，它将停止执行宏，因此 Vim 实际上不会执行该宏九十九次。</li>
</ul>
<h2 id="以聪明的方式学习搜索和替换"><a href="#以聪明的方式学习搜索和替换" class="headerlink" title="以聪明的方式学习搜索和替换"></a>以聪明的方式学习搜索和替换</h2><p>做好搜索的能力是编辑的必要技能。掌握搜索功能使您可以利用正则表达式的灵活性来搜索文件中的任何模式。花些时间学习这些。实际上，您可以自己完成本章中的搜索和替换。我曾经读过一本关于正则表达式的书，却没有真正去做，后来我几乎忘了读的所有东西。主动编码是掌握任何技能的最佳方法。</p>
<p>一种提高模式匹配技能的好方法是，每当您需要搜索模式时（例如”hello 123”），而不是查询文字搜索字词(<code>/hello 123</code>)，都可以尝试为它(<code>/\v(\l+) (\d+)</code>)。这些正则表达式概念中的许多不仅在使用 Vim 时，也适用于常规编程。</p>
<p>既然您已经了解了 Vim 中的高级搜索和替换，现在让我们学习功能最丰富的命令之一，即全局命令。</p>
<h1 id="许可和版权"><a href="#许可和版权" class="headerlink" title="许可和版权"></a>许可和版权</h1><p>这些材料全部归 ©2020 Igor Irianto 所有。</p>
<p><img src="https://licensebuttons.net/l/by-nc-sa/4.0/88x31.png#id=ldrA8&originHeight=31&originWidth=88&originalType=binary&status=done&style=none"></p>
<p>这项作品已获得<a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">&lt;&lt;知识共享署名-非商业性-相同方式共享 4.0 版&gt;&gt;</a>的许可。</p>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="南风 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="南风 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>南风
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://github.nanfeng.ink/2020/05/21/%E8%81%AA%E6%98%8E%E7%9A%84%E5%AD%A6%E4%B9%A0Vim%EF%BC%88%E4%B8%8A%EF%BC%89/" title="聪明的学习Vim（上）">https://github.nanfeng.ink/2020/05/21/聪明的学习Vim（上）/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Linux/" rel="tag"><i class="fa fa-tag"></i> Linux</a>
              <a href="/tags/Vim/" rel="tag"><i class="fa fa-tag"></i> Vim</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/05/15/VCS%E5%9C%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/" rel="prev" title="VCS在虚拟机中的安装和使用">
      <i class="fa fa-chevron-left"></i> VCS在虚拟机中的安装和使用
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/05/21/%E8%81%AA%E6%98%8E%E7%9A%84%E5%AD%A6%E4%B9%A0Vim%EF%BC%88%E4%B8%8B%EF%BC%89/" rel="next" title="聪明的学习Vim（下）">
      聪明的学习Vim（下） <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC81MzA0Ny8yOTUyMw=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Vim-%E8%AF%AD%E6%B3%95"><span class="nav-number"></span> <span class="nav-text">Vim 语法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E4%B8%80%E9%97%A8%E8%AF%AD%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">如何学习一门语言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99"><span class="nav-number">2.</span> <span class="nav-text">语法规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%8D%E6%B1%87%E8%A1%A8"><span class="nav-number">3.</span> <span class="nav-text">词汇表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8D%E8%AF%8D-%E5%8A%A8%E4%BD%9C-Motion"><span class="nav-number">3.1.</span> <span class="nav-text">名词(动作 Motion)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E8%AF%8D-%E6%93%8D%E4%BD%9C%E7%AC%A6-Operator"><span class="nav-number">3.2.</span> <span class="nav-text">动词(操作符 Operator)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E5%A4%9A%E5%90%8D%E8%AF%8D-%E6%96%87%E6%9C%AC%E5%AF%B9%E8%B1%A1"><span class="nav-number">4.</span> <span class="nav-text">更多名词(文本对象)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E5%90%88%E6%80%A7%E5%92%8C%E8%AF%AD%E6%B3%95"><span class="nav-number">5.</span> <span class="nav-text">结合性和语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%AA%E6%98%8E%E5%9C%B0%E5%AD%A6%E4%B9%A0%E8%AF%AD%E6%B3%95"><span class="nav-number">6.</span> <span class="nav-text">聪明地学习语法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8%E6%96%87%E4%BB%B6%E4%B8%AD%E7%A7%BB%E5%8A%A8"><span class="nav-number"></span> <span class="nav-text">在文件中移动</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E5%AF%BC%E8%88%AA"><span class="nav-number">1.</span> <span class="nav-text">字符导航</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%AF%B9%E8%A1%8C%E5%8F%B7"><span class="nav-number">2.</span> <span class="nav-text">相对行号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E7%A7%BB%E5%8A%A8%E8%AE%A1%E6%95%B0"><span class="nav-number">3.</span> <span class="nav-text">对移动计数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E8%AF%8D%E5%AF%BC%E8%88%AA"><span class="nav-number">4.</span> <span class="nav-text">单词导航</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BD%93%E5%89%8D%E8%A1%8C%E5%AF%BC%E8%88%AA"><span class="nav-number">5.</span> <span class="nav-text">当前行导航</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%A5%E5%AD%90%E5%92%8C%E6%AE%B5%E8%90%BD%E5%AF%BC%E8%88%AA"><span class="nav-number">6.</span> <span class="nav-text">句子和段落导航</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%B9%E9%85%8D%E5%AF%BC%E8%88%AA"><span class="nav-number">7.</span> <span class="nav-text">匹配导航</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%8C%E5%8F%B7%E5%AF%BC%E8%88%AA"><span class="nav-number">8.</span> <span class="nav-text">行号导航</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AA%97%E6%A0%BC%E5%AF%BC%E8%88%AA"><span class="nav-number">9.</span> <span class="nav-text">窗格导航</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BB%9A%E5%8A%A8"><span class="nav-number">10.</span> <span class="nav-text">滚动</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2%E5%AF%BC%E8%88%AA"><span class="nav-number">11.</span> <span class="nav-text">搜索导航</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%8D%E7%BD%AE%E6%A0%87%E8%AE%B0"><span class="nav-number">12.</span> <span class="nav-text">位置标记</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%B3%E8%BD%AC"><span class="nav-number">13.</span> <span class="nav-text">跳转</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%AA%E6%98%8E%E5%9C%B0%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%88%AA"><span class="nav-number">14.</span> <span class="nav-text">聪明地学习导航</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F"><span class="nav-number"></span> <span class="nav-text">输入模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E5%85%A5%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.</span> <span class="nav-text">进入输入模式的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%80%E5%87%BA%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">退出输入模式的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E5%A4%8D%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.</span> <span class="nav-text">重复输入模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F%E4%B8%AD%E5%88%A0%E9%99%A4%E5%A4%A7%E5%9D%97%E6%96%87%E6%9C%AC"><span class="nav-number">4.</span> <span class="nav-text">在输入模式中删除大块文本</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8%E8%BF%9B%E8%A1%8C%E8%BE%93%E5%85%A5"><span class="nav-number"></span> <span class="nav-text">用寄存器进行输入</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E6%BB%9A%E5%8A%A8"><span class="nav-number">1.</span> <span class="nav-text">页面滚动</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8"><span class="nav-number">2.</span> <span class="nav-text">自动补全</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E6%99%AE%E9%80%9A%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="nav-number">3.</span> <span class="nav-text">执行普通模式下的命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%AA%E6%98%8E%E5%9C%B0%E5%AD%A6%E4%B9%A0%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.</span> <span class="nav-text">聪明地学习输入模式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%82%B9%E5%91%BD%E4%BB%A4"><span class="nav-number"></span> <span class="nav-text">点命令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%B3%95"><span class="nav-number">1.</span> <span class="nav-text">用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%89%8D%E7%AE%97%E6%98%AF%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="nav-number">2.</span> <span class="nav-text">什么才算是修改操作？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E5%A4%8D%E5%A4%9A%E8%A1%8C%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C"><span class="nav-number">3.</span> <span class="nav-text">重复多行修改操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E4%BF%AE%E6%94%B9%E4%B8%AD%E5%8C%85%E5%90%AB%E7%A7%BB%E5%8A%A8%E6%93%8D%E4%BD%9C"><span class="nav-number">4.</span> <span class="nav-text">在修改中包含移动操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%AA%E6%98%8E%E5%9C%B0%E5%AD%A6%E4%B9%A0%E7%82%B9%E5%91%BD%E4%BB%A4"><span class="nav-number">5.</span> <span class="nav-text">聪明地学习点命令</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number"></span> <span class="nav-text">寄存器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%8410%E7%A7%8D%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.</span> <span class="nav-text">寄存器的10种类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">2.</span> <span class="nav-text">寄存器命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">3.</span> <span class="nav-text">在输入模式中使用寄存器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%AF%84%E5%AD%98%E5%99%A8-quot-quot"><span class="nav-number">4.</span> <span class="nav-text">匿名寄存器(&quot;&quot;)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E5%8F%B7%E5%AF%84%E5%AD%98%E5%99%A8-quot-0-9"><span class="nav-number">5.</span> <span class="nav-text">编号寄存器(&quot;0-9)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8-quot-0"><span class="nav-number">5.1.</span> <span class="nav-text">复制寄存器 (&quot;0)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E5%8F%B7%E5%AF%84%E5%AD%98%E5%99%A8-quot-1-9"><span class="nav-number">5.2.</span> <span class="nav-text">编号寄存器 (&quot;1-9)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E5%88%A0%E9%99%A4%E5%AF%84%E5%AD%98%E5%99%A8-quot"><span class="nav-number">6.</span> <span class="nav-text">小删除寄存器(&quot;-)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E5%AF%84%E5%AD%98%E5%99%A8-quot-a-z"><span class="nav-number">7.</span> <span class="nav-text">命名寄存器 (&quot;a-z)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AA%E8%AF%BB%E5%AF%84%E5%AD%98%E5%99%A8-quot-quot-quot"><span class="nav-number">8.</span> <span class="nav-text">只读寄存器(&quot;:, &quot;., &quot;%)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Buffer%E4%BA%A4%E6%9B%BF%E6%96%87%E4%BB%B6%E5%AF%84%E5%AD%98%E5%99%A8-quot"><span class="nav-number">9.</span> <span class="nav-text">Buffer交替文件寄存器 (&quot;#)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AF%84%E5%AD%98%E5%99%A8-quot"><span class="nav-number">10.</span> <span class="nav-text">表达式寄存器 (&quot;&#x3D;)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%89%E5%8F%96%E5%92%8C%E6%8B%96%E6%94%BE%E5%AF%84%E5%AD%98%E5%99%A8-quot-quot"><span class="nav-number">11.</span> <span class="nav-text">选取和拖放寄存器 (&quot;*, &quot;+)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%BB%91%E6%B4%9E%E5%AF%84%E5%AD%98%E5%99%A8-quot"><span class="nav-number">12.</span> <span class="nav-text">黑洞寄存器 (&quot;_)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2%E6%A8%A1%E5%BC%8F%E5%AF%84%E5%AD%98%E5%99%A8-quot"><span class="nav-number">13.</span> <span class="nav-text">搜索模式寄存器 (&quot;&#x2F;)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">14.</span> <span class="nav-text">查看所有的寄存器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">15.</span> <span class="nav-text">执行寄存器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B8%85%E9%99%A4%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">16.</span> <span class="nav-text">清除寄存器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9"><span class="nav-number">17.</span> <span class="nav-text">获取寄存器中的内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%AA%E6%98%8E%E5%9C%B0%E5%AD%A6%E4%B9%A0%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">18.</span> <span class="nav-text">聪明地学习寄存器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%8F%E5%91%BD%E4%BB%A4"><span class="nav-number"></span> <span class="nav-text">宏命令</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%AE%8F%E5%91%BD%E4%BB%A4"><span class="nav-number">1.</span> <span class="nav-text">基本宏命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E4%BF%9D%E6%8A%A4"><span class="nav-number">2.</span> <span class="nav-text">安全保护</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%89%A7%E8%A1%8C%E5%AE%8F"><span class="nav-number">3.</span> <span class="nav-text">命令行执行宏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E5%A4%9A%E4%B8%AA%E6%96%87%E4%BB%B6%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%AE%8F%E5%91%BD%E4%BB%A4"><span class="nav-number">4.</span> <span class="nav-text">在多个文件中执行宏命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E6%89%A7%E8%A1%8C%E5%AE%8F%E5%91%BD%E4%BB%A4"><span class="nav-number">5.</span> <span class="nav-text">递归执行宏命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A2%9E%E6%B7%BB%E4%B8%80%E4%B8%AA%E5%B7%B2%E7%9F%A5%E5%AE%8F"><span class="nav-number">6.</span> <span class="nav-text">增添一个已知宏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E4%B8%80%E4%B8%AA%E5%B7%B2%E7%9F%A5%E5%AE%8F"><span class="nav-number">7.</span> <span class="nav-text">修改一个已知宏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E5%AE%8F"><span class="nav-number">8.</span> <span class="nav-text">拷贝宏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9E%E7%BB%AD%E6%89%A7%E8%A1%8C%E5%AE%8F%E5%91%BD%E4%BB%A4"><span class="nav-number">9.</span> <span class="nav-text">连续执行宏命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%AA%E6%98%8E%E5%9C%B0%E5%AD%A6%E4%B9%A0%E5%AE%8F%E5%91%BD%E4%BB%A4"><span class="nav-number">10.</span> <span class="nav-text">聪明地学习宏命令</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%92%A4%E9%94%80"><span class="nav-number"></span> <span class="nav-text">撤销</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Undo%EF%BC%8CRedo%EF%BC%8C%E5%92%8C-UNDO"><span class="nav-number">1.</span> <span class="nav-text">Undo，Redo，和 UNDO</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%AD%E7%82%B9%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="nav-number">2.</span> <span class="nav-text">断点插入操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%92%A4%E9%94%80%E6%A0%91"><span class="nav-number">3.</span> <span class="nav-text">撤销树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%9D%E6%8C%81%E6%92%A4%E9%94%80%E7%8A%B6%E6%80%81"><span class="nav-number">4.</span> <span class="nav-text">保持撤销状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E6%97%85%E8%A1%8C"><span class="nav-number">5.</span> <span class="nav-text">时间旅行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%AA%E6%98%8E%E5%9C%B0%E5%AD%A6%E4%B9%A0%E6%92%A4%E9%94%80%E6%93%8D%E4%BD%9C"><span class="nav-number">6.</span> <span class="nav-text">聪明地学习撤销操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%AF%E8%A7%86%E6%A8%A1%E5%BC%8F"><span class="nav-number"></span> <span class="nav-text">可视模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E5%8F%AF%E8%A7%86%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.</span> <span class="nav-text">三种可视模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E8%A7%86%E6%A8%A1%E5%BC%8F%E5%AF%BC%E8%88%AA"><span class="nav-number">2.</span> <span class="nav-text">可视模式导航</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E8%A7%86%E6%A8%A1%E5%BC%8F%E8%AF%AD%E6%B3%95"><span class="nav-number">3.</span> <span class="nav-text">可视模式语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E8%A7%86%E6%A8%A1%E5%BC%8F%E5%92%8CEx%E5%91%BD%E4%BB%A4"><span class="nav-number">4.</span> <span class="nav-text">可视模式和Ex命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%A8%E5%A4%9A%E8%A1%8C%E7%BC%96%E8%BE%91"><span class="nav-number">5.</span> <span class="nav-text">跨多行编辑</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%92%E5%A2%9E%E6%95%B0%E5%AD%97"><span class="nav-number">6.</span> <span class="nav-text">递增数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8F%AF%E8%A7%86%E6%A8%A1%E5%BC%8F%E5%8C%BA%E5%9F%9F"><span class="nav-number">7.</span> <span class="nav-text">选择最后一个可视模式区域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E6%8F%92%E5%85%A5%E6%A8%A1%E5%BC%8F%E8%BF%9B%E5%85%A5%E5%8F%AF%E8%A7%86%E6%A8%A1%E5%BC%8F"><span class="nav-number">8.</span> <span class="nav-text">从插入模式进入可视模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%A8%A1%E5%BC%8F"><span class="nav-number">9.</span> <span class="nav-text">选择模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A5%E8%81%AA%E6%98%8E%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AD%A6%E4%B9%A0%E5%8F%AF%E8%A7%86%E6%A8%A1%E5%BC%8F"><span class="nav-number">10.</span> <span class="nav-text">以聪明的方式学习可视模式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2%E5%92%8C%E6%9B%BF%E6%8D%A2"><span class="nav-number"></span> <span class="nav-text">搜索和替换</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E5%8C%BA%E5%88%86%E5%A4%A7%E5%B0%8F%E5%86%99"><span class="nav-number">1.</span> <span class="nav-text">智能区分大小写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E8%A1%8C%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6"><span class="nav-number">2.</span> <span class="nav-text">一行中的第一个和最后一个字符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E5%A4%8D%E6%90%9C%E7%B4%A2"><span class="nav-number">3.</span> <span class="nav-text">重复搜索</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2%E6%9B%BF%E4%BB%A3%E8%AF%8D"><span class="nav-number">4.</span> <span class="nav-text">搜索替代词</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E6%AF%94%E8%B5%9B%E7%9A%84%E5%BC%80%E5%A7%8B%E5%92%8C%E7%BB%93%E6%9D%9F"><span class="nav-number">5.</span> <span class="nav-text">设置比赛的开始和结束</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2%E8%8C%83%E5%9B%B4%E5%AD%97%E7%AC%A6"><span class="nav-number">6.</span> <span class="nav-text">搜索范围字符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6"><span class="nav-number">7.</span> <span class="nav-text">搜索重复字符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%84%E5%AE%9A%E4%B9%89%E8%8C%83%E5%9B%B4"><span class="nav-number">8.</span> <span class="nav-text">预定义范围</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E5%A4%9A%E6%90%9C%E7%B4%A2%E7%A4%BA%E4%BE%8B"><span class="nav-number">9.</span> <span class="nav-text">更多搜索示例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E4%B8%80%E5%AF%B9%E7%9B%B8%E4%BC%BC%E5%AD%97%E7%AC%A6%E4%B9%8B%E9%97%B4%E6%8D%95%E8%8E%B7%E6%96%87%E6%9C%AC"><span class="nav-number">9.1.</span> <span class="nav-text">在一对相似字符之间捕获文本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8D%95%E8%8E%B7%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81"><span class="nav-number">9.2.</span> <span class="nav-text">捕获电话号码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%9B%BF%E4%BB%A3"><span class="nav-number">10.</span> <span class="nav-text">基本替代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E5%A4%8D%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E6%9B%BF%E6%8D%A2"><span class="nav-number">11.</span> <span class="nav-text">重复最后一次替换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%BF%E4%BB%A3%E8%8C%83%E5%9B%B4"><span class="nav-number">12.</span> <span class="nav-text">替代范围</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-number">13.</span> <span class="nav-text">模式匹配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%BF%E4%BB%A3%E6%A0%87%E5%BF%97"><span class="nav-number">14.</span> <span class="nav-text">替代标志</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%B4%E6%94%B9%E5%AE%9A%E7%95%8C%E7%AC%A6"><span class="nav-number">15.</span> <span class="nav-text">更改定界符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E6%9B%BF%E6%8D%A2"><span class="nav-number">16.</span> <span class="nav-text">特殊替换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9B%BF%E4%BB%A3%E6%A8%A1%E5%BC%8F"><span class="nav-number">17.</span> <span class="nav-text">替代模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%A8%E5%A4%9A%E4%B8%AA%E6%96%87%E4%BB%B6%E6%9B%BF%E6%8D%A2"><span class="nav-number">18.</span> <span class="nav-text">跨多个文件替换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E5%AE%8F%E6%9B%BF%E6%8D%A2%E5%A4%9A%E4%B8%AA%E6%96%87%E4%BB%B6"><span class="nav-number">19.</span> <span class="nav-text">用宏替换多个文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A5%E8%81%AA%E6%98%8E%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AD%A6%E4%B9%A0%E6%90%9C%E7%B4%A2%E5%92%8C%E6%9B%BF%E6%8D%A2"><span class="nav-number">20.</span> <span class="nav-text">以聪明的方式学习搜索和替换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AE%B8%E5%8F%AF%E5%92%8C%E7%89%88%E6%9D%83"><span class="nav-number"></span> <span class="nav-text">许可和版权</span></a></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="南风"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">南风</p>
  <div class="site-description" itemprop="description">陌上人如玉，公子世无双</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Mr-southerly" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Mr-southerly" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:Mr.southerly@qq.com" title="E-Mail → mailto:Mr.southerly@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/5784412625" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;5784412625" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/Zhanfei_Han" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;Zhanfei_Han" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://scholar.google.com.hk/citations?user=C3j6MiYAAAAJ&hl=zh-CN" title="Scholar → https:&#x2F;&#x2F;scholar.google.com.hk&#x2F;citations?user&#x3D;C3j6MiYAAAAJ&amp;hl&#x3D;zh-CN" rel="noopener" target="_blank"><i class="fab fa-google-plus fa-fw"></i>Scholar</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.researchgate.net/profile/Zhanfei-Han" title="Research → https:&#x2F;&#x2F;www.researchgate.net&#x2F;profile&#x2F;Zhanfei-Han" rel="noopener" target="_blank"><i class="fab fa-researchgate fa-fw"></i>Research</a>
      </span>
  </div>



      </div>


		
		<script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script>
		<script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script>
		<div class="widget-wrap">
			<div id="myCanvasContainer" class="widget tagcloud">
			<canvas width="220" height="250" id="resCanvas" style="width=100%">
				<ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/3D%E6%89%93%E5%8D%B0/" rel="tag">3D打印</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AD/" rel="tag">AD</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Aria2/" rel="tag">Aria2</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CNN/" rel="tag">CNN</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cadence/" rel="tag">Cadence</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C%E8%AF%AD%E8%A8%80/" rel="tag">C语言</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/" rel="tag">Docker</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Frp/" rel="tag">Frp</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Github/" rel="tag">Github</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML-CSS/" rel="tag">HTML+CSS</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IOS/" rel="tag">IOS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Multisim/" rel="tag">Multisim</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PID/" rel="tag">PID</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/STM32/" rel="tag">STM32</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SoC/" rel="tag">SoC</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spice/" rel="tag">Spice</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SystemVerilog/" rel="tag">SystemVerilog</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VCS/" rel="tag">VCS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Verilog/" rel="tag">Verilog</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vim/" rel="tag">Vim</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%A0%E5%8D%9C/" rel="tag">占卜</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%99%A8%E4%BB%B6/" rel="tag">器件</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E8%89%BA/" rel="tag">工艺</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E5%AD%97/" rel="tag">数字</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A8%A1%E6%8B%9F/" rel="tag">模拟</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%89%88%E5%9B%BE/" rel="tag">版图</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A0%B4%E8%A7%A3/" rel="tag">破解</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%84%9A%E6%9C%AC/" rel="tag">脚本</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag">虚拟机</a><span class="tag-list-count">3</span></li></ul>
			</canvas>
			</div>
		</div>
		
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>


    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">南风</span>
  <a href="https://beian.miit.gov.cn/" target="_blank"> &nbsp;&nbsp;津ICP备19004841号</a> 
</div>



<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
-->

<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("04/18/2019 15:54:40");
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "你终于来了，我已经在这里等了你 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒了";
    }
setInterval("createtime()",250);
</script>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  
  <script data-pjax>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

    </div>
  
  
  
  <!-- 页面点击小红心 -->
  <script type="text/javascript" src="/js/clicklove.js"></script>

  <script type="text/javascript" color="0,0,0" opacity='0.5' zIndex="-1" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>

  <!-- require APlayer -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css">
  <script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script>
  <!-- require MetingJS -->
  <script src="https://cdn.jsdelivr.net/npm/meting@1.2.0/dist/Meting.min.js"></script>



<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
<div class="aplayer" 
	data-id="4941857491" 
	data-server="netease" 
	data-type="playlist" 
	data-fixed="true"	
	data-order="random"
	data-volume="0.18"
	data-list-folded="false"
	data-autoplay="true"
	data-lrc-type="0"
	data-preload="auto"
	data-theme="#cc543a" >
     </div>


</html>




