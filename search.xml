<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>TLM测试及数据处理</title>
    <url>/2022/03/01/TLM%E6%B5%8B%E8%AF%95%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/12924220/1645691124907-87a17131-ba97-419d-8635-d5bf38ffda12.png#clientId=u9889798a-028c-4&from=paste&height=372&id=u52c723de&margin=%5Bobject%20Object%5D&name=image.png&originHeight=743&originWidth=1174&originalType=binary&ratio=1&size=68439&status=done&style=none&taskId=ue409ea66-7b9e-485a-8260-d0235bd629b&width=587" alt="image.png"></p>
<h2 id="测试步骤"><a href="#测试步骤" class="headerlink" title="测试步骤"></a>测试步骤</h2><p>1、利用四探针测量不同间距（L12、L23、……、L45）相邻金属焊点的电阻（R12、R23、……、R45）<br>2、以L（um）为横坐标、R（Ω）为纵坐标画线，对其进行线性拟合，其纵坐标截距为2Rc，斜率为Rsh/W。由此得出Rc<br>3、测量焊点1-3之间电阻R13，可得Re13=（R12+R23-R13）/2，也可测焊点2-4之间电阻R24，可得Re24=（R23+R34-R24）/2，也可测焊点3-5之间电阻R35，可得Re35=（R34+R45-R35）/2，并对Re13、Re24、Re35求平均值得到Re</p>
<h2 id="计算步骤"><a href="#计算步骤" class="headerlink" title="计算步骤"></a>计算步骤</h2><p>（W、S单位均为um）<br>1、特征接触电阻<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12924220/1645691962467-82512cf0-e1c8-409e-a5a3-6baa83c376de.png#clientId=u9889798a-028c-4&from=paste&height=57&id=ue37b8b8a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=113&originWidth=414&originalType=binary&ratio=1&size=10020&status=done&style=none&taskId=u0fc3d5cb-6b25-445d-8a75-9d53555432d&width=207" alt="image.png"><br>2、传输电阻<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12924220/1645692054409-5a4db620-1356-43dc-8b82-e4753a979840.png#clientId=u9889798a-028c-4&from=paste&height=41&id=uc83296a1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=82&originWidth=397&originalType=binary&ratio=1&size=6480&status=done&style=none&taskId=u2d7f91f9-abd7-4e60-b493-a78119baeb9&width=198.5" alt="image.png"><br>3、半导体方块电阻<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12924220/1645692046985-1d7b18bb-c5c3-4cdf-8939-6fc7779df7ac.png#clientId=u9889798a-028c-4&from=paste&height=49&id=u1ee7d293&margin=%5Bobject%20Object%5D&name=image.png&originHeight=98&originWidth=627&originalType=binary&ratio=1&size=13760&status=done&style=none&taskId=u7a0b0b3e-a050-4dcc-8b42-838b0009296&width=313.5" alt="image.png"><br>4、金属接触下方半导体方块电阻<br><img src="https://cdn.nlark.com/yuque/0/2022/png/12924220/1645692035161-3b6bdb2c-e723-4dbe-8cb9-99dcfe16fd90.png#clientId=u9889798a-028c-4&from=paste&height=44&id=uc7097ef5&margin=%5Bobject%20Object%5D&name=image.png&originHeight=88&originWidth=405&originalType=binary&ratio=1&size=7926&status=done&style=none&taskId=ubb0251e4-817a-47b3-a454-c30d6cc3637&width=202.5" alt="image.png"><br>​</p>
]]></content>
      <categories>
        <category>笔记篇</category>
        <category>测试</category>
      </categories>
      <tags>
        <tag>版图</tag>
        <tag>器件</tag>
      </tags>
  </entry>
  <entry>
    <title>Cadence之Layout常用快捷键</title>
    <url>/2021/10/18/Cadence%E4%B9%8BLayout%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>功能键</th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>左键</td>
<td>选中一个图形，如果两个图形交叠的话，单击选中其中一个图形，再单击选中另一个图形，用左键框选，选中一片图形，某个图形要被完全包围才会被选中</td>
<td></td>
</tr>
<tr>
<td>中键</td>
<td>放大（相当于Z+左键）</td>
<td></td>
</tr>
<tr>
<td>右键</td>
<td>调出常用菜单命令</td>
<td></td>
</tr>
<tr>
<td>滚轮</td>
<td>放大缩小版图视图</td>
<td></td>
</tr>
<tr>
<td>方向键</td>
<td>放大缩小版图视图</td>
<td></td>
</tr>
<tr>
<td>Shift+滚轮</td>
<td>左右移动版图视图</td>
<td></td>
</tr>
<tr>
<td>Shift+方向键</td>
<td>鼠标每次移动半个格点距离</td>
<td></td>
</tr>
<tr>
<td>Ctrl+方向键</td>
<td>移动cell使版图边界与视图边界对齐</td>
<td></td>
</tr>
<tr>
<td>Shift+左键</td>
<td>连续选择多个图像，如果不小心选多了，可以用Ctrl+左键减选图形</td>
<td>Cadence菜单中大写表示+按Shift，Ctrl写成^</td>
</tr>
<tr>
<td>F1</td>
<td>显示帮助窗口</td>
<td></td>
</tr>
<tr>
<td>F2</td>
<td>保存</td>
<td></td>
</tr>
<tr>
<td>F3</td>
<td>Save a Copy</td>
<td>在选取相应工具显示相应属性对话框，可以设置画线的走向，斜角等，比如在选取Path工具后，想要控制Path的走向，可以按F3调出对话框进行设置；还有如果想实现图形的镜像对称，也可以用F3键，选择对话框中的sideway（左右镜像）和updown（上下镜像）</td>
</tr>
<tr>
<td>F4</td>
<td>Toggle Partial Select，就是用来控制是否可以部分选择一个图形</td>
<td></td>
</tr>
<tr>
<td>F5</td>
<td>Open,打开</td>
<td></td>
</tr>
<tr>
<td>F8</td>
<td>Guided Path Create，切换至L90XYFirst</td>
<td></td>
</tr>
<tr>
<td>A</td>
<td>Quick Align，快速对准</td>
<td></td>
</tr>
<tr>
<td>Ctrl+A</td>
<td>全选</td>
<td></td>
</tr>
<tr>
<td>B</td>
<td>去某一级（Go to Level）</td>
<td></td>
</tr>
<tr>
<td>Shift+B</td>
<td>从子模块版图中返回上层版图</td>
<td></td>
</tr>
<tr>
<td>C</td>
<td>copy复制</td>
<td></td>
</tr>
<tr>
<td>Shift+C</td>
<td>chop裁切。首先调用命令，然后选中图形，然后随意裁切画好的图形，按F3有很多设置</td>
<td></td>
</tr>
<tr>
<td>D</td>
<td>取消选择。这个也可以用鼠标点击空白区域实现，Shift+D和Ctrl+D也是取消选择</td>
<td></td>
</tr>
<tr>
<td>F</td>
<td>满工作区显示</td>
<td></td>
</tr>
<tr>
<td>Shift+F</td>
<td>显示所有等级图层。在调用多层Instance时用起来方便</td>
<td></td>
</tr>
<tr>
<td>Ctrl+F</td>
<td>显示上层等级图层</td>
<td></td>
</tr>
<tr>
<td>G</td>
<td>gravity吸i附，开关引力。如果格点设置的不合适或遇到不规则的斜边时使用较方便，将鼠标放到图形的断点或边上时，可使用G。</td>
<td></td>
</tr>
<tr>
<td>I</td>
<td>添加元器件，左键放置、右键旋转、Esc推出载入</td>
<td></td>
</tr>
<tr>
<td>K</td>
<td>ruler，标尺工具，画标尺</td>
<td></td>
</tr>
<tr>
<td>Shift+K</td>
<td>label，标签工具，标签要加在特定的text层上</td>
<td></td>
</tr>
<tr>
<td>M</td>
<td>move，移动工具，点选move工具后，选中要移动的图形，然后在屏幕上任意一处单击一下，这个就是确定移动的参考点，然后可以自由移动了。这个也可以通过鼠标先选中一个图像，移动鼠标箭头办成十字方向的时候就可以通过拖动来实现</td>
<td></td>
</tr>
<tr>
<td>Shift+M</td>
<td>merge，合并工具，合并在一起的图形会变成一个平滑的整体；移动PIN：选中后按键盘的Shift+M，单击右键是旋转</td>
<td></td>
</tr>
<tr>
<td>N</td>
<td>diagonal，斜45°对角+正交，多次按可以变换走线方向</td>
<td></td>
</tr>
<tr>
<td>Shift+N</td>
<td>orthogonal，直角正交</td>
<td>Shift+N和Ctrl+N是控制走向的</td>
</tr>
<tr>
<td>Ctrl+N</td>
<td>先横后竖，L90XFirst</td>
<td></td>
</tr>
<tr>
<td>O</td>
<td>插入接触孔，create contact</td>
<td></td>
</tr>
<tr>
<td>Shift+O</td>
<td>rotate旋转</td>
<td></td>
</tr>
<tr>
<td>P</td>
<td>画path，摁P后点击连接起始端，选择要连接的层，再单击结束端，再摁回车结束</td>
<td></td>
</tr>
<tr>
<td>Shift+P</td>
<td>polygon，多边形工具</td>
<td></td>
</tr>
<tr>
<td>Ctrl+P</td>
<td>pin，插入引脚</td>
<td></td>
</tr>
<tr>
<td>Q</td>
<td>查看器件属性，左键选中后按Q</td>
<td></td>
</tr>
<tr>
<td>Shift+Q</td>
<td>打开设计属性对话框，左键选中后按Shift+Q</td>
<td></td>
</tr>
<tr>
<td>R</td>
<td>rectangle，矩形工具，画矩形</td>
<td></td>
</tr>
<tr>
<td>Shift+R</td>
<td>reshape，重定形，就是在原来的图形上再补上一块图形</td>
<td></td>
</tr>
<tr>
<td>Ctrl+R</td>
<td>redraw，重画</td>
<td></td>
</tr>
<tr>
<td>S</td>
<td>stretch，框选要拉伸图形，再拉伸</td>
<td></td>
</tr>
<tr>
<td>Shift+S</td>
<td>search，查找</td>
<td></td>
</tr>
<tr>
<td>Ctrl+S</td>
<td>split，添加拐点，就是配合stretch命令可以是原来值的path打弯</td>
<td></td>
</tr>
<tr>
<td>T</td>
<td>tap，查看该点各层信息</td>
<td></td>
</tr>
<tr>
<td>Shift+T</td>
<td>tree</td>
<td></td>
</tr>
<tr>
<td>Ctrl+T</td>
<td>Zoom to Set</td>
<td></td>
</tr>
<tr>
<td>U</td>
<td>undo，撤销</td>
<td></td>
</tr>
<tr>
<td>Shift+U</td>
<td>取消撤销</td>
<td></td>
</tr>
<tr>
<td>V</td>
<td>attatch，关联，将一个子图形（child）关联到一个父图形（parent）后，若移动parent，则child也将跟着移动，若移动child，则parent不会移动。可以将label关联到pad上</td>
<td></td>
</tr>
<tr>
<td>Ctrl+V</td>
<td>Type in CIW</td>
<td></td>
</tr>
<tr>
<td>W</td>
<td>连线</td>
<td></td>
</tr>
<tr>
<td>X</td>
<td>保存电路原理图</td>
<td></td>
</tr>
<tr>
<td>Shift+X</td>
<td>进入版图的子模块</td>
<td></td>
</tr>
<tr>
<td>Ctrl+X</td>
<td>fit edit，适合编辑</td>
<td></td>
</tr>
<tr>
<td>Y</td>
<td>yank，区域复制，如果你想复制某个区域的全部图形而且又不是完整的图形，那么copy就不行的，先按Y，鼠标框选中要复制的区域，然后Shift+Y粘贴即可；copy只能复制完整图形对象</td>
<td></td>
</tr>
<tr>
<td>Z</td>
<td>视图放大</td>
<td></td>
</tr>
<tr>
<td>Shift+Z</td>
<td>缩小版图视图两倍</td>
<td></td>
</tr>
<tr>
<td>Ctrl+Z</td>
<td>放大版图视图两倍</td>
<td></td>
</tr>
<tr>
<td>Esc</td>
<td>cancel，取消</td>
<td></td>
</tr>
<tr>
<td>Tab</td>
<td>平移视图Pan，按Tab，用鼠标点击视图区中某一点，视图就会移至以该点为中心</td>
<td></td>
</tr>
<tr>
<td>Delete</td>
<td>删除</td>
<td></td>
</tr>
<tr>
<td>Backspace</td>
<td>撤销上一点</td>
<td></td>
</tr>
<tr>
<td>Enter</td>
<td>确定图形的最后一点，也可以双击鼠标键结束</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>工具篇</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Cadence</tag>
        <tag>版图</tag>
      </tags>
  </entry>
  <entry>
    <title>测量范德堡法电阻率和霍尔电压</title>
    <url>/2021/09/15/%E6%B5%8B%E9%87%8F%E8%8C%83%E5%BE%B7%E5%A0%A1%E6%B3%95%E7%94%B5%E9%98%BB%E7%8E%87%E5%92%8C%E9%9C%8D%E5%B0%94%E7%94%B5%E5%8E%8B/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文转载自<a href="https://tech.sina.cn/2020-01-18/detail-iihnzahk4851160.d.html">测量范德堡法电阻率和霍尔电压</a></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>半导体材料研究和器件测试通常要测量样本的电阻率和霍尔电压。半导体材料的电阻率主要取决于体掺杂，在器件中，电阻率会影响电容、串联电阻和阈值电压。霍尔电压测量用来推导半导体类型(n还是p)、自由载流子密度和迁移率。</p>
<p>为确定半导体范德堡法电阻率和霍尔电压，进行电气测量时需要一个电流源和一个电压表。为自动进行测量，一般会使用一个可编程开关，把电流源和电压表切换到样本的所有侧。4200A-SCS参数分析仪拥有4个源测量单元(SMUs)和4个前置放大器(用于高电阻测量)，可以自动进行这些测量，而不需可编程开关。用户可以使用4个中等功率SMU (4200-SMU, 4201-SMU)或高功率SMU (4210-SMU, 4211-SMU)，对高电阻材料，要求使用4200-PA前置放大器。4200A-SCS包括多项内置测试，在需要时把SMU的功能自动切换到电压表或电流源，霍尔电压测量要求对样本应用磁场。</p>
<p>4200A-SCS包括交互软件，在半导体材料上进行范德堡法和霍尔电压测量。4200A-SCS Clarius+软件提供了全面的程序库，除电阻率和霍尔电压测试外，还包括许多其他测试和项目。范德堡法和霍尔电压测试是在Clarius V1.5和V1.6中新增的，包括计算确定表面或体积电阻率、霍尔迁移率和霍尔系数。</p>
<h3 id="范德堡法电阻率测量"><a href="#范德堡法电阻率测量" class="headerlink" title="范德堡法电阻率测量"></a>范德堡法电阻率测量</h3><p>人们通常使用范德堡法(vdp)推导半导体材料的电阻率。这种四线方法用在拥有四个端子、均匀厚度的小的扁平形样本上。电流通过两个端子施加到样本上，透过相反的两个端子测量电压下跌，如下图所示<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1634364476208-80f2160b-4ac1-4554-bdcc-0cd88f567590.png#align=left&display=inline&height=162&margin=%5Bobject%20Object%5D&originHeight=162&originWidth=180&size=0&status=done&style=none&width=180"></p>
<p>使用下图所示的SMU仪器配置，围着样本的边缘重复测量8次。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1634364565292-77253094-b27c-4c79-89e2-57d49ed6aefb.png#align=left&display=inline&height=249&margin=%5Bobject%20Object%5D&originHeight=249&originWidth=457&size=0&status=done&style=none&width=457"></p>
<p>然后使用这一串8项电压测量(V1-V8)和测试电流(I)来计算电阻率(ρ)，ρA和ρB是体积电阻率，fA和是样本对称度的几何因数，与两个电阻比率QA和QB相关。公式如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1634364598272-b78ab736-8588-4451-904c-0331f8d05f43.png#align=left&display=inline&height=148&margin=%5Bobject%20Object%5D&originHeight=148&originWidth=672&size=0&status=done&style=none&width=672"></p>
<h3 id="霍尔电压测量"><a href="#霍尔电压测量" class="headerlink" title="霍尔电压测量"></a>霍尔电压测量</h3><p>霍尔电压测量对半导体材料表征具有重要意义，因为从霍尔电压和电阻率可以导出传导率类型、载流子密度和迁移率。在应用磁场后，可以使用下面的I-V测量配置测量霍尔电压：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1634364647819-8f22b279-0b5b-49df-a73d-fbc7152b4b4f.png#align=left&display=inline&height=121&margin=%5Bobject%20Object%5D&originHeight=121&originWidth=298&size=0&status=done&style=none&width=298"><br>1、把正磁场B垂直应用到样本，在端子3和端子1之间应用一个电流(I31pBp)，测量端子2和端子4之间的电压下跌(V24pBp)。<br>2、颠倒电流(I31nBp)，再次测量电压下跌(V24nBp)。这种颠倒电流方法用来校正偏置电压。<br>3、从端子2到端子4应用电流(I24pBp)，测量端子1和端子3之间的电压下跌(V13pBp)。<br>4、颠倒电流(I24nBp)，再次测量电压下跌(V13nBp)。</p>
<blockquote>
<p>颠倒磁场Bn，再次重复这一过程，测量电压下跌V24pBn、V24nBn、V13pBn和V13nBn</p>
</blockquote>
<p>从8项霍尔电压测量中，可以使用下面的公式计算平均霍尔系数，RHC和RHD是霍尔系数(cm3/C)，计算出RHC和RHD后，可以通过下面的公式确定平均霍尔系数(RHAVG)，从范德堡法电阻率(ρAVG)(表示为输出参数Volume_Resistivity)和霍尔系数(RHAVG)中，可以计算出霍尔迁移率(μH)：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1634364761381-41d5b087-0bf5-4c91-bb2f-70a800b5b81f.png#align=left&display=inline&height=165&margin=%5Bobject%20Object%5D&originHeight=165&originWidth=526&size=0&status=done&style=none&width=526"></p>
<h2 id="使用4200A测量范德堡法电阻率和霍尔电压"><a href="#使用4200A测量范德堡法电阻率和霍尔电压" class="headerlink" title="使用4200A测量范德堡法电阻率和霍尔电压"></a>使用4200A测量范德堡法电阻率和霍尔电压</h2><p>4200A-SCS配有四个SMU和前置放大器，简化了范德堡法和霍尔电压测量，因为它包含多项内置测试，可以自动完成这些测量。在使用这些内置测试时，四个SMUs连接到样本的四个端子上，如下图所示。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1634364883760-30f6efc0-726d-4bfc-a9b0-7deb578efd66.png#align=left&display=inline&height=160&margin=%5Bobject%20Object%5D&originHeight=160&originWidth=211&size=0&status=done&style=none&width=211"><br>对每项测量，<strong>每个SMU的功能会在电流源、电压表或公共之间变化</strong>。先测量八项测试中每项测试的电压下跌和测试电流，然后导出电阻率或霍尔系数。霍尔电压测量要求对样本应用一个磁场。<br>Clarius+测试库包括范德堡法和霍尔迁移率测量的测试。在Select视图中，可以使用屏幕右侧Material材料过滤器，在Test Library测试库中找到这些测试，如图6所示。选择测试，然后选择Add添加，可以把这些测试添加到项目树中。这些测试从vdpulib用户程序库中的用户模块创建<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1634364967619-edb9e406-7126-43b5-8beb-8989b12ca69c.png#align=left&display=inline&height=284&margin=%5Bobject%20Object%5D&originHeight=284&originWidth=509&size=0&status=done&style=none&width=509"><br>可以使用范德堡法表面和体积电阻率测试。测试库有两项电阻率测试：vdp-surface-resistivity和vdp-volume-resistivity。vdp-surface-resistivity测试测量和计算电阻率，单位为Ω/square。对vdp-volume-resistivity测试，用户必须输入样本厚度，然后计算出电阻率，单位为Ω-cm。对这两项测试，都强制应用电流，进行8项电压测量。</p>
<p>还可以使用霍尔系数测试。使用四端SMU仪器，强制应用电流，使用正负磁场进行8项电压测量。磁场使用固定磁铁生成，会提示用户颠倒磁场。可以在测试库中找到hall-coefficient测试，添加到项目树中</p>
<p>为成功地进行电阻率测量，我们必需考虑潜在的错误来源。主要为<strong>静电干扰、泄漏电流、光线、温度、载流子注入</strong>等。<br>1、<strong>静电干扰</strong>：当带电物体放到不带电物体附近时，会发生静电干扰。通常情况下，干扰的影响并不显著，因为电荷在低电阻时会迅速消散。但是，高电阻材料不允许电荷迅速衰退，所以可能会导致测量不稳定。由于DC或DC静电场，可能会产生错误的读数。<br>2、<strong>泄漏电流</strong>：对高电阻样本，泄漏电流可能会劣化测量，泄漏电流源于电缆、探头和测试夹具的绝缘电阻，通过使用优质绝缘体、降低湿度、使用保护装置等，可以最大限度地降低泄漏电流。<br>3、<strong>光线</strong>：光敏效应产生的电流可能会劣化测量，特别是在高电阻样本上。为防止这种效应，应把样本放在暗舱中。<br>4、<strong>温度</strong>：热电电压也可能会影响测量精度，源电流导致的样本变热也可能会产生热电电压，实验室环境中的温度波动也可能会影响测量。由于半导体的温度系数相对较大，所以可能需要使用校正因数，补偿实验室中的温度变化。<br>5、<strong>载流子注入</strong>：此外，为防止少数/多数载流子注入影响电阻率测量，两个电压传感端子之间的电压差应保持在100mV以下，理想情况下是<strong>25mV</strong>，因为热电压kt/q约为26mV。在不影响测量精度的情况下，测试电流应尽可能低。</p>
<p>通过使用四个SMUs和内置测试，可以利用4200A-SCS参数分析仪简便地在半导体材料上实现范德堡法测量。通过使用用户提供的磁铁，还可以确定霍尔迁移率。如果想测试低电阻材料（如导体），可以使用基于Keithley 3765霍尔效应卡的系统，包括2182A纳伏表。</p>
]]></content>
      <categories>
        <category>笔记篇</category>
        <category>测试</category>
      </categories>
      <tags>
        <tag>版图</tag>
        <tag>器件</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Lift-off工艺制作金属电极</title>
    <url>/2021/08/13/%E5%88%A9%E7%94%A8Lift-off%E5%B7%A5%E8%89%BA%E5%88%B6%E4%BD%9C%E9%87%91%E5%B1%9E%E7%94%B5%E6%9E%81/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文转载自<a href="https://www.prlib.cn/knowledge-base/%E5%88%A9%E7%94%A8lift-off%E5%B7%A5%E8%89%BA%E5%88%B6%E4%BD%9C%E9%87%91%E5%B1%9E%E7%94%B5%E6%9E%81">利用LIFT-OFF工艺制作金属电极</a>，仅用于资料备份供个人学习使用。<br>在材料、微电子等研究课题中，制作高品质的电极是准确反映材料或者器件本身性能的前提条件，为此我们需要制作一个高品质的电极。在此，光刻中剥离（lift-off）工艺是我们制作电极的基础手段。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>剥离工艺（lift-off），在衬底上用光刻工艺获得图案化的光刻胶结构或者金属等掩膜（shadow mask），利用镀膜工艺在掩膜上镀上目标涂层，再利用去胶液（又称剥离液）溶解光刻胶或者机械去除金属硬掩膜的方式获得与图案一致的目标图形结构，我们称之为剥离工艺。<br>与其他图形转移手段相比，lift-off工艺更加简单易行。如下图所示，相同的结构可以通过不同的图形化工艺获得。这里我们重点介绍lift-off工艺，关于刻蚀（湿法以及干法刻蚀）、金属微结构或者模板的加工，待我们介绍<a href="https://www.prlib.cn/knowledge-base/liga-%e7%94%b5%e9%93%b8%e6%8a%80%e6%9c%af%e6%a6%82%e8%bf%b0">LIGA</a>再进行详细描述。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1628821660598-6719071b-7cbb-4b47-8206-0e3ec560888b.png#align=left&display=inline&height=603&margin=%5Bobject%20Object%5D&originHeight=708&originWidth=802&size=0&status=done&style=none&width=683"></p>
<h2 id="影响lift-off工艺的因素"><a href="#影响lift-off工艺的因素" class="headerlink" title="影响lift-off工艺的因素"></a><strong>影响lift-off工艺的因素</strong></h2><p>通过上面的描述，不难理解lift-off工艺的实现过程，但是这里面有一些细节，决定这lift-off工艺的成败与否。</p>
<h3 id="光刻胶的厚度"><a href="#光刻胶的厚度" class="headerlink" title="光刻胶的厚度"></a><strong>光刻胶的厚度</strong></h3><p>由上述定义可以看出，光刻胶在lift-off工艺中起到形成图案，以及让光刻胶上的薄膜层以及衬底上的沉积的薄膜层断开，从而实现光刻胶在去胶液中溶解过程中，上层金属飘落下来。<br>所以，这里光刻胶的厚度值是很关键的参数，通常我们会有一个经验值：<strong>光刻胶厚度/被剥离金属厚度≥3。</strong><br>但是需要注意，光刻胶的厚度会影响其分辨率，所以lift-off工艺不适用于特别厚的金属剥离。</p>
<h3 id="光刻胶种类"><a href="#光刻胶种类" class="headerlink" title="光刻胶种类"></a><strong>光刻胶种类</strong></h3><p>lift-off工艺在紫外光刻和电子束光刻中都是很常见的工艺，但是两者在光刻胶的选择上却有着较大的差异。这里我们先引入一个名词：<strong>底切（under cut）</strong>和顶切（top cut），其对应的光刻胶的形态见下图所示。由图我们也能看出光刻胶的形态对于lift-off成功与否有着直接关系。所以我们需要under cut结构。</p>
<ul>
<li>对于紫外光刻（含激光直写），由于其机理决定了，负胶（例如<a href="https://www.allresist.cn/?product=ar-n-4340">AR-N 4340</a>）相比于正胶更容易获得under cut形态，图形反转胶（<a href="https://www.allresist.cn/?product_cat=image-reversal-resist">AR-U 4000</a>）的负胶工艺能帮我们获得完美的under cut结构。</li>
<li>对于电子束胶来说，由于电子与光刻胶作用过程中的散射，正胶（如<a href="https://www.allresist.cn/?product=ar-p-631%EF%BD%9E679pmma">PMMA</a>）相比于负胶更容易获得under cut结构。当然，我们也可以通过工艺手段控制形成undercut结构（见下面双层胶工艺）；</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1628821837037-160e4d12-dec4-441a-a190-a7eb5d0b082d.png#align=left&display=inline&height=611&margin=%5Bobject%20Object%5D&originHeight=611&originWidth=1013&size=0&status=done&style=none&width=1013"></p>
<h3 id="双层剥离方案"><a href="#双层剥离方案" class="headerlink" title="双层剥离方案"></a><strong>双层剥离方案</strong></h3><p>上面介绍了光刻胶形态对lift-off工艺的影响，因此，我们也可以通过双层胶体系来获得under cut结构，这里紫外胶和电子束胶的原理和方案上有一些区别：</p>
<ul>
<li>紫外胶，我们需要将不含光敏的<strong>剥离胶</strong>（<a href="https://www.allresist.cn/?product=ar-br-5400">LOL，LOR，如AR-BR 5400</a>）置于紫外正胶或者负胶底层，利用上层胶的光刻胶经曝光显影后开出窗口，底层胶在显影液中继续腐蚀，并产生横向拓展，形成under cut结构，横向拓展的深度与显影液的碱当量以及显影时间呈正相关。</li>
<li>对于电子束胶，通常选择<strong>两种不同灵敏度的正胶</strong>，将高灵敏度的胶置于底层，低灵敏度的胶置于上层，在曝光过程显影过程中高灵敏度胶相比于地灵敏度胶显影结构会更宽，从而获得under cut结构。当然，也可将LOR胶置于电子束胶下层，利用两次显影工艺获得under cut结构，如下图所示，双层胶体系中要求，<strong>底层胶的厚度至少是被剥离金属层厚度的1.25倍以上</strong>，上层胶来控制线宽，另外，横向拓展深度不易过深，否则容易在定影后的干燥环节由于液体表面张力的存在导致胶体坍塌。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1628821947285-cb73c322-5ce4-4d32-89cd-b39c80c93229.png#align=left&display=inline&height=540&margin=%5Bobject%20Object%5D&originHeight=540&originWidth=871&size=0&status=done&style=none&width=871"></p>
<h3 id="镀膜方式"><a href="#镀膜方式" class="headerlink" title="镀膜方式"></a><strong>镀膜方式</strong></h3><p>我们做电极最常用的镀膜方式有蒸发和溅射两种，这里我们仅以这两种镀膜方式为例子进行说明。</p>
<ul>
<li>蒸发（包括电子束蒸发和热蒸发）方式其金属以类似辐射的方式由源材料沉积到衬底上，方向性好。</li>
<li>溅射工艺，金属粒子能量大，弥散在整个真空腔室中，没有很好的方向性。</li>
</ul>
<p>这种方向性决定了金属化过程中金属膜对光刻胶侧壁的包覆性。溅射镀膜会将整个光刻胶断面包覆起来，轻度的将导致剥离困难，或者形成的电极边缘不光滑、有毛刺，重度的将导致任你选用何种剥离液，是否辅以超声或者加热，都无法实现剥离。所以，这里我们<strong>首选蒸发镀膜</strong>的方式。</p>
<h3 id="温度"><a href="#温度" class="headerlink" title="温度"></a><strong>温度</strong></h3><p>这里我们介绍两个工艺过程的温度对lift-off工艺的影响。</p>
<ul>
<li>坚膜（hard bake），我们在光刻胶的产品资料中常常会见到坚膜步骤会标注为选做步骤，那么对于lift-off工艺来说，我们一般建议<strong>不做坚膜</strong>，因为坚膜会使光刻胶的稳定性得到提高，也就会对后续的剥离步骤带来困难；</li>
<li>镀膜过程中的温度，镀膜过程中我们一定要<strong>控制好温度</strong>，因为温度过高（超过光刻胶的玻璃态转化温度）则会导致光刻胶软化，图案变形。另外，有些胶在这个温度下会加剧交联化，导致后续使用去胶液很难去除光刻胶。</li>
</ul>
<p>利用蒸发镀膜的膜厚胶厚的情况下一定要注意温度，因为较厚的镀膜往往需要较长的镀膜时间，光刻胶不可避免的被加热，由于<strong>镀膜过程中受热</strong>可能导致<strong>光刻胶变形</strong>、光刻胶与衬底以及薄膜的热膨胀系数不同，会导致<strong>薄膜层褶皱</strong>，<strong>边缘翘起</strong>等现象。必要的时候可以选择间歇镀膜来改善这种热效应。</p>
<h3 id="剥离过程"><a href="#剥离过程" class="headerlink" title="剥离过程"></a><strong>剥离过程</strong></h3><p>通常我们每款光刻胶都会有推荐的去胶液，在正常工艺下，<strong>使用配套的去胶液</strong>是能够很好的实现lift-off工艺的，如果遇到剥离困难，也可考虑使用<strong>超声辅助</strong>，或者将部分剥离液<strong>升高温度</strong>至50~80℃来加速剥离过程（注意部分有机溶剂加热会有危险，需正确谨慎的操作）。这里请尽可能<strong>不要使用去胶机</strong>（如<a href="http://www.germantech.com.cn/new/cplook.asp?id=400">alpha plasma Q 235</a>）来做lift-off工艺，因为完全依赖光刻胶很小的开口使光刻胶灰化不仅效果达不到效果，反而去胶机的氧等离子体有可能使金属电极发生氧化。当然去胶机在lift-off工艺中可以实现打底胶工艺（下面介绍）。<br>综上所述，我们通过规范的操作就能获得一个形态完美的金属电极了，但是他未必是一个高品质的电极。因此，我们通常还得注意一下细节。</p>
<ul>
<li><strong>接触电阻：</strong>在绝大多数情况下，我们无需担心接触电阻的问题，但是当我们做完电极后发现其品质较差，那我们就得排除是否由于光刻胶显影后的残胶导致的接触电阻过大，我们可以通过在镀膜前利用去胶机的氧等离子稍微打一下，我们称之为打底胶工艺，从而去除残胶。打底胶过程不易过长，否则光刻胶的整体厚度会减小很多。推荐使用微波等离子体去胶机（如<a href="http://www.germantech.com.cn/new/cplook.asp?id=400">alpha plasma Q系列</a>），相比于射频去胶机来说，对衬底没有物理轰击损伤；</li>
<li><strong>对于纳米线或者纳米带结构：</strong>这种结构在垂直方向有一定的厚度，在边缘处如果比较陡直的话，我们需要要注意金属电极的厚度，不能太薄了（常规电极厚度80nm左右即可），否则容易导致金属电极在材料边缘断线。</li>
<li><strong>金属与衬底的粘附性：</strong>在做电极时，我们要特别注意金属电极层与衬底的粘附性，如果粘附性不好需要做一些处理，如Au在Si衬底上的粘附性就不是很好，所以我们通常需要做Ti/Ni/Au。避免在做lift-off的工艺时金属漂落。</li>
</ul>
]]></content>
      <categories>
        <category>笔记篇</category>
        <category>工艺</category>
      </categories>
      <tags>
        <tag>工艺</tag>
      </tags>
  </entry>
  <entry>
    <title>光刻工艺流程</title>
    <url>/2021/07/15/%E5%85%89%E5%88%BB%E5%B7%A5%E8%89%BA%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文转载自知乎上Litho wiki的<a href="https://www.zhihu.com/collection/681643459">光刻工艺流程（精简版）</a>，仅作为资料备份供个人学习使用，著作权归原作者所有。</p>
<h2 id="光刻概念"><a href="#光刻概念" class="headerlink" title="光刻概念"></a>光刻概念</h2><p>光刻（光学曝光），是指利用特定波长的光进行辐照，将掩膜板上的图形转移到光刻胶上的过程。 光学曝光是一个复杂的物理化学过程，具有大面积、重复性好、易操作以及成本低等特点，是半导体器件与大规模集成电路制造的核心步骤。</p>
<h2 id="光刻工艺流程："><a href="#光刻工艺流程：" class="headerlink" title="光刻工艺流程："></a>光刻工艺流程：</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12924220/1628817953846-915dc3dc-ed68-460a-b2b7-fb8bb4cbfc1c.jpeg#align=left&display=inline&height=314&margin=%5Bobject%20Object%5D&originHeight=314&originWidth=720&size=0&status=done&style=none&width=720"></p>
<h2 id="衬底预处理（Substrate-Pre-treatment）"><a href="#衬底预处理（Substrate-Pre-treatment）" class="headerlink" title="衬底预处理（Substrate Pre-treatment）"></a>衬底预处理（Substrate Pre-treatment）</h2><ul>
<li><a href="https://link.zhihu.com/?target=https://www.prlib.cn/knowledge-base/%25e5%2585%2589%25e5%2588%25bb%25e5%2589%258d%25e8%25a1%25ac%25e5%25ba%2595%25e5%25a6%2582%25e4%25bd%2595%25e6%25b8%2585%25e6%25b4%2597">去除表面污染物</a>（颗粒、有机物、工艺残余、可动离子）以及水蒸气；</li>
<li>预烘烤至 100~200℃可有助于增强光刻胶与衬底的黏附性；</li>
<li>对于亲水性衬底（如，SiO2、玻璃、贵金属膜、GaAs 等），使用增附剂（如，AR 300-80 或 HMDS）增加衬底与光刻胶的黏附性， 称为<a href="https://link.zhihu.com/?target=https://www.prlib.cn/knowledge-base/%25e5%258c%2580%25e8%2583%25b6%25e5%2589%258d%25e8%25a1%25ac%25e5%25ba%2595%25e5%25a2%259e%25e9%2599%2584%25e5%25a4%2584%25e7%2590%2586">增附或者助黏</a>。</li>
</ul>
<blockquote>
<p>AR 300-80 new 的增附原理：<br>在衬底（如 SiO2 或 SiN）上旋涂 AR 300-80 new（4000rpm）并在 60℃（热板 2min；烘箱 25min）条件下前烘，可获得 15nm 厚的二苯基二羟基硅烷（Diphenylsilanediol）薄膜。衬底上原来的官能团（SiO2 的 -OH 或 SiN 的 -N）将会被很薄的一 层二苯基二羟基硅烷（Diphenylsilanediol）链接层取代。当旋涂光刻胶时，这层很薄的二苯基二羟基硅烷（Diphenylsilanediol） 将迅速溶解于光刻胶的溶剂中，溶解于光刻胶中的二苯基二羟基硅烷（Diphenylsilanediol）对后续的曝光和显影过程不会产生 影响。当然也可使用有机溶剂（如，丙酮、乙醇、苯甲醚……）将其去除，但其疏水性官能团依然保留在衬底表面。<br><img src="https://cdn.nlark.com/yuque/0/2021/jpg/12924220/1628818061036-e173a265-9f6a-40ae-96b5-47721515ca26.jpg#align=left&display=inline&height=174&margin=%5Bobject%20Object%5D&originHeight=174&originWidth=701&size=0&status=done&style=none&width=701"></p>
<p>如果需要恢复衬底的亲水性特性，可以使用强碱或者让等离子体刻蚀工艺来实现。</p>
</blockquote>
<h2 id="涂胶（Coating）"><a href="#涂胶（Coating）" class="headerlink" title="涂胶（Coating）"></a>涂胶（Coating）</h2><h3 id="涂胶方式"><a href="#涂胶方式" class="headerlink" title="涂胶方式"></a>涂胶方式</h3><p><a href="https://link.zhihu.com/?target=https://www.prlib.cn/knowledge-base/%25e5%2585%2589%25e5%2588%25bb%25e8%2583%25b6%25e6%2597%258b%25e6%25b6%2582%25e6%259b%25b2%25e7%25ba%25bf">旋转涂胶（Spin coating）</a>和<a href="https://link.zhihu.com/?target=https://www.prlib.cn/knowledge-base/%25e5%2596%25b7%25e6%25b6%2582%25e5%25b7%25a5%25e8%2589%25ba-spray-coating">喷涂（Spray coating）</a>等方法；</p>
<ul>
<li>涂胶前衬底需要冷却至室温，光刻胶也需在室温下开盖使用（冰箱中刚取出 的过冷光刻胶会冷凝空气中的水汽）；</li>
<li>光刻胶中的气泡需通过静置的方式使气泡逸出后使用，用滴管等取光刻胶时 动作要轻缓，避免带入气泡；</li>
<li>随着光刻胶的频繁开盖，溶剂挥发，光刻胶的厚度会相应的增加；</li>
<li>多次旋涂可以获得较厚的膜层，但涂新胶层前需要对已涂好的光刻胶层进行 烘烤并冷却，多次旋涂的均匀性会变差。</li>
</ul>
<blockquote>
<p><strong><em>涂胶均匀性影响因素</em></strong></p>
<ul>
<li>衬底的洁净程度和粗糙度以及疏水性质；</li>
<li>旋涂过程中由低速到高速阶段的加速度；</li>
<li>高速阶段前光刻胶的覆盖情况；</li>
<li>旋涂时间，一般厚胶需要较长的时间，薄胶旋涂时间过长反而对均匀性不利；</li>
</ul>
</blockquote>
<h2 id="前烘（Soft-bake）"><a href="#前烘（Soft-bake）" class="headerlink" title="前烘（Soft bake）"></a>前烘（Soft bake）</h2><h3 id="前烘目的"><a href="#前烘目的" class="headerlink" title="前烘目的"></a><a href="https://link.zhihu.com/?target=https://www.prlib.cn/knowledge-base/%25e5%2589%258d%25e7%2583%2598%25ef%25bc%2588%25e8%25bd%25af%25e7%2583%2598%25ef%25bc%2589-softbake">前烘</a>目的</h3><p>去除光刻胶中的溶剂、增强黏附性、释放光刻胶膜内应力以及防止光刻胶污染设备；</p>
<h3 id="常见的烘烤方式"><a href="#常见的烘烤方式" class="headerlink" title="常见的烘烤方式"></a>常见的烘烤方式</h3><p>热板，烘烤时间短，但易受外界环境影响；<br>烘箱，烘烤时间长，不适合厚胶的烘烤；</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>欠烘，易导致残余溶剂影响曝光及显影过程；</li>
<li>过烘，会减小光刻胶中感光成分的活性；</li>
<li>对于衬底对温度敏感的应用中，前烘温度可在较低温度（＜ 60℃）下进行，但需要适当延长烘烤时间；</li>
<li>烘烤后需要冷却至室温再进行后续工艺，特别是厚胶，曝光前需要等待一段时间来实现再吸水过程，保证显影速度和高对比度。</li>
</ul>
<h2 id="曝光（exposure）"><a href="#曝光（exposure）" class="headerlink" title="曝光（exposure）"></a><a href="https://link.zhihu.com/?target=https://www.prlib.cn/knowledge-base/%25e7%25b4%25ab%25e5%25a4%2596%25e6%259b%259d%25e5%2585%2589-%25e6%259b%259d%25e5%2585%2589%25e6%258a%2580%25e6%259c%25af">曝光（exposure）</a></h2><ul>
<li>掩膜对准式曝光：需要掩膜版获得图形，掩膜版图形和光刻胶图形为1:1关系，接触式和接近式，光源通常为UV光源；</li>
<li>步进投影式曝光：需要掩膜版获得图形，掩膜版与光刻胶之间有投影系统，按一定比例将图形曝光在光刻胶上；</li>
<li>激光直写：利用激光束按照预先设定的路径扫描来获得图形，通常使用DMD技术来实现激光光斑控制获得图形，无需掩膜版。</li>
<li>电子束直写：利用电子束作为光源对光刻胶进行曝光，曝光过程采用失量或者栅线扫描获得图形，无需掩膜版，通常分为高斯束和变形束。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpg/12924220/1628819922609-c1bbd8df-d7e8-49ad-a8b7-8c9810935fc2.jpg#align=left&display=inline&height=389&margin=%5Bobject%20Object%5D&originHeight=389&originWidth=1414&size=0&status=done&style=none&width=1414"></p>
<blockquote>
<p>曝光过程我们需要控制的是曝光剂量，按照光刻胶的种类以及技术资料获得相应的参考剂量。并通过实验获得最佳曝光剂量，注意加速电压也会影响曝光剂量。<br>对于导电性不良的衬底材料进行电子束曝光的时候，需要通过引入导电聚合物或者导电膜等手段改善导电性能，来避免荷电效应带来的缺陷。</p>
</blockquote>
<h2 id="后烘（post-exposure-bake-PEB）"><a href="#后烘（post-exposure-bake-PEB）" class="headerlink" title="后烘（post exposure bake-PEB）"></a>后烘（post exposure bake-PEB）</h2><p><a href="https://link.zhihu.com/?target=https://www.prlib.cn/knowledge-base/%25e5%2590%258e%25e7%2583%2598-peb">后烘</a>是指在曝光之后的光刻胶膜的烘烤过程。由于光刻胶膜还未显影，也就是说还未闭合，PEB也可以在高于光刻胶软化温度的情况下进行。这个工艺步骤不是必要步骤，在以下情况下需要进行：</p>
<ul>
<li>化学放大胶：光反应在曝光期间开始并在后烘环节中完成。“化学放大”的过程发生在，曝光后反应产物的催化下，并在烘烤中完成。这使得较厚的光刻胶可以使用较低的曝光剂量进行曝光，且显影速度快；</li>
<li>图形反转胶和交联型负胶：图形反转胶在反转工艺下需要在曝光后进行后烘工艺，来实现图形的反转，从而使曝光区域在显影后流下来。交联型负胶也需要在后烘环节来进行交联反应；</li>
<li>高反射率衬底上的单色光源曝光应用中，由于界面的反射，会在光刻胶内部形成干涉，这种干涉会导致显影时在光刻胶侧壁形成波浪条纹结构，即驻波效应。曝光后的后烘有助于光反应产物的扩散，因此随后显影过程中的光刻胶结构具有更陡峭和更光滑的侧壁。</li>
</ul>
<h2 id="显影（development）"><a href="#显影（development）" class="headerlink" title="显影（development）"></a>显影（development）</h2><p><a href="https://link.zhihu.com/?target=https://www.prlib.cn/knowledge-base/%25e6%2598%25be%25e5%25bd%25b1-development">显影（development）</a>过程中正胶薄膜结构的形成是通过溶解曝光区域，而负胶显影去除的是未曝光的区域，对于可重复的结果，温度范围在21-23℃误差±0.5°保持。</p>
<h3 id="常见的显影方式"><a href="#常见的显影方式" class="headerlink" title="常见的显影方式"></a>常见的显影方式</h3><p>浸没式（immersion）、喷淋式（spray）和搅拌式（puddle）三种。</p>
<h3 id="显影液种类"><a href="#显影液种类" class="headerlink" title="显影液种类"></a>显影液种类</h3><p>紫外光刻胶常见的显影液是碱性水溶液，分为含金属离子碱性显影液和不含金属离子基于TMAH的两种类别。<br>电子束胶的显影液有以有机溶剂和TMAH基的显影液量大类别。通常显影液的选择需要根据自己的光刻胶种类（一般会有推荐显影液）、样品（如衬底材料）、工艺（后续工艺对金属离子控制要求）等来进行选择。</p>
<h3 id="显影的影响因素"><a href="#显影的影响因素" class="headerlink" title="显影的影响因素"></a>显影的影响因素</h3><p>主要有显影液、显影方式以及温度等，同种光刻胶显影液稀释后显影速度降低，对比度提高、显影方式决定了光刻胶与新鲜显影液的接触是否充分，温度高，显影速度快。</p>
<h2 id="定影（stopping）"><a href="#定影（stopping）" class="headerlink" title="定影（stopping）"></a>定影（stopping）</h2><p>定影，终止显影过程，紫外光刻胶由于常用的是水溶性碱作为显影液，故常用水冲洗即可；电子束胶常用有机溶剂作为显影液，所以需要专门的定影液来进行定影。<br>需要注意的是，电子束曝光获得的深宽比很高的光刻胶结构，由于自身强度较弱，在表面张力作用下容易坍塌。<br>在lift-off工艺中，显影后底胶的处理，也需要特别注意。</p>
<h2 id="坚膜（hard-bake）"><a href="#坚膜（hard-bake）" class="headerlink" title="坚膜（hard bake）"></a>坚膜（hard bake）</h2><p>坚膜就是通过加温烘烤使胶膜更加牢固的粘附在晶圆表面，并可以增加胶层的抗刻蚀能力，坚膜并不是一道必需工艺。</p>
<ul>
<li>后续工艺为刻蚀工艺，建议进行坚膜，来提高光刻胶的稳定性。</li>
<li>后续工艺为lift-off工艺，一般不建议进行坚膜工艺，因为坚膜后光刻胶稳定性提高，反而不利于剥离的进行。</li>
<li>另外，一定要注意坚膜的温度，过高的温度会光刻胶结构变形、融化甚至图形消失。</li>
<li>当然我们也可以利用这种高温处理来获得一些特殊的应用，这种工艺叫热回流（reflow）。</li>
</ul>
<h2 id="图形转移（pattern-transfer）"><a href="#图形转移（pattern-transfer）" class="headerlink" title="图形转移（pattern transfer）"></a>图形转移（pattern transfer）</h2><ul>
<li><a href="https://link.zhihu.com/?target=https://www.prlib.cn/knowledge-base/%25e5%2588%25a9%25e7%2594%25a8lift-off%25e5%25b7%25a5%25e8%2589%25ba%25e5%2588%25b6%25e4%25bd%259c%25e9%2587%2591%25e5%25b1%259e%25e7%2594%25b5%25e6%259e%2581">金属剥离（lift-off）</a>：需要注意光刻胶的厚度与金属厚度的关系，尽可能获得undercut结构，必要时可以使用双层胶工艺，注意显影后的底胶可能会对器件造成影响，镀膜方式需要选择蒸发镀膜，注意较厚的金属镀膜的热效应；</li>
<li>刻蚀工艺：干法刻蚀需要选择光刻胶抗刻蚀性较好的胶（相对），计算好所需的光刻胶的厚度，注意刻蚀过程中的温度，刻蚀后由于光刻胶变性，湿法无法完成去胶，建议采用去胶机。湿法刻蚀需要选择粘附性好的胶，还需要做增附处理；</li>
<li>LIGA：与湿法腐蚀类似，需要选择与衬底粘附性好的胶，防止在液体中发生漂胶现象；</li>
<li>离子注入：需要选择一定厚度的耐温性和机械稳定性好的胶，高剂量离子注入后会导致光刻变性，需要使用去胶机进行去除。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpg/12924220/1628820333394-b0199327-6817-49de-8a6f-f16187bbf6c2.jpg#align=left&display=inline&height=159&margin=%5Bobject%20Object%5D&originHeight=159&originWidth=264&size=0&status=done&style=none&width=264"></p>
<h2 id="去胶（remove）"><a href="#去胶（remove）" class="headerlink" title="去胶（remove）"></a>去胶（remove）</h2><p>图形转移后，光刻胶就不再需要了，因此需要将其去除干净。</p>
<h3 id="去胶方式"><a href="#去胶方式" class="headerlink" title="去胶方式"></a>去胶方式</h3><p>去胶的方法通常有湿法和干法两种。</p>
<ul>
<li>湿法就是利用有机溶剂或者对光刻胶有腐蚀作用的溶液将光刻胶溶解或者腐蚀掉，从而达到去胶的目的，这里，去胶液的选择需要遵循与衬底反应或者不损伤衬底为前提条件。</li>
<li>干法去胶是利用氧等离子体将光刻胶灰化掉，从而达到去胶的目的。对于去胶方法的选择，一般推荐优先考虑湿法，因为湿法去胶更加简单，如果发生湿法无法去除的则考虑使用干法去胶，这里需要注意的是，干法去胶的过程中使用氧等离子体，可能会对样品有氧化。例如，lift-off工艺中不适合使用干法去胶，原因是去胶效果不如湿法去胶，且氧等离子体有可能使被剥离的金属产生氧化。</li>
</ul>
]]></content>
      <categories>
        <category>笔记篇</category>
        <category>工艺</category>
      </categories>
      <tags>
        <tag>工艺</tag>
      </tags>
  </entry>
  <entry>
    <title>LCD1602驱动模块设计</title>
    <url>/2021/06/14/LCD1602%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="LCD驱动模块前端设计流程"><a href="#LCD驱动模块前端设计流程" class="headerlink" title="LCD驱动模块前端设计流程"></a>LCD驱动模块前端设计流程</h1><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><ol>
<li>使用Verilog代码完成LCD1602型号的液晶显示屏驱动设计</li>
</ol>
<ul>
<li>LCD驱动模块的上位机为主控系统，下位机为LCD1602液晶显示屏；</li>
<li>要求LCD驱动模块与主控系统交互时使用APB接口（APB时钟采用64MHz) ；     </li>
<li>该驱动模块工作时钟使用外部时钟（工作时钟采用50MHz) ；</li>
<li>该模块初始化完成后，它所驱动的LCD1602液晶显示屏默认输出“ABCD至MNOP abcd至mnop”共16*2个英文字符，主控系统可通过APB总线控制液晶显示屏输出的字符；</li>
<li>该模块内部需要设计使能寄存器，模块每次向LCD1602液晶显示屏输出新的字符时，均需要通过APB总线配置使能寄存器；</li>
<li>该模块内部需要设计BUSY寄存器，主控系统可以通过APB总线读取驱动模块的忙或不忙状态（16*2个字符正在向显示屏输出，则模块处于忙状态，否则处于不忙状态)﹔</li>
<li>本设计只向LCD液晶显示屏写入数据，不对其进行读操作。</li>
</ul>
<ol start="2">
<li>字符型的显示原理</li>
</ol>
<ul>
<li>用LCD显示一个字符时比较复杂，因为一个字符由6×8或8×8点阵组成，既要找到和显示屏幕上某几个位置对应的显示RAM区的8字节，还要使每字节的不同位为”1”，其它的为”0”，为”1”的点亮，为”0”的不亮。这样一来就组成某个字符。</li>
<li>内带字符发生器的控制器来说，显示字符就比较简单了，可以让控制器工作在文本方式，根据在LCD上开始显示的行列号及每行的列数找出显示RAM对应的地址，设立光标，在此送上该字符对应的代码即可。</li>
</ul>
<ol start="3">
<li>RAM形式的标准字库</li>
</ol>
<p>液晶显示模块是一个慢显示器件，所以在执行每条指令之前一定要确认模块的忙标志为低电平，表示不忙，否则此指令失效（通过LCD读时序发送指令9)。要显示字符时要先输入显示字符地址，也就是告诉模块在哪里显示字符，如图是1602的内部显示地址<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1623723647525-e2d14a47-58fe-4ec1-a4a8-b6f240fe1a1e.png#align=left&display=inline&height=213&id=pTsd4&margin=%5Bobject%20Object%5D&originHeight=213&originWidth=639&status=done&style=none&width=639"></p>
<h2 id="功能架构"><a href="#功能架构" class="headerlink" title="功能架构"></a>功能架构</h2><p>LCD驱动模块的上位机为主控系统，下位机为LCD1602液晶显示屏<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1623723648005-7ccc5404-7528-43f0-b92b-dee5bc003158.png#align=left&display=inline&height=327&id=VpNct&margin=%5Bobject%20Object%5D&originHeight=327&originWidth=768&status=done&style=none&width=768"></p>
<h2 id="功能划分"><a href="#功能划分" class="headerlink" title="功能划分"></a>功能划分</h2><h3 id="硬件实现"><a href="#硬件实现" class="headerlink" title="硬件实现"></a>硬件实现</h3><p>该模块初始化完成后，它所驱动的LCD1602液晶显示屏默认输出“ABCD至MNOP abcd至mnop”共16*2个英文字符，主控系统可通过APB总线控制液晶显示屏输出的字符；</p>
<h3 id="软件实现"><a href="#软件实现" class="headerlink" title="软件实现"></a>软件实现</h3><ol>
<li>该模块内部需要设计使能寄存器，模块每次向LCD1602液晶显示屏输出新的字符时，均需要通过APB总线配置使能寄存器；</li>
<li>该模块内部需要设计BUSY寄存器，主控系统可以通过APB总线读取驱动模块的忙或不忙状态（16*2个字符正在向显示屏输出，则模块处于忙状态，否则处于不忙状态)；</li>
</ol>
<h2 id="接口协议"><a href="#接口协议" class="headerlink" title="接口协议"></a>接口协议</h2><p>LCD1602液晶模块内部的控制器共有11条控制指令，如下表所示：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>指令</th>
<th>RS</th>
<th>R/W</th>
<th>D7</th>
<th>D6</th>
<th>D5</th>
<th>D4</th>
<th>D3</th>
<th>D2</th>
<th>D1</th>
<th>D0</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>清显示</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>光标返回</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>*</td>
</tr>
<tr>
<td>3</td>
<td>置输入模式</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>I/D</td>
<td>S</td>
</tr>
<tr>
<td>4</td>
<td>显示开/关控制</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>D</td>
<td>C</td>
<td>B</td>
</tr>
<tr>
<td>5</td>
<td>光标或字符移位</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>S/C</td>
<td>R/L</td>
<td>*</td>
<td>*</td>
</tr>
<tr>
<td>6</td>
<td>置功能</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>DL</td>
<td>N</td>
<td>F</td>
<td>*</td>
<td>*</td>
</tr>
<tr>
<td>7</td>
<td>置字符发生存储器地址</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>字符发生存储器地址</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>置数据存储器地址</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>显示数据存储器地址</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>读忙标志或地址</td>
<td>0</td>
<td>1</td>
<td>BF</td>
<td>计数器地址</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>10</td>
<td>写数到CGRAM或DDRAM</td>
<td>1</td>
<td>0</td>
<td>要写的数据内容</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>11</td>
<td>从CGRAM或DDRAM读数</td>
<td>1</td>
<td>1</td>
<td>读出的数据内容</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>指令1：清显示，指令码01H,光标复位到地址00H位置。<br>指令2：光标复位，光标返回到地址00H。<br>指令3：光标和显示模式设置VD:光标移动方向，高电平右移，低电平左移S：屏幕所有文字是否左移或者右移。高电平表示有效，低电平则无效。<br>指令4：显示开关控制。D：控制整体显示的开与关，高电平表示开显示，低电平表示关显示C：控制光标的开与关，高电平表示有光标，低电平表示无光标B：控制光标是否闪烁，高电平闪烁，低电平不闪烁。<br>指令5：光标或显示移位S/C：高电平时移动显示的文字，低电平时移动光标。<br>指令6：功能设置命令DL；高电平时为4位总线，低电平时为8位总线N；低电平时为单行显示，高电平时双行显示F：低电平时显示5<em>7的点阵字符，高电平时显示5</em>10的点阵字符。<br>指令7：字符发生器RAM地址设置。<br>指令8：DDRAM地址设置。<br>指令9：读忙信号和光标地址BF：为忙标志位，高电平表示忙，此时模块不能接收命令或者数据，如果为低电平表示不忙。<br>指令10：写数据。<br>指令11：读数据。</p>
<h2 id="接口时序"><a href="#接口时序" class="headerlink" title="接口时序"></a>接口时序</h2><h3 id="APB写时序"><a href="#APB写时序" class="headerlink" title="APB写时序"></a>APB写时序</h3><p>如图所示，地址（PADDR)、写信号（PWRITE)、选择信号（PSEL)、写数据（PWDATA)在时钟上升沿到来时有效。表明一次写传输的开始，传输的第一个时钟周期称为SETUP周期。在第二个时钟上升沿使能信号（PENABLE）有效，进入ENABLE周期。而地址、写数据和控制信号需要在此期间保持有效。传输在ENABLE周期结束时完成，此时PENABLE变为低电平，PSEL也变为低电平。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1623723648513-671755c8-5a33-4b51-92e9-1ba3931f2d2f.png#align=left&display=inline&height=318&id=KpNKE&margin=%5Bobject%20Object%5D&originHeight=318&originWidth=513&status=done&style=none&width=513"></p>
<h3 id="APB读时序"><a href="#APB读时序" class="headerlink" title="APB读时序"></a>APB读时序</h3><p>由图所示，地址（PADDR)、写信号（PWRITE)、选择信号（PSEL)、写数据（PWDATA)在时钟上升沿到来时有效。在读传输时，从设备必须在ENABLE周期提供数据，读数据在ENABLE周期结束的时钟上升沿被主设备采样。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1623723649029-4d50b1db-ff34-4fe8-8e63-0b6c4ac2f7b0.png#align=left&display=inline&height=324&id=mc2Pj&margin=%5Bobject%20Object%5D&originHeight=324&originWidth=521&status=done&style=none&width=521"></p>
<h3 id="LCD写操作时序"><a href="#LCD写操作时序" class="headerlink" title="LCD写操作时序"></a>LCD写操作时序</h3><p>如图所示，在LCD写操作时序中，RS引脚和R/W引脚先变化，其中R/W引脚先置高，变化了tAS时间后使能引脚E从低电平变为高电平，然后上位机写入DB数据，写完之后，使能信号E从高变低。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1623723649327-13d478d1-5026-433f-b4c0-47db1109d677.png#align=left&display=inline&height=346&id=o9fCa&margin=%5Bobject%20Object%5D&originHeight=346&originWidth=675&status=done&style=none&width=675"></p>
<table>
<thead>
<tr>
<th>Item</th>
<th>Symbol</th>
<th>Min</th>
<th>Typ</th>
<th>Max</th>
<th>Unit</th>
</tr>
</thead>
<tbody><tr>
<td>Enable cycle time</td>
<td>tcycE</td>
<td>500</td>
<td>-</td>
<td>-</td>
<td>ns</td>
</tr>
<tr>
<td>Enable pulse width(high level)</td>
<td>PWEH</td>
<td>230</td>
<td>-</td>
<td>-</td>
<td>ns</td>
</tr>
<tr>
<td>Enable rise/fall time</td>
<td>tEr,tEf</td>
<td>-</td>
<td>-</td>
<td>20</td>
<td>ns</td>
</tr>
<tr>
<td>Address set-up time(RS,R/W to E)</td>
<td>tAS</td>
<td>40</td>
<td>-</td>
<td>-</td>
<td>ns</td>
</tr>
<tr>
<td>Address hold time</td>
<td>tAH</td>
<td>10</td>
<td>-</td>
<td>-</td>
<td>ns</td>
</tr>
<tr>
<td>Data set-up time</td>
<td>tDSW</td>
<td>80</td>
<td>-</td>
<td>-</td>
<td>ns</td>
</tr>
<tr>
<td>Data hold time</td>
<td>tH</td>
<td>10</td>
<td>-</td>
<td>-</td>
<td>ns</td>
</tr>
</tbody></table>
<h3 id="LCD读操作时序"><a href="#LCD读操作时序" class="headerlink" title="LCD读操作时序"></a>LCD读操作时序</h3><p>如图所示，RS和R/W引脚先变化，因为是读操作R/W引脚首先置为高电平经过tAS时间后，使能引脚E才从低电平变到高电平，经过tD时间后，我们进行数据读取，读取完成后，再把使能E拉低，经过一段时间后，可以继续下一次读写操作。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1623723649715-53f21345-1f35-4036-8a2d-8cc905257d48.png#align=left&display=inline&height=352&id=hjmB2&margin=%5Bobject%20Object%5D&originHeight=352&originWidth=679&status=done&style=none&width=679"><br>图6 LCD读操作时序</p>
<table>
<thead>
<tr>
<th>Item</th>
<th>Symbol</th>
<th>Min</th>
<th>Typ</th>
<th>Max</th>
<th>Unit</th>
</tr>
</thead>
<tbody><tr>
<td>Enable cycle time</td>
<td>tcycE</td>
<td>500</td>
<td>-</td>
<td>-</td>
<td>ns</td>
</tr>
<tr>
<td>Enable pulse width(high level)</td>
<td>PWEH</td>
<td>230</td>
<td>-</td>
<td>-</td>
<td>ns</td>
</tr>
<tr>
<td>Enable rise/fall time</td>
<td>tEr,tEf</td>
<td>-</td>
<td>-</td>
<td>20</td>
<td>ns</td>
</tr>
<tr>
<td>Address set-up time(RS,R/W to E)</td>
<td>tAS</td>
<td>40</td>
<td>-</td>
<td>-</td>
<td>ns</td>
</tr>
<tr>
<td>Address hold time</td>
<td>tAH</td>
<td>10</td>
<td>-</td>
<td>-</td>
<td>ns</td>
</tr>
<tr>
<td>Data delay time</td>
<td>tDDR</td>
<td>-</td>
<td>-</td>
<td>100</td>
<td>ns</td>
</tr>
<tr>
<td>Data hold time</td>
<td>tDHR</td>
<td>5</td>
<td>-</td>
<td>-</td>
<td>ns</td>
</tr>
</tbody></table>
<h2 id="功能分解"><a href="#功能分解" class="headerlink" title="功能分解"></a>功能分解</h2><h3 id="结构框架"><a href="#结构框架" class="headerlink" title="结构框架"></a>结构框架</h3><ul>
<li>设计框架主要由APB、LCD接口，内部寄存器模块，LCD主状态机控制模块构成</li>
<li>数据或命令内部寄存使用多组寄存器来设计，每组寄存器对应4个字符，一个字符8bit数据</li>
<li>LCD主状态机控制可灵活设计，包括打开功能设置、关闭显示、清显示、设置为输入模式、打开显示、光标跳至1行1列、光标跳至2行1列命令以及显示数据等状态，要满足驱动模块通过控制HD44780芯片，来实现LCD显示的目的</li>
<li>LCD驱动模块的复位通过外部复位信号控制</li>
<li>LCD时序只需要设计写操作即可</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1623723650095-5fe5c9a6-9784-445f-ba68-b37b562b4cd2.png#align=left&display=inline&height=344&id=ekFir&margin=%5Bobject%20Object%5D&originHeight=344&originWidth=971&status=done&style=none&width=971"></p>
<h3 id="APB接口和LCD接口"><a href="#APB接口和LCD接口" class="headerlink" title="APB接口和LCD接口"></a>APB接口和LCD接口</h3><ul>
<li>APB接口模块要设计为从机接口，时钟采用64MHz，地址数据位宽均为32bit，此接口可以使用ready，也可以不使用。</li>
<li>LCD接口模块要设计为主机接口，时钟采用50MHz，data7-0值包含数据和命令。<table>
<thead>
<tr>
<th>读状态</th>
<th>输入</th>
<th>RS=L,R/W=H,E=H</th>
<th>输出</th>
<th>D0-D7=状态字</th>
</tr>
</thead>
<tbody><tr>
<td>写指令</td>
<td>输入</td>
<td>RS=L,R/W=L,D0-D7=指令码,E=高脉冲</td>
<td>输出</td>
<td>无</td>
</tr>
<tr>
<td>读数据</td>
<td>输入</td>
<td>RS=H,R/W=H,E=H</td>
<td>输出</td>
<td>D7-D0=数据</td>
</tr>
<tr>
<td>写数据</td>
<td>输入</td>
<td>RS=H,R/W=L,D0-D7=数据,E=高脉冲</td>
<td>输出</td>
<td>无</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="寄存器功能"><a href="#寄存器功能" class="headerlink" title="寄存器功能"></a>寄存器功能</h3><ul>
<li>字符显示寄存器：主控系统通过APB总线对LCD驱动模块的寄存器进行读写，将字符对应的十六进制码（可通过工具生成）写入字符寄存器</li>
<li>使能寄存器：写入字符寄存器后，打开使能控制寄存器，LCD驱动对LCD1602液晶显示屏进行写字符操作</li>
<li>BUSY寄存器：主控系统对整个驱动流程可通过APB总线来查询驱动模块是否处于忙状态</li>
</ul>
<h3 id="初始化（复位）过程"><a href="#初始化（复位）过程" class="headerlink" title="初始化（复位）过程"></a>初始化（复位）过程</h3><ul>
<li><p>在LCD驱动初始化功能</p>
<blockquote>
<p>驱动上电完成后延时15ms<br>写指令38H（不检测忙信号)<br>延时5ms<br>写指令38H（不检测忙信号)<br>延时5ms<br>写指令38H（不检测忙信号)<br>以后每次写指令、读/写数据操作均需要检测忙信号（以下指令在每帧的LCD字符重新输出时，都要执行)<br>写指令38H：显示模式设置<br>写指令08H：显示关闭<br>写指令01H：显示清屏<br>写指令06H：显示光标移动设置<br>写指令0CH：显示开及光标设置</p>
</blockquote>
</li>
<li><p>LCD驱动初始化完成驱动LCD液晶显示屏显示“ABCD至MNOP abcd至mnop”共16*2个英文字符</p>
</li>
</ul>
<h3 id="主状态机功能"><a href="#主状态机功能" class="headerlink" title="主状态机功能"></a>主状态机功能</h3><ul>
<li>主状态机主要实现向LCD1602内置的HD44780芯片发送命令，用于控制屏幕显示、关闭，控制光标的位置与移动字符显示。</li>
<li>在字符显示状态时，首先要输出显示地址，即光标的位置，之后输出要显示字符的十六进制数据，此时LCD1602的光标会自动后移。</li>
<li>在光标移动到每一行的最后位置时，需要通过命令调正光标回到下一行的首列。</li>
</ul>
<h2 id="功能设计"><a href="#功能设计" class="headerlink" title="功能设计"></a>功能设计</h2><h3 id="时钟、复位"><a href="#时钟、复位" class="headerlink" title="时钟、复位"></a>时钟、复位</h3><p>模块中使用一个外部50MHz工作时钟和64MHz的APB时钟，复位使用外部复位，低电平复位有效，高电平释放复位，采用异步复位同步释放。</p>
<h3 id="字符写入过程"><a href="#字符写入过程" class="headerlink" title="字符写入过程"></a>字符写入过程</h3><ul>
<li>写入显示地址时要求最高位D7恒定为高电平1，例如第二行第一个字符的地址是40H，实际写入的数据应该是01000000B (40H) +10000000B(80H) = 11000000B(C0H)。</li>
<li>在液晶模块显示字符时光标是自动右移的，无需人工干预。</li>
<li>1602液晶模块内部的字符发生存储器（CGROM）已经存储了160个不同的点阵字符图形，这些字符有：阿拉伯数字、英文字母的大小写、常用的符号、和日文假名等，每一个字符都有一个固定的代码，比如大写的英文字母“A”的代码是01000001B(41H)，显示时模块把地址41H中的点阵字符图形显示出来，我们就能看到字母“A”。</li>
</ul>
<h3 id="主状态机"><a href="#主状态机" class="headerlink" title="主状态机"></a>主状态机</h3><ul>
<li>状态共分为打开功能设置（发送38H)、关闭显示（发送08H)、清显示（发送01H)、设置为输入模式（发送06H)、打开显示（发送OCH)、光标跳至1行1列（发送80H)、发送字符（发送数据)、光标跳至2行1列（发送COH)、发送字符（发送数据）命令。</li>
<li>输出只和状态有关而与输入无关，故采用Moore状态机。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1623724874546-0dea39a2-6d35-46b2-acd0-0c8a04dc85b4.png#align=left&display=inline&height=327&margin=%5Bobject%20Object%5D&name=image.png&originHeight=327&originWidth=1110&size=41040&status=done&style=none&width=1110" alt="image.png"></p>
<h3 id="显示流程"><a href="#显示流程" class="headerlink" title="显示流程"></a>显示流程</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1623724894879-e2b40361-ef7c-463c-b43c-1091ad2ed791.png#align=left&display=inline&height=661&margin=%5Bobject%20Object%5D&name=image.png&originHeight=661&originWidth=327&size=20584&status=done&style=none&width=327" alt="image.png"></p>
<h2 id="功能仿真"><a href="#功能仿真" class="headerlink" title="功能仿真"></a>功能仿真</h2><ol>
<li>将写好的rtl代码使用make命令运行，其中Makefile文件中包含</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1623723651129-f07a780c-89d3-4462-9098-60e8338b93b1.png#align=left&display=inline&height=356&id=cuUWr&margin=%5Bobject%20Object%5D&originHeight=619&originWidth=817&status=done&style=none&width=470"></p>
<ol start="2">
<li>打开图形界面后，选中顶层点击Dump，然后进行仿真，并查看run.log。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1623723651892-88a77e48-5777-4f18-946d-c2e8c8365ce1.png#align=left&display=inline&height=258&id=DeaKC&margin=%5Bobject%20Object%5D&originHeight=1017&originWidth=1920&status=done&style=none&width=488"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1623723652394-a2ac84d3-3f65-4d4d-8fab-3cdf7da8d879.png#align=left&display=inline&height=274&id=qenQM&margin=%5Bobject%20Object%5D&originHeight=1017&originWidth=1920&status=done&style=none&width=518"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1623723652926-daea04f0-0333-4cfa-aabc-afeeda640a7a.png#align=left&display=inline&height=270&id=jMpHY&margin=%5Bobject%20Object%5D&originHeight=1017&originWidth=1920&status=done&style=none&width=510"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1623723653456-cb84357b-eae9-4372-84b1-38801fc7ba71.png#align=left&display=inline&height=269&id=b8CaN&margin=%5Bobject%20Object%5D&originHeight=1017&originWidth=1920&status=done&style=none&width=507"></p>
<ol start="3">
<li>将顶层文件中的端口添加到波形窗口查看波形。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1623723653922-dbb12eca-c3b9-4bad-a1a7-39639503f754.png#align=left&display=inline&height=256&id=Xtr6V&margin=%5Bobject%20Object%5D&originHeight=1017&originWidth=1920&status=done&style=none&width=483"><br>从上图我们可以看出LCD驱动模块初始化之后，会先对液晶显示屏输入命令做初始化设置，再驱动LCD液晶显示屏显示“ABCD至MNOP abcd至mnop”共16*2个英文字符。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1623723654412-6fffe270-54a8-4c9e-ba3e-afc44665eded.png#align=left&display=inline&height=272&id=CfrrN&margin=%5Bobject%20Object%5D&originHeight=1009&originWidth=1912&status=done&style=none&width=516"><br>上图为APB接口波形图，此时上位机通过APB接口先配置显示使能寄存器，再配置字符寄存器。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1623723654797-c9101c5d-4ec2-480c-806b-c6076658f8e6.png#align=left&display=inline&height=265&id=fRy0m&margin=%5Bobject%20Object%5D&originHeight=1009&originWidth=1912&status=done&style=none&width=503"><br>上图为上位机配置内部寄存器以后，LCD驱动模块驱动下位机重新显示字符的波形图，从波形图上来看，配置寄存器以后驱动模块依然能正常向下位机LCD1602液晶显示屏发送数据，符合功能设计需求。</p>
<h1 id="LCD驱动模块后端流程"><a href="#LCD驱动模块后端流程" class="headerlink" title="LCD驱动模块后端流程"></a>LCD驱动模块后端流程</h1><h2 id="逻辑综合"><a href="#逻辑综合" class="headerlink" title="逻辑综合"></a>逻辑综合</h2><p>逻辑综合将 RTL 编码转换为特定时序约束下的门级网表和约束，具体操作使用DC软件完成。</p>
<ol>
<li>在工作空间target中建立目录树</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1623723655366-01ddd6d1-f064-4533-90c0-99c322c02efa.png#align=left&display=inline&height=175&id=sgWzy&margin=%5Bobject%20Object%5D&originHeight=175&originWidth=490&status=done&style=none&width=490"></p>
<ol start="2">
<li>创建.synopsys_dc.setup文件，此文件在启动DC初始化环境的时候自动调用，该文件配置库文件的搜索路径，指定target library和link library的工艺库文件。其中target library中包含了cell的库文件以生成网表，link library中包含了设计网表中的cell。</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1623723655797-f05c5a59-f8a7-46b8-aa8c-5da2264a349c.png#align=left&display=inline&height=313&id=Ndiml&margin=%5Bobject%20Object%5D&originHeight=508&originWidth=885&status=done&style=none&width=546"></p>
<ol start="3">
<li>启动DC</li>
</ol>
<ul>
<li>在work目录中启动dc_shell</li>
<li>使用source ../analyze_source_file.tcl读入需要综合的RTL代码文件</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1623723656506-62e2d47d-f3d4-4d13-ad1c-12e1a688b769.png#align=left&display=inline&height=344&id=sC4os&margin=%5Bobject%20Object%5D&originHeight=502&originWidth=885&status=done&style=none&width=606.991455078125"></p>
<ul>
<li>使用elaborate lcd1602声明顶层模块</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1623723656883-99fead1a-ec03-46b0-9446-77d8d04fd434.png#align=left&display=inline&height=619&id=amtPu&margin=%5Bobject%20Object%5D&originHeight=827&originWidth=817&status=done&style=none&width=611.9971313476562"></p>
<ul>
<li>使用link查看是否缺少子模块，返回值为1则说明文件完整</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1623723657457-5c1aa8c0-82bb-42dc-8ac6-47b7abc873fb.png#align=left&display=inline&height=174&id=HX9me&margin=%5Bobject%20Object%5D&originHeight=225&originWidth=813&status=done&style=none&width=626.9971313476562"></p>
<ol start="4">
<li>设计约束文件</li>
</ol>
<ul>
<li>在clock部分我们创建端口时钟和一个虚拟时钟，设置周期和占空比以及建立保持时间。</li>
<li>在con部分我们给所有的输入输出端口（除时钟外）设置输入输出延时。</li>
<li>在DRC部分我们给当前设计设置了最大转换时间和最大扇出，始终设置最大转换时间</li>
<li>在timing部分我们给输入输出端口设置建立保持时间约束。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1623723657927-0670724e-30c4-413e-9a19-dfaa3dc63da5.png#align=left&display=inline&height=366&id=xAHmE&margin=%5Bobject%20Object%5D&originHeight=509&originWidth=855&status=done&style=none&width=613.9971313476562"></p>
<ol start="5">
<li>编译并输出</li>
</ol>
<ul>
<li>使用compile命令对当前的设计进行逻辑综合</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1623723658462-aeaad3e2-f9e5-4dc6-a61f-1876d96a98f6.png#align=left&display=inline&height=630&id=Gpiwq&margin=%5Bobject%20Object%5D&originHeight=855&originWidth=808&status=done&style=none&width=594.9971313476562"></p>
<ul>
<li>编译完成后我们需要输出后面的时序约束文件和网表文件，使用change_names -hierarchy -rules verilog更改变量名使之符合Verilog语法规则。</li>
<li>使用write -format verilog -hierarchy -output ../output/lcd1602.v命令输出网表文件</li>
<li>使用write_sdc ../output/lcd1602.sdc输出时序约束文件</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1623723658723-a86996fb-0331-4295-b24f-98625b940103.png#align=left&display=inline&height=132&id=JD8IF&margin=%5Bobject%20Object%5D&originHeight=132&originWidth=815&status=done&style=none&width=815"></p>
<h2 id="布局布线"><a href="#布局布线" class="headerlink" title="布局布线"></a>布局布线</h2><p>布局布线将区域内的cell安置在相应的位置并用金属层进行连接，具体操作利用ICC完成。</p>
<ol>
<li>配置ICC环境并启动</li>
</ol>
<ul>
<li>首先我们在target工作目录中新建PR文件夹，在PR文件夹中同样需要.sysnopsy_dc.setup配置文件，内容和SYM中的一致。</li>
<li>使用icc_shell启动ICC。 </li>
<li>使用create_mw_lib XXX（设计库名称） -open -technology XXX（工艺库路径+名称） - mw_reference_library XXX（参考库路径+名称）命令创建milkway设计库</li>
<li>使用read_verilog ../SYM/output/lcd1602.v读入综合生成的网表文件。</li>
<li>使用link命令将网表中的的单元和参考库中的单元连接起来，然后使用check_design。</li>
<li>使用read_sdc ../SYM/output/lcd1602.sdc读入综合生成的约束文件。</li>
<li>使用check_timing检查约束文件是否导入。</li>
<li>使用set_tlu_plus_files -max_tluplus XXX（路径+max.tluplus） -min_tluplus XXX（路径+min.tluplus） -tech2itf_map XXX（路径+tluplus.map）命令导入寄生参数文件，然后使用check_tlu_plus_file检查tlu文件是否导入。</li>
</ul>
<ol start="2">
<li>打开图形界面并进行布局布线</li>
</ol>
<ul>
<li>使用start_gui命令打开ICC的图形界面，然后再工具栏点击creat floorplan创建平面图。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1623723659002-d41d9d67-c464-4e65-bbd7-0cf649b79ca3.png#align=left&display=inline&height=421&id=ONu93&margin=%5Bobject%20Object%5D&originHeight=421&originWidth=452&status=done&style=none&width=452"></p>
<ul>
<li>选择工具栏Preroute中Create Power Straps在进行引脚和网络的连接。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1623723659542-2ea85737-7e83-4395-9b78-922bab74a511.png#align=left&display=inline&height=559&id=L8Kmd&margin=%5Bobject%20Object%5D&originHeight=559&originWidth=479&status=done&style=none&width=479"></p>
<ul>
<li>选择工具栏Preroute中Create Power Straps在图形界面中画出六、五、四层金属电源线（VDD和VSS）。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1623723660194-dd728d9b-7e65-4b8e-9d4a-25f9b26ed846.png#align=left&display=inline&height=392&id=DPRbd&margin=%5Bobject%20Object%5D&originHeight=525&originWidth=666&status=done&style=none&width=496.99432373046875"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1623723660753-adc11f0d-65b1-4eac-8b9f-33a247dcca95.png#align=left&display=inline&height=305&id=wKI31&margin=%5Bobject%20Object%5D&originHeight=709&originWidth=1176&status=done&style=none&width=505.99713134765625"></p>
<ul>
<li>选择工具栏Preroute中Preoute standard cells中的fill empty rows，填充空行，并在DRC中布置M1-M4的power rail。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1623723661366-8dacecdc-39a4-41e8-8850-80c08c3bf6bd.png#align=left&display=inline&height=291&id=PKrDb&margin=%5Bobject%20Object%5D&originHeight=666&originWidth=1316&status=done&style=none&width=574.9971313476562"></p>
<ul>
<li>选择工具栏中Floorplan中的create placement blockage工具，遮住标准单元的第一行和最后一行，然后选择工具栏Finishing中的add tap cell array将标准单元N阱和衬底接电源和地，防止闩锁效应。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1623723661798-26619d78-30f8-4db9-bd90-54bbcc3eca0e.png#align=left&display=inline&height=589&id=jUiag&margin=%5Bobject%20Object%5D&originHeight=891&originWidth=790&status=done&style=none&width=521.9971313476562"></p>
<ul>
<li>在终端使用check_physical_design -stage pre_place_opt和check_physical_constraints命令检查设计和约束。</li>
<li>在终端里使用place_opt命令进行自动布局，使用report_qor评估布局质量。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1623723662311-aea2eed1-b69e-44fa-9d45-0b48501ac73c.png#align=left&display=inline&height=567&id=UpUQO&margin=%5Bobject%20Object%5D&originHeight=851&originWidth=812&status=done&style=none&width=540.9971313476562"></p>
<ul>
<li>使用set_propagated_clock [all_clocks]命令进行设置时钟，使用clock_opt命令进行时钟树综合。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1623723662843-3bc4ebfa-358a-4073-b343-677035e630a1.png#align=left&display=inline&height=579&id=QmJJM&margin=%5Bobject%20Object%5D&originHeight=853&originWidth=812&status=done&style=none&width=550.9971313476562"></p>
<ul>
<li>使用route_opt进行自动布线。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1623723664071-0aa8b881-d498-4828-9776-34cb21ea9bb0.png#align=left&display=inline&height=319&id=RW0Yp&margin=%5Bobject%20Object%5D&originHeight=1017&originWidth=1920&status=done&style=none&width=601.9971313476562"></p>
<ol start="3">
<li>时序检查、DRC检查和违例修正</li>
</ol>
<ul>
<li>使用reqort_qor查看时序报告，检查建立/保持时间的违例。使用verify_drc做DRC检查。</li>
<li>使用report_timing -transition_time检查建立/保持时间的违例。</li>
<li>使用size_cell u_apbif/U355 AND3_X2M_A7TULL命令修改对应建立时间违例。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1623723664476-518c0459-96b3-4826-967c-7bde583a83b0.png#align=left&display=inline&height=563&id=HqZaC&margin=%5Bobject%20Object%5D&originHeight=854&originWidth=820&status=done&style=none&width=540.991455078125"></p>
<ul>
<li>如果有保持时间违例，可以使用insert_buffer添加到路径中，直到时序正常。</li>
<li>使用legalize_placement -incremental和route_zrt_eco命令重新进行布局布线。</li>
<li>使用verify_zrt_route进行DRC检查。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1623723664901-79a2e710-eafd-474e-9ec5-59b6f1bf47ed.png#align=left&display=inline&height=478&id=Mr5Lv&margin=%5Bobject%20Object%5D&originHeight=857&originWidth=816&status=done&style=none&width=454.99713134765625"></p>
<ul>
<li>检查没有任何违例之后使用save_design命令保存设计并退出。</li>
</ul>
]]></content>
      <categories>
        <category>项目篇</category>
      </categories>
      <tags>
        <tag>数字</tag>
        <tag>Verilog</tag>
        <tag>SoC</tag>
      </tags>
  </entry>
  <entry>
    <title>GaN HEMT射频器件中设计参数的影响</title>
    <url>/2021/06/08/GaN%20HEMT%E5%B0%84%E9%A2%91%E5%99%A8%E4%BB%B6%E4%B8%AD%E8%AE%BE%E8%AE%A1%E5%8F%82%E6%95%B0%E7%9A%84%E5%BD%B1%E5%93%8D/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1623305603742-5a3d00a4-0bee-4bde-9ab9-e7d52724f6d0.png#align=left&display=inline&height=327&id=SLYMd&margin=%5Bobject%20Object%5D&originHeight=327&originWidth=530&status=done&style=none&width=530"><br>上图为一GaN射频器件的基本结构。假如其中的可调变量有：</p>
<ul>
<li>栅电极栅脚长度：Lg；</li>
<li>栅电极栅头长度：Lgh；</li>
<li>栅-源间距Lgs；</li>
<li>栅-漏间距Lgd；</li>
<li>钝化层介电常数εpas；</li>
<li>棚电极宽度W；</li>
<li>势垒层厚度tB；</li>
<li>势垒层AlGaN中Al组分xAl；</li>
<li>缓冲层背景掺杂浓度nbuf；</li>
<li>衬底热导率θsub；</li>
<li>衬底厚度tsub；</li>
</ul>
<p>论述改变上述参数大小时，对器件直流、小信号、高频噪声和大信号特性的影响，并简单说明影响的物理机制。</p>
<h2 id="公式："><a href="#公式：" class="headerlink" title="公式："></a>公式：</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1623305808168-a17ec09c-9add-46c5-8b96-d1c400a437f8.png#align=left&display=inline&height=798&margin=%5Bobject%20Object%5D&name=image.png&originHeight=798&originWidth=630&size=54959&status=done&style=none&width=630" alt="image.png"></p>
<h2 id="栅电极栅脚长度-Lg"><a href="#栅电极栅脚长度-Lg" class="headerlink" title="栅电极栅脚长度_Lg_"></a>栅电极栅脚长度_Lg_</h2><p>根据膝点电压公式可知栅脚长度_Lg_和沟道电阻_Rch_成正比，因此栅电极栅脚长度_Lg_越大，沟道电阻_Rch_越大，膝点电压_Vknee_越大。<br>根据漏电公式可知减小栅电极长度_Lg_可以有效地减小表面漏电_Ileak_，但同时也会造成短沟道效应。增大栅电极长度_Lg_可以增大击穿电压，不过同时也会降低器件跨导_gm_。这样同时也会降低匹配时的增益，对于输出功率来说，由于膝点电压增大，会导致输出功率减小。对于高频噪声来说，由于跨导的降低导致等效噪声电阻增大。<br>根据截止频率公式可知，截止频率_fT_和栅电极长度_Lg_成反比，减小栅电极长度，截止频率增大。 </p>
<h2 id="栅电极栅头长度-Lgh"><a href="#栅电极栅头长度-Lgh" class="headerlink" title="栅电极栅头长度_Lgh_"></a>栅电极栅头长度_Lgh_</h2><p>栅电极栅头长度_Lgh_越大，栅电极电阻_RG_越小，根据最大振荡频率公式，增大栅头长度_Lgh_，可以有效减小栅电阻_RG_，进而增大振荡频率_fmax_。</p>
<h2 id="栅-源间距-Lgs"><a href="#栅-源间距-Lgs" class="headerlink" title="栅-源间距_Lgs_"></a>栅-源间距_Lgs_</h2><p>根据膝点电压公式可知栅-源间距_Lgs_和栅-源导通电阻_Rs,ac_成正比，栅-源间距_Lgs_越小，栅-源间的导通电阻_Rs,ac_越小，膝点电压_Vknee_越小。<br>根据跨导公式可知，栅-源导通电阻_Rs_越大，器件跨导越小，减小栅-源间距_Lgs_可以有效地增大器件的跨导。同时根据截止频率公式可知，减小栅-源间距_Lgs_可以减小导通电阻_Rs_可以增大截止频率_fT_，但是减小栅源间距会造成栅源间的电容_Cgs_变大，又会减小截止频率_fT_，因此我们要取一个折衷。<br>栅-源间导通电阻_Rs_的减小又可以使得器件的热损耗减小，进而提高器件的效率。</p>
<h2 id="栅-漏间距-Lgd"><a href="#栅-漏间距-Lgd" class="headerlink" title="栅-漏间距_Lgd_"></a>栅-漏间距_Lgd_</h2><p>根据膝点电压公式可知栅-漏间距_Lgd_和栅-漏导通电阻_Rd,ac_成正比，栅-漏间距_Lgd_越小，栅-漏间的导通电阻_Rd,ac_越小，膝点电压_Vknee_越小。同时根据截止频率公式可知，减小栅-漏间距_Lgd_可以减小导通电阻_Rd_可以增大截止频率_fT_，但是减小栅漏间距会造成栅漏间的电容_Cgd_变大，又会减小截止频率_fT_，因此我们要取一个折衷。增加截止频率_fT _又可以减小等效噪声电阻。<br>但是栅-漏间距_Lgd_增大可以提高器件的击穿电压。<br>栅-漏间导通电阻_Rd_的减小又可以使得器件的热损耗减小，进而提高器件的效率。但是输出的阻抗比较小时，器件的增益会降低。</p>
<h2 id="钝化层介电常数-εpas"><a href="#钝化层介电常数-εpas" class="headerlink" title="钝化层介电常数_εpas_"></a>钝化层介电常数_εpas_</h2><p>根据跨导公式可知，跨导_gm_和器件的栅电容_Cg_成正比，栅电容_Cg_和钝化层介电常数_εpas_成正比，介电常数_εpas_越大，栅电容_Cg_越大跨导_gm_越高。跨导的增大又有利于提升器件的增益。</p>
<h2 id="栅电极宽度-Wg"><a href="#栅电极宽度-Wg" class="headerlink" title="栅电极宽度_Wg_"></a>栅电极宽度_Wg_</h2><p>根据饱和电流公式可知直流饱和电流_Ids_和栅电极宽度_Wg_近似正比关系，因此增大栅电极宽度_Wg_，饱和电流_Ids_也会线性增大。<br>根据膝点电压公式可知栅电极宽度_Wg_越大，导通电阻_Rs,ac_，_Rd,ac_，_Rch_均变小，膝点电压_Vknee_和导通电阻_Ron_成线性正相关关系，和栅电极宽度_Wg_成反比关系。<br>根据跨导公式可知，器件的跨导_gm_和栅电极宽度_Wg_成正比，栅电极宽度_Wg_越大，器件的跨导越大。导通电阻的减小同时也有利于器件效率的提高和增益的放大。<br>增大器件的栅宽_Wg_，器件膝点电压_Vknee_减小，输出功率_Pout_变大。</p>
<h2 id="势垒层厚度-tB"><a href="#势垒层厚度-tB" class="headerlink" title="势垒层厚度_tB_"></a>势垒层厚度_tB_</h2><p>增加势垒层的厚度_tB_会导致异质结结构中的二维电子气浓度_ns_升高，根据饱和电流公式可知当_ns_变大时，直流饱和电流_Ids_也将线性增大。同时沟道内的二维电子气浓度_ns_增大也会减小沟道内导通电阻，导致器件的膝点电压_Vknee_减小。导通电阻的减小同时也有利于器件效率的提高和增益的放大。<br>根据跨导公式可知，跨导_gm_和器件的栅电容_Cg_成正比，栅电容_Cg_和势垒层厚度_tB_成反比，势垒层越厚，栅电容_Cg_越小跨导_gm_越低。</p>
<h2 id="势垒层AlGaN中Al组分-xAl"><a href="#势垒层AlGaN中Al组分-xAl" class="headerlink" title="势垒层AlGaN中Al组分_xAl_"></a>势垒层AlGaN中Al组分_xAl_</h2><p>随着势垒层AlGaN中的Al组分的增大，AlGaN势垒层和GaN沟道层晶格失配增大，应力明显。势垒层的极化系数变大，禁带宽度_Eg_展宽，这样会导致异质结的导带势垒变高，二维电子气浓度_ns_变大，根据饱和电流公式可知当_ns_变大时，直流饱和电流_Ids_也将线性增大。<br>根据膝点电压公式可知沟道内的二维电子气浓度_ns_增大也会减小沟道内的导通电阻，高铝组分的势垒层也会降低方阻_Rsh_，减小导通电阻，进而降低器件的膝点电压_Vknee_。同时提高器件的输出功率和效率以及匹配时的增益。<br>在增大AlGaN中的Al组分根据漏电公式可知提高势垒层二维电子气浓度_ns_的同时，势垒层高度的增加对于减小栅极漏电_Ig_也有帮助。</p>
<h2 id="缓冲层背景掺杂浓度-nbuf"><a href="#缓冲层背景掺杂浓度-nbuf" class="headerlink" title="缓冲层背景掺杂浓度_nbuf_"></a>缓冲层背景掺杂浓度_nbuf_</h2><p>使用C或Fe补偿掺杂可以减小缓冲层的掺杂浓度，进而有效的减小缓冲层漏电_Ibuf_，提高器件的击穿电压。</p>
<h2 id="衬底热导率-θsub"><a href="#衬底热导率-θsub" class="headerlink" title="衬底热导率_θsub_"></a>衬底热导率_θsub_</h2><p>衬底的热导率越高，器件的散热越好，可靠性越高，器件温度下降会导致导通电阻的降低，进而降低膝点电压增大输出功率，散热性能良好又会降低载流子的散射概率，进而增大输运速度，提高饱和电流的大小，增大器件的跨导，降低高频等效电阻。</p>
<h2 id="衬底厚度-tsub"><a href="#衬底厚度-tsub" class="headerlink" title="衬底厚度_tsub_"></a>衬底厚度_tsub_</h2><p>衬底的热导率越薄（标准100 um），器件的散热越好，可靠性越高，器件温度下降会导致导通电阻的降低，进而降低膝点电压增大输出功率，散热性能良好又会降低载流子的散射概率，进而增大输运速度，提高饱和电流的大小，增大器件的跨导，降低高频等效电阻。</p>
]]></content>
      <categories>
        <category>笔记篇</category>
        <category>器件</category>
      </categories>
      <tags>
        <tag>器件</tag>
      </tags>
  </entry>
  <entry>
    <title>iphone快捷命令实现轻敲两下打开微信粤康码</title>
    <url>/2021/06/02/iphone%E5%BF%AB%E6%8D%B7%E5%91%BD%E4%BB%A4%E5%AE%9E%E7%8E%B0%E8%BD%BB%E6%95%B2%E4%B8%A4%E4%B8%8B%E6%89%93%E5%BC%80%E5%BE%AE%E4%BF%A1%E7%B2%A4%E5%BA%B7%E7%A0%81/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>苹果手机中的“快捷命令app”可以算是苹果公司官方放出的折腾的渠道，由此有许多的苹果玩家建立了相关论坛和社区，比如<a href="https://sharecuts.cn/shortcuts">捷径社区</a>，里面有不少大神创建的各种快捷指令。<br>鉴于最近广州疫情爆发，各个办公楼宿舍楼都要求出示健康码。每次在门口都得等很久，尤其是一手拿快递一手扫码出示的时候，于是我便找了网上的一些<a href="https://sharecuts.cn/shortcut/9872">大神的作品</a>，做了一些小小的改动。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在这里我就讲个大概的原理，某大神公布在gitee上了小程序的地址，里面包含的信息大概就是两个词典。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;miniapp&quot;: &#123;</span><br><span class="line">        &quot;name&quot;: [</span><br><span class="line">            &quot;穗康&quot;,</span><br><span class="line">            &quot;粤省事&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;穗康&quot;: &#123;</span><br><span class="line">            &quot;ID&quot;: &quot;gh_8052c0bb85ba&quot;,</span><br><span class="line">            &quot;URL&quot;: &quot;packages/health-code/pages/report-health/index.html&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;粤省事&quot;: &#123;</span><br><span class="line">            &quot;ID&quot;: &quot;gh_1ac06b5a8f4e&quot;,</span><br><span class="line">            &quot;URL&quot;: &quot;operation_plus/pages/yiqing/daka/user/index/index.html?cityCode=4406&amp;service_id=1&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取了词典的键值对之后，然后利用腾讯视频打开编码后的链接。</p>
<blockquote>
<p><strong>补充一下</strong>：由于微信的封闭性，他自己关闭了好多的URL导致微信不支持通过脚本或其他方式打开网址。大部分只能使用扫一扫或者通过手机浏览器打开。因此需要借助腾讯视频的接口打开URL</p>
</blockquote>
<h2 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h2><ul>
<li>首先在手机上下载<strong>腾讯视频</strong>app</li>
<li>然后获取捷径这里我给个<a href="https://www.icloud.com/shortcuts/d92ec35b67d349b7b7218e2aea9caa8c">链接</a>，可以直接在手机上打开：<a href="https://www.icloud.com/shortcuts/d92ec35b67d349b7b7218e2aea9caa8c">https://www.icloud.com/shortcuts/d92ec35b67d349b7b7218e2aea9caa8c</a></li>
<li>安装捷径</li>
<li>添加双击动作：<code>打开设置</code>-&gt;<code>辅助功能</code>-&gt;<code>触控</code>-&gt;<code>轻点背面</code>-&gt;<code>轻点两下</code>-&gt;选择刚才添加的<code>粤康码</code>捷径-&gt;<code>完成</code></li>
<li>当然你也可以直接呼叫“<code>嘿，Siri，粤康码</code>”来打开。</li>
</ul>
<h2 id="具体脚本"><a href="#具体脚本" class="headerlink" title="具体脚本"></a>具体脚本</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1622632080861-7dfd6297-553a-4d1e-a8e4-40499f1194f8.png#align=left&display=inline&height=532&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1792&originWidth=828&size=255834&status=done&style=none&width=246" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1622632098597-2f3d66ee-377f-43c5-be81-d38dcc90924c.png#align=left&display=inline&height=526&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1792&originWidth=828&size=300206&status=done&style=none&width=243" alt="image.png"><br>具体的操作过程有兴趣的可以自行研究一下。<br>最后希望疫情早点过去，大家都能平平安安的。</p>
]]></content>
      <categories>
        <category>折腾篇</category>
      </categories>
      <tags>
        <tag>IOS</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>SV系统验证（10）——TCL脚本和回归测试</title>
    <url>/2021/05/26/SV%E7%B3%BB%E7%BB%9F%E9%AA%8C%E8%AF%81%EF%BC%8810%EF%BC%89%E2%80%94%E2%80%94TCL%E8%84%9A%E6%9C%AC%E5%92%8C%E5%9B%9E%E5%BD%92%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h2 id="TCL基础入门"><a href="#TCL基础入门" class="headerlink" title="TCL基础入门"></a>TCL基础入门</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><ul>
<li>TCL（Tool Command Language）是一种解释执行的脚本语言（Scripting Language）。它提供了通用的编程能力：支持变量、过程和控制结构；同时TCL还拥有一个功能强大的固有的核心命令集。</li>
<li>由于TCL的解释器是用一个C\C++语言的过程库实现的，因此在某种意义上我们又可以把TCL看作一个C库，这个库中有丰富的用于扩展TCL命令的C\C++过程和函数，每个应用程序都可以根据自己的需要对TCL语言进行扩展。</li>
<li>扩展后的TCL语言将可以继承TCL核心部分的所有功能，包括核心命令、控制结构、数据类型、对过程的支持等；TCL良好的可扩展性使得它能很好地适应产品测试的需要，目前已成为自动测试中事实上的标准。</li>
</ul>
<h3 id="脚本学习核心"><a href="#脚本学习核心" class="headerlink" title="脚本学习核心"></a>脚本学习核心</h3><ul>
<li>TCL脚本执行依赖于解释器（逐行执行）。</li>
<li>TCL有效命令行以命令+字符串（结合空格间隔符）形成。</li>
<li>明白置换（$、[]、\）和引用（””，{}）的差别和联系。</li>
<li>理解命令eval、expr、source、exec的差别。</li>
<li>掌握{*}配合glob等返回list后的操作</li>
</ul>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><ul>
<li><p>一个TCL脚本可以包含一个或多个命令。命令之间必须用换行符或分号隔开，下面的两个脚本都是合法的：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">set a <span class="number">1</span></span><br><span class="line">set b <span class="number">2</span></span><br><span class="line">或set a <span class="number">1</span>; set b <span class="number">2</span></span><br></pre></td></tr></table></figure></li>
<li><p>TCL的每一个命令包含一个或几个单词，第一个单词代表命令名，另外的单词则是这个命令的参数，单词之间必须用空格或TAB键隔开。</p>
</li>
</ul>
<h3 id="置换"><a href="#置换" class="headerlink" title="置换"></a>置换</h3><ul>
<li><p>TCL解释器在分析命令时，把所有的命令参数都当作<strong>字符串</strong>看待，例如</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">%set x <span class="number">10</span>        <span class="comment">//定义变量x，并把x的值赋为10 </span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">%set y x+<span class="number">100</span>  <span class="comment">//y的值是x+100，而不是我们期望的110</span></span><br><span class="line">x+<span class="number">100</span></span><br></pre></td></tr></table></figure></li>
<li><p>上例的第二个命令中，x被看作字符串x+100的一部分，如果我们想用x的值’10’，就必须告诉TCL解释器：我们在这里期望的是变量x的值，而非字符x’。怎么告诉TCL解释器呢，这就要用到TCL语言中提供的置换功能。</p>
</li>
<li><p>TCL提供三种形式的置换：<strong>变量置换</strong>、<strong>命令置换</strong>和<strong>反斜杠置换</strong>。</p>
</li>
</ul>
<h3 id="变量置换"><a href="#变量置换" class="headerlink" title="变量置换"></a>变量置换</h3><ul>
<li><p>变量置换由一个$符号标记，变量置换会导致变量的值插入一个单词中。例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">%set y $x+<span class="number">100</span></span><br><span class="line"><span class="comment">// y的值是10+100，这里x被置换成它的值10+100</span></span><br></pre></td></tr></table></figure></li>
<li><p>这时，y的值还不是我们想要的值110，而是10+100，因TCL解释器把10+100看成是一个字符串而不是表达式，y要得到值110，还必须用命令置换，使得TCL会把10+100看成个表达式并求值。</p>
</li>
</ul>
<h3 id="命令置换"><a href="#命令置换" class="headerlink" title="命令置换"></a>命令置换</h3><ul>
<li><p>命令置换是由[]括起来的TCL命令及其参数，命令置换会导致某一个命令的所有或部分单词被另一个命令的结果所代替。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">%set y [expr $x+<span class="number">100</span>]</span><br><span class="line"><span class="number">110</span></span><br></pre></td></tr></table></figure></li>
<li><p>y的值是110，这里当TCL解释器遇到字符’[‘时，它就会把随后的expr作为一个命令名，从而激活与expr对应的C/C++过程，并把’expr’和变量置换后得到的’10+110’传递给该命令过程进行处理。</p>
</li>
<li><p>如果在上例中我们去掉’[]’，那么TCL会报错。因为在正常情况下，TCL解释器<strong>只把命令行中的第一个单词作为看作命令</strong>，其他的单司都作为普通字符串处理，看作是命令的参数。</p>
</li>
</ul>
<h3 id="反斜杠置换"><a href="#反斜杠置换" class="headerlink" title="反斜杠置换"></a>反斜杠置换</h3><ul>
<li><p>TCL语言中的反斜杠置换类似于C语言中反斜杠的用法，主要用于在单词符号中插入诸如换行符、空格、[、$等被TCL解释器当作特殊符号对待的字符。例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">%set msg multiple\ space           <span class="comment">//msg的值为multiple space.</span></span><br><span class="line">multiple space</span><br></pre></td></tr></table></figure></li>
<li><p>如果没有\的话，TCL会报错，因为解释器会把这里最后两个单词之间的空格认为是分隔符，于是发现set命令有多于两个参数，从而报错。加入了”后，空格不被当作分隔符，’multiple space’被认为是一个单词（word）</p>
</li>
</ul>
<h3 id="双引号和花括号"><a href="#双引号和花括号" class="headerlink" title="双引号和花括号"></a>双引号和花括号</h3><ul>
<li><p>除了使用反斜杠外，TCL提供另外两种方法来使得<strong>解释器把分隔符和置换符等特殊字符当作普通字符，而不作特殊处理</strong>，这就要使用双引号和花括号（}）。</p>
</li>
<li><p>TCL解释器对双引号中的<strong>各种分隔符将不作处理，但是对换行符及$和[]两种置换符会照常处理</strong>。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">%set y <span class="string">&quot;$x ddd&quot;</span></span><br><span class="line"><span class="number">100</span> ddd </span><br></pre></td></tr></table></figure></li>
<li><p>**TCL中的注释符是”#”**，”#”和直到所在行结尾的所有字符都被TCL看作注释，TCL解释器对注释将不作任何处理。</p>
</li>
</ul>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul>
<li><p>一个TCL的简单变量包含两个部分：<strong>名字和值（都可以是任意字符）</strong>。</p>
</li>
<li><p>TCL解释器在分析一个变量置换时，只<strong>把从$符号往后直到第一个不是字母、数字或下划线的字符之间的单词符号</strong>作为要被置换的变量的名字。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">%set a <span class="number">2</span>     <span class="comment">//2</span></span><br><span class="line">%set a<span class="variable">.1</span> <span class="number">4</span>   <span class="comment">//4</span></span><br><span class="line">%set b $a<span class="variable">.1</span>  <span class="comment">//2.1</span></span><br><span class="line">%set b $&#123;a<span class="variable">.1</span>&#125; <span class="comment">//4</span></span><br><span class="line">%set a &#123;kdfj kjdf&#125;  <span class="comment">//kdfj kjdf</span></span><br><span class="line">%set a              <span class="comment">//kdfj kjdf 读取变量</span></span><br></pre></td></tr></table></figure></li>
<li><p>在最后一个命令行，我们希望把变量a.1的值付给b，但是TCL解释器在分析时只把符号之后直到第一个不是字母、数字或下划线的字符（这里是.）之间的单词符号（这里是’a）当作要被置换的变量的名字，所以TCL解释器把a置换成2，然后把字符串“2.1”付给变量b。这显然与我们的初衷不同。</p>
</li>
<li><p>如果变量名中有<strong>不是字母、数字或下划线的字符</strong>，又要用置换，可以用<strong>花括号把变量名括起来</strong>。</p>
</li>
<li><p>TCL中的set命令<strong>能生成一个变量、也能读取或改变一个变量的。</strong></p>
</li>
</ul>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul>
<li>数组是一些元素的集合。TCL的数组和普通计算机语言中的数组有很大的区别。在TCL中，<strong>不能单独声明一个数组，数组只能和数组元素一起声明</strong>。数组中，数组元素的名字包含两部分：<strong>数组名和数组中元素的名字</strong>，TCL中数组元素的名字（下<strong>标）可以为任何字符串</strong>。<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">%set day(monday) <span class="number">1</span>     <span class="comment">//第一个命令生成一个名为day的数组，同时在数组中生成一个名为monday的数组元素，并把值置为1</span></span><br><span class="line">%set day(tuesday) <span class="number">2</span>    <span class="comment">//第二个命令生成一个名为tuesday的数组元素，并把值置为2</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><ul>
<li><p>unset这个命令从解释器中删除变量，它后面可以有任意多个参数，每个参数是一个变量名，可以是简单变量，也可以是数组或数组元素。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">%unset a b day(monday)</span><br></pre></td></tr></table></figure></li>
<li><p>append命令把文本加到一个变量的后面</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">%set txt hello                   <span class="comment">//Hello</span></span><br><span class="line">%append txt <span class="string">&quot;！How are you&quot;</span>      <span class="comment">//hello！How are you</span></span><br></pre></td></tr></table></figure></li>
<li><p> incr命令把一个变量值加上一个整数。incr要求变量原来的值和新加的值都必须是整数。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">%set b <span class="number">2</span> </span><br><span class="line">incr b <span class="number">3</span>     <span class="comment">//结果为5</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><ul>
<li><p>TCL支持常用的数学函数，表达式中数学函数的写法类似于C\C++语言的写法，数学函数的参数可以是任意表达式，<strong>多个参数之间用逗号隔开</strong>。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">%set x <span class="number">2</span>    <span class="comment">//2</span></span><br><span class="line">%expr <span class="number">2</span>*sin($x&lt;<span class="number">3</span>)   <span class="comment">//1.68294196962</span></span><br></pre></td></tr></table></figure></li>
<li><p>其中<strong>expr是TCL的一个命令</strong>，语法为：expr arg  ？arg…？，两个？之间的参数表示可省，后面介绍命令时对于可省参数都使用这种表示形式。</p>
</li>
<li><p>需要注意的一点是，数学函数并不是命令，只在表达式中出现才有意义，即<strong>出现在expr之后才有意义。</strong></p>
</li>
</ul>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ul>
<li>TCL中list是由一堆元素组成的有序集合，list可以嵌套定义，<strong>list每个元素可以是任意字符串，也可以是list。</strong><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">&#123;&#125;  <span class="comment">//空list</span></span><br><span class="line">&#123;a b c d&#125;</span><br><span class="line">&#123;a &#123;b c&#125; d&#125;<span class="comment">//list可以嵌套</span></span><br><span class="line"></span><br><span class="line">语法：list ？value value...？  <span class="comment">//这个命令生成1个list，list的元素就是所有的value</span></span><br><span class="line">%list <span class="number">1</span> <span class="number">2</span> &#123;<span class="number">3</span> <span class="number">4</span>&#125;</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> &#123;<span class="number">3</span> <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line">语法：concat list ？list..？  <span class="comment">//整合两个list</span></span><br><span class="line">%concat &#123;<span class="number">123</span>&#125; &#123;<span class="number">456</span>&#125;</span><br><span class="line">&#123;<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>&#125;</span><br><span class="line"></span><br><span class="line">语法：lindex list index       <span class="comment">//返回list的第index个元素</span></span><br><span class="line">%lindex &#123;<span class="number">12</span>&#123;<span class="number">3</span> <span class="number">4</span>&#125;&#125; <span class="number">2</span> </span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line">语法：llength list            <span class="comment">//返回list的元素个数</span></span><br><span class="line">%llength &#123;<span class="number">1</span> <span class="number">2</span> &#123;<span class="number">3</span> <span class="number">4</span>&#125;&#125;</span><br><span class="line"><span class="number">3</span></span><br><span class="line">语法：linsert list index value ？value...？    <span class="comment">//list插入元素</span></span><br><span class="line">%linsert &#123;<span class="number">1</span> <span class="number">2</span> <span class="number">5</span> <span class="number">6</span>&#125; <span class="number">1</span> <span class="number">7</span> <span class="number">8</span></span><br><span class="line"><span class="number">1</span> <span class="number">7</span> <span class="number">8</span> <span class="number">2</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">语法：lappend varname value ？value...？       <span class="comment">//把每个value的值作为一个元素附加到变量varname后面</span></span><br><span class="line">%lappend a <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="控制命令"><a href="#控制命令" class="headerlink" title="控制命令"></a>控制命令</h2><h3 id="控制流：-if命令"><a href="#控制流：-if命令" class="headerlink" title="控制流： if命令"></a>控制流： if命令</h3><ul>
<li>语法：if test1 body1  ？else bodyn？</li>
<li>TCL先把test1当作一个表达式求值，如果值非0，则把body1当作一个脚本执行并返回所得值，否则把test2当作一个表达式求值，如果值非0，则把body2当作一个脚本执行并返回所得值。<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> &#123;$x&gt;<span class="number">0</span>&#125;&#123;                  <span class="comment">//注意&#123;一定要写在上一行，因为不这样，TCL解释器会认为if命令在换行符已经结束了；</span></span><br><span class="line">.....&#125;elseif &#123;$x==<span class="number">1</span>&#125;&#123;       <span class="comment">//同时if和&#123;之间应该有一个空格，否则TCL解释器会会把&#x27;if&#123;&#x27;作为一个整体命令导致出错</span></span><br><span class="line">.....&#125;elseif &#123;$x==<span class="number">2</span>&#125;&#123;</span><br><span class="line">.....&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">.....&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="循环：while命令"><a href="#循环：while命令" class="headerlink" title="循环：while命令"></a>循环：while命令</h3><ul>
<li>语法：while test body</li>
<li>参数test是一个表达式，body是一个脚本，如果表达式的值非0，就运行脚本，直到表达式为0才停止循环，此时while命令中断并返回一个空字符串。此处是一个脚本：<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">set b <span class="string">&quot;&quot;</span></span><br><span class="line">set i [expr [llength $a]-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">while</span> &#123;$i&gt;=<span class="number">0</span>&#125;&#123;</span><br><span class="line">  lappend b [lindex $a $i]</span><br><span class="line">  incr i-<span class="number">1</span> &#125;               <span class="comment">//变量a是一个链表，脚本把a的值复制到b</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="循环：for命令"><a href="#循环：for命令" class="headerlink" title="循环：for命令"></a>循环：for命令</h3><ul>
<li>语法：for init test reinit body</li>
<li>参数init是一个初始化脚本，第二个参数test是一个表达式，用来决定循环什么时候中断，第三个参数reinit是一个重新初始化的脚本，第四个参数body也是脚本，代表循环体；<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假设变量a是一个链表，下面的脚本把a的值复制到b：</span></span><br><span class="line">set b <span class="string">&quot;&quot;</span> </span><br><span class="line"><span class="keyword">for</span>&#123;set i [expr [llength $a]-<span class="number">1</span>]&#125;&#123;$i&gt;=<span class="number">0</span>&#125;&#123;incr i-<span class="number">1</span>&#125;&#123;</span><br><span class="line">  lappend b[lindex $a $i]&#125;</span><br><span class="line"><span class="comment">//作用和上面的例子是相同的</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="循环：foreach命令"><a href="#循环：foreach命令" class="headerlink" title="循环：foreach命令"></a>循环：foreach命令</h3><p>语法：foreach varName list body<br>第一个参数varName是一个变量，第二个参数list是一个表（有序集合），第三个参数body是循环体。每次取得链表的一个元素，都会执行循环体一次。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">set b <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">foreach</span> i $a&#123;</span><br><span class="line">  set b [linsert $b <span class="number">0</span> $i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//变量a是一个链表，脚本把a的值复制到b,顺序刚好相反</span></span><br></pre></td></tr></table></figure>


<h3 id="控制：switch命令"><a href="#控制：switch命令" class="headerlink" title="控制：switch命令"></a>控制：switch命令</h3><ul>
<li>语法：switch ？options？ string { pattern body ？pattern body…？}</li>
<li>第一个是可选参数options，表示进行匹配的方式。TCL支持三种匹配方式：**-exact方式，-glob方式，-regexp方式**，缺省情况表示-glob方式。-exact方式表示的是精确匹配，-glob方式的匹配方式和string match命令的匹配方式相同，-regexp方式是正规表达式的匹配方式。第二个参数string是要被用来作测试的值，第三个参数是括起来的一个或多个元素对<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">%switch $x&#123;         <span class="comment">//一旦switch命令找到一个模式匹配</span></span><br><span class="line">  b&#123;incr t1&#125;        <span class="comment">//就执行相应的脚本，并返回脚本的</span></span><br><span class="line">  c&#123;incr t2&#125;&#125;       <span class="comment">//值，作为switch命令的返回值。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="跳出循环"><a href="#跳出循环" class="headerlink" title="跳出循环"></a>跳出循环</h3><ul>
<li>在循环体中，可以用break和continue命令中断循环。其中break命令结束整个循环过程，并从循环中跳出，continue只是结束本次循环。</li>
<li>source命令读一个文件并把这个文件的内容作为一个脚本进行求值``</li>
<li><code>%source e:/tcl&amp;c/hello.tcl </code></li>
<li>eval命令是一个用来构造和执行TCL脚本的命令，其语法为：<code>eval arg ？arg...？</code><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">%eval set a <span class="number">2</span>;</span><br><span class="line">set b <span class="number">4</span> <span class="number">4</span>   <span class="comment">//它可以接收一个或多个参数，然后把所有的参数以空格隔开组合到一起成为一个脚本，然后对这个脚本进行求值。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ul>
<li><p>TCL支持过程的定义和调用，在TCL中，过程可以看作是用TCL脚本实现的命令，效果与TCL的固有命令相似。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">%proc add &#123;x y&#125; &#123;expr $x+$y&#125;   <span class="comment">//TCL中过程是由proc命令产生的：</span></span><br><span class="line">%add <span class="number">1</span> <span class="number">2</span>           <span class="number">3</span>           <span class="comment">//proc生成一个新的命令，可以象固有命令一样调用</span></span><br></pre></td></tr></table></figure></li>
<li><p>TCL中过程是由proc命令产生的：proc命令的第一个参数是你要定义的过程的名字，第二个参数是过程的参数列表，参数之间用空格隔开，第三个参数是一个TCL脚本，代表过程体。</p>
</li>
<li><p>在定义过程时，你可以利用return命令在任何地方返回你想要的值。return命令迅速中断过程，并把它的参数作为过程的结果</p>
</li>
</ul>
<h3 id="局部变量和全局变量"><a href="#局部变量和全局变量" class="headerlink" title="局部变量和全局变量"></a>局部变量和全局变量</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">%set a <span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">%proc sample&#123;x&#125;&#123;</span><br><span class="line">  <span class="keyword">global</span> a       <span class="comment">//全局变量声明</span></span><br><span class="line">  incr a         <span class="comment">//a+1 默认＋1</span></span><br><span class="line">  <span class="keyword">return</span>[expr $a+$x&#125;</span><br><span class="line">%sample <span class="number">3</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line">%set a</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><ul>
<li><p>因为TCL把所有的输入都当作字符串看待，所以TCL提供了较强的字符串操作功能。</p>
</li>
<li><p>语法：<strong>format</strong> formatstring  ？vlue value…？</p>
</li>
<li><p>format命令类似于ANSIC中的sprintf函数，按formatstring提供的格式，把各个value的值组合到formatstring中形成一个新字符串返回。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">%set name john            <span class="comment">//John</span></span><br><span class="line">%set age <span class="number">20</span>               <span class="comment">//20</span></span><br><span class="line">%set msg[format <span class="string">&quot;%s is %d years old&quot;</span> $name $age]     <span class="comment">//john is 20 years old</span></span><br></pre></td></tr></table></figure></li>
<li><p>语法：<strong>scan</strong> string format varName  ？varName…？</p>
</li>
<li><p>scan命令可以认为<strong>是format命令的逆</strong>，其功能类似于ANSIC中的sscanf函数。它按format提供的格式分析string字符串，然后把结果存到变量varName中，<strong>注意除了空格和TAB键之外，string和format中的字符和’%’必须匹配</strong>。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">%scan<span class="string">&quot;some 26 34&quot;</span><span class="string">&quot;some %d %d&quot;</span> a b     <span class="comment">//2</span></span><br><span class="line">%set a                                <span class="comment">//26</span></span><br><span class="line">%set b                                <span class="comment">//34 </span></span><br></pre></td></tr></table></figure></li>
<li><p>语法：regexp  ？switchs？ ？–？ Exp string  ?matchVar？\  ?subMatchVar subMatchVar…？</p>
</li>
<li><p>regexp命令用于判断正规表达式exp是否全部或部分匹配字符串string，匹配返回1，否则0</p>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1622083013238-b947aa23-b4c7-4ef1-81cd-81ce72c43ea5.png#align=left&display=inline&height=190&margin=%5Bobject%20Object%5D&name=image.png&originHeight=243&originWidth=558&size=55038&status=done&style=none&width=437" alt="image.png"></p>
<h3 id="文件访问"><a href="#文件访问" class="headerlink" title="文件访问"></a>文件访问</h3><ul>
<li><p>TCL提供了丰富的文件操作的命令。通过这些命令你可以对文件名进行操作（查找匹配某一模式的文件）、以顺序或随机方式读写文件、检索系统保留的文件信息（如最后访问时间）</p>
</li>
<li><p>TCL中文件名和我们熟悉的windows表示文件的方法有一些区别：<code>在表示文件的目录结构时它使用&#39;/&#39;，而不是&#39;\&#39;</code>。</p>
</li>
<li><p>语法：open name  ?access？</p>
</li>
<li><p>open命令以access方式打开文件name，返回供其他命令（gets，close等）使用的文件标识。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">文件的打开方式和我们熟悉的C语言类似，有以下方式：</span><br><span class="line">r  只读方式打开。文件必须已经存在。这是默认方式。</span><br><span class="line">r+ 读写方式打开，文件必须已经存在。</span><br><span class="line">w  只写方式打开文件，如果文件存在则清空文件内容，否则创建一新的空文件。</span><br><span class="line">w+ 读写方式打开文件，如文件存在则清空文件内容，否则创建新的空文件。</span><br><span class="line">a  只写方式打开文件，文件必须存在，并把指针指向文件尾。</span><br><span class="line">a+ 读写方式打开文件，并把指针指向文件尾。如文件不存在，创建新的空文件</span><br></pre></td></tr></table></figure></li>
<li><p>open命令返回一个字符串用于表识打开的文件。当调用别的命令（如：gets，puts，close）]对打开的文件进行操作时，就可以使用这个文件标识符。TCL有三个特定的文件标识：<strong>stdin，stdout和stderr</strong>，分别对应标准输入、标准输出和错误通道，任何时候你都可以使用这三个文件标识。</p>
</li>
<li><p>gets fileld  ?varName?读fileld标识的文件的下一行，忽略换行符。如果命令中有varName就把该行赋给它，并返回该行的字符数（文件尾返回-1），如果没有varName参数，返回文件的下一行作为命令结果（如果到了文件尾，就返回空字符串）</p>
</li>
<li><p>put  ?-nonewline？?fileld？string puts命令把string写到fileld中，如果没有nonewline开关的话，添加换行符。fileld默认是stdout，命令返回值为一空字符串。</p>
</li>
<li><p>flush fileld把缓冲区内容写到fileld标识的文件中，命令返回值为空字符串。</p>
</li>
<li><p>flush命令迫使缓冲区数据写到文件中。flush直到数据被写完才返回。当文件关闭时缓冲区数据会首动flush.</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">proc tgrep &#123;pattern filename&#125;&#123;     </span><br><span class="line">  set f [open $filename r]               </span><br><span class="line">  <span class="keyword">while</span> &#123;[gets $f line]&#125;&#123; </span><br><span class="line">    <span class="keyword">if</span> &#123;regexp $pattern $line]&#125;&#123; </span><br><span class="line">        puts stdout $line  </span><br><span class="line">    &#125; </span><br><span class="line">close $f </span><br><span class="line">&#125;<span class="comment">//TCL文件I/O的基本特点示例</span></span><br></pre></td></tr></table></figure></li>
<li><p>TCL提供两个命令来管理当前工作目录：pwd和cd.</p>
<blockquote>
<p>pwd和UNIX下的pwd命令完全一样，没有参数，返回当前目录的完整路径。<br>cd命令也和UNIX命令也一样，使用一个参数，可以把工作目录改变为参数提供的目录。如果cd没使用参数，UNIX下，会把工作目录变为启动TCL脚本的用户的工作目录。</p>
</blockquote>
</li>
<li><p>TCL提供了两个命令进行文件名操作：glob和file，用来操作文件或获取文件信息。</p>
<blockquote>
<p>glob命令采用一种或多种模式作为参数，并返回匹配这个（些）模式的所有文件的列表</p>
</blockquote>
</li>
<li><p>语法为：glob  ?switches？  pattern  ?pattern…？</p>
</li>
<li><p>glob命令的模式采用string match命令的匹配规则。例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">%glob *<span class="variable">.c</span> *<span class="variable">.h</span> </span><br><span class="line">main<span class="variable">.c</span> hash<span class="variable">.c</span> hash<span class="variable">.h</span> </span><br><span class="line">file delete *<span class="variable">.tmp</span>             <span class="comment">//不生效不执行通配符展开</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//先使用glob命令返回文件列表，在使用参数展开语法&#123;*&#125;把列表元素作为独立参数提供给指令。</span></span><br><span class="line">file delete &#123;*&#125;[glob*<span class="variable">.tmp</span>]    <span class="comment">//必须加&#123;&#125;，否则不同元组之间的空格会将所有元素合为一个</span></span><br><span class="line"><span class="comment">//也可以选择使用eval </span></span><br><span class="line">eval file delete [glob*<span class="variable">.tmp</span>]</span><br></pre></td></tr></table></figure></li>
<li><p>file是有许多选项的常用命令，可以用来进行文件操作也可以检索文件信息</p>
<blockquote>
<p>file atime name返回一个十进制的字符串，表示文件name最后被访问的时间。时间是以秒为单位从1970年1月1日12：00AM开始计算。如果文件name不存在或查询不到访问时间就返回错误。例：<code>%file atime license.txt         975945600</code></p>
</blockquote>
</li>
<li><p>语法：file copy  ?-force？  ?–？source target</p>
<blockquote>
<p>这个命令把source中指明的文件或目录递归的拷贝到目的地址targetDir，只有当存在-force选项时，已经存在的文件才会被覆盖。试图覆盖一个非空的目录或以一个文件覆盖一个目录或以一个目录覆盖一个文件都会导致错误。</p>
</blockquote>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">file mkdir dir  ？dir..？        <span class="comment">//创建dir中指明的目录</span></span><br><span class="line">file owned name                  <span class="comment">//如果name被当前用户拥有，返回1，否则返回0</span></span><br><span class="line">file executable name             <span class="comment">//如果name对当前用户是可以执行的，就返回1，否则返回0。</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>笔记篇</category>
        <category>数字验证</category>
      </categories>
      <tags>
        <tag>SystemVerilog</tag>
      </tags>
  </entry>
  <entry>
    <title>SV系统验证（9）——验证量化和覆盖率</title>
    <url>/2021/05/19/SV%E7%B3%BB%E7%BB%9F%E9%AA%8C%E8%AF%81%EF%BC%889%EF%BC%89%E2%80%94%E2%80%94%E9%AA%8C%E8%AF%81%E9%87%8F%E5%8C%96%E5%92%8C%E8%A6%86%E7%9B%96%E7%8E%87/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>“验证如果没有量化，那么就意味着没有尽头。”<br>伴随着复杂SoC系统的验证难度系数成倍增加，无论是定向测试还是随机测试，我们在验证的过程中终究需要回答两个问题：</p>
<ul>
<li>是否所有设计的功能在验证计划中都已经验证？</li>
<li>代码中的某些部分是否从未执行过？</li>
</ul>
</blockquote>
<p><strong>覆盖率</strong>就是用来帮助我们在仿真中回答以上问题的指标，已经被广泛采用，作为衡量验证过程中的重要数据<br>一旦通过覆盖率来量化验证，我们可以在更复杂的情况下捕捉一些功能特性是否被覆盖：</p>
<ul>
<li>当我们在测试X特性的时候，Y特性是否也在同一时刻被使能和测试？</li>
<li>是否可以精简我们已有的测试来加速仿真，并且取得同样的覆盖率？</li>
<li>覆盖率在达到一定的数值的时候，是否停滞，不再继续上升？</li>
</ul>
<p>简单而言，覆盖率就是用来衡量验证<strong>精度</strong>和<strong>完备性</strong>的数据指标，可以告诉我们在仿真时设计的哪些结构被触发，当然，它也可以告诉我们设计在仿真时的哪些结构从未被触发过<br>只有满足以下三个条件，才可以在仿真中实现高质量的验证：</p>
<ul>
<li>测试平台必须产生合适的激励来触发一个设计错误</li>
<li>测试平台仍然需要产生合适的激励使得被触发的错误可以进一步传导到输出端口</li>
<li>测试平台需要包含一个监测器（monitor）用来监测被激活的设计错误，以及在它传播的某个节点（内部或者外部）可以捕捉到它</li>
</ul>
<h2 id="覆盖率种类"><a href="#覆盖率种类" class="headerlink" title="覆盖率种类"></a>覆盖率种类</h2><p><strong>没有任何一种单一的覆盖率</strong>可以完备地去衡量验证过程即使我们可以达到100%的代码覆盖率，但这并不意味着100%<br>的功能覆盖率。原因在于代码覆盖率并<strong>不是</strong>用来衡量设计内部的功能运转，或者模块之间的互动，或者功能时序的触发等。<br>类似地，我们即便达到了100%功能覆盖率，也可能只达到了90%的代码覆盖率。原因可能在于我们疏漏了去测试某些功能，或者一些实现的功能并没有被描述。<br>从上述关于代码覆盖率和功能覆盖率简单的论述就可以证明，如果想要得到全面的验证精度，我们就需要多个覆盖率种类的指标<br><strong>最常见的划分覆盖率的两种方法</strong></p>
<ul>
<li>按照覆盖率生成的方法，即隐性生成还是显性生成。</li>
<li>按照覆盖率溯源，即它们从功能描述而来还是从设计实现而来。<blockquote>
<p>例如功能覆盖率是显性的需要人为定义的覆盖率，而代码覆盖率则是隐性覆盖率这是因为仿真工具可以自动从RTL代码来生成。</p>
</blockquote>
</li>
</ul>
<h2 id="代码覆盖率"><a href="#代码覆盖率" class="headerlink" title="代码覆盖率"></a>代码覆盖率</h2><p>代码覆盖率的一个优势在于它可以由仿真工具<strong>自动收集</strong>，继而用来指出在测试程序中设计源代码哪些被激活触发，而哪些则一直处于非激活的状态。由于代码覆盖率自动的特性，在仿真过程中使能它变得很简单，它不需要修改设计或者验证环境。</p>
<h3 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h3><ul>
<li><strong>代码覆盖率100%并不意味着足够的功能覆盖率</strong></li>
<li>研究发现，在回归测试实现了90%的代码覆盖率时，平均只有54%的代码会被监测，这意味着即便代码覆盖率的完备性满足，但依然可能在这些代码中存在漏洞</li>
<li>上述的推断是因为不是所有被覆盖的代码都会得到足够的监测，也由于没有得到足够的监测，因此一些即便被触发的漏洞也在传播的过程中没有到达监测点上——漏洞便从眼皮底下“逃逸”了</li>
<li>另外，代码覆盖率的数据无法直接映射到哪些设计功能被测试了所以从这一点来看，代码覆盖率和功能覆盖率之间又是相互独立的。</li>
</ul>
<h3 id="跳转覆盖率（toggle）"><a href="#跳转覆盖率（toggle）" class="headerlink" title="跳转覆盖率（toggle）"></a>跳转覆盖率（toggle）</h3><ul>
<li>用来衡量寄存器跳转的次数（0-&gt;1，1-&gt;0）</li>
<li>一般项目会要求模块的端口实现至少1次0到1，以及1次1到0的跳转来<strong>保证模块的集成和模块之间的互动</strong>，也有的项目会要求所有的寄存器都应该同端口一样<strong>满足跳转的最少次数</strong></li>
<li>端口跳转覆盖率<strong>经常用来测试IP模块之间的基本连接性</strong>，例如检查一些输入端口是否没有连接，或者已经连接的两个端口的比特位数是否不匹配，又或者一些已经连接的输入是否被给定的固定值等，都可以通过跳转覆盖率来发现问题</li>
</ul>
<h3 id="行覆盖率（statement-line）"><a href="#行覆盖率（statement-line）" class="headerlink" title="行覆盖率（statement/line）"></a>行覆盖率（statement/line）</h3><ul>
<li>用来<strong>衡量源代码哪些代码行被执行过</strong>，以此来指出哪些代码行没有被执行过</li>
<li>从每一行执行的次数，如果设置最小的执行次数，也可以用来做充足代码测试的一项指标</li>
<li>代码覆盖率可以指出在一些缺乏输入激励的情况下，<strong>某些赋值的代码行没有被执行的情况</strong>，它也可以指出在一些漏洞影响或者无用代码的影响下，一些代码行也无法被执行的情况对于那些无用的代码，也就是永远不会被执行的代码，在代码分析时，我们可以将它们从覆盖率数据中过滤掉</li>
</ul>
<h3 id="分支覆盖率（branch）"><a href="#分支覆盖率（branch）" class="headerlink" title="分支覆盖率（branch）"></a>分支覆盖率（branch）</h3><ul>
<li>分支覆盖率是用来对条件语句<strong>（if/else，case，?：）</strong>，<strong>指出其执行的分支轨迹</strong>。</li>
<li>例如判断下列分支的布尔表达式为<strong>true或者false</strong></li>
</ul>
<p><code> if(parity==ODD || parity==EVEN)begin</code></p>
<h3 id="条件覆盖率（condition-expression）"><a href="#条件覆盖率（condition-expression）" class="headerlink" title="条件覆盖率（condition/expression）"></a>条件覆盖率（condition/expression）</h3><ul>
<li>条件覆盖率是用来衡量一些布尔表达式中各个条件真伪判断的执行轨迹。</li>
<li>例如下列if条件语句中的两个条件是否各自衡量为true/false <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(parity==ODD || parity==EVEN)<span class="keyword">begin</span></span><br><span class="line">parity==ODD 或者 parity !=ODD</span><br><span class="line">paraity==EVEN 或者parity !=EVEN</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="状态机覆盖率（FSM）"><a href="#状态机覆盖率（FSM）" class="headerlink" title="状态机覆盖率（FSM）"></a>状态机覆盖率（FSM）</h3><ul>
<li>仿真工具由于可以自动识别状态机，因此在收集覆盖率时，也可以将覆盖率状态的执行情况监测到。</li>
<li>每个状态的进入次数，状态之间的跳转次数，以及多个状态的跳转顺序都可以由仿真工具记录下来。</li>
</ul>
<h2 id="功能覆盖率"><a href="#功能覆盖率" class="headerlink" title="功能覆盖率"></a>功能覆盖率</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p><strong>这一检查中可能会存在一些不期望的情况</strong>：</p>
<ul>
<li>一些功能没有被实现</li>
<li>一些功能被错误地实现了</li>
<li>一些没有被要求的功能也被实现了</li>
</ul>
<blockquote>
<p>我们无法通过代码覆盖率得知要求的功能是否被实现了，而需要<strong>显性地通过功能覆盖率</strong>与设计功能描述做映射，继而量化功能验证的进程。<br>在约束随机测试流行于验证时，由于随机测试在仿真时会自动产生上千条测试激励，但我们却无法知道随机产生的激励究竟测试了什么功能。<br>功能覆盖率是最好地可以协助在回归测试时自动监测哪些功能被激活的方法。</p>
</blockquote>
<p><strong>创建功能覆盖率模型需要完成以下两个步骤</strong>：</p>
<ul>
<li>从功能描述文档提取拆分需要测试的功能点</li>
<li>将功能点量化为与设计实现对应的SV功能覆盖代码</li>
</ul>
<h3 id="覆盖组（covergroup）"><a href="#覆盖组（covergroup）" class="headerlink" title="覆盖组（covergroup）"></a>覆盖组（covergroup）</h3><ul>
<li>覆盖组与类相似，在一次定义以后便可以多次进行例化。</li>
<li>覆盖组含有覆盖点（coverpoint）、选项（option）、形式参数（argument）和可选触发（trigger event）。</li>
<li><strong>一个覆盖组包含了一个或者多个数据点</strong> 。</li>
<li>覆盖组可以定义在类里，也可以定义在模块或者程序（program）中。</li>
<li>覆盖组可以采集任何可见的变量，比如程序或模块变量、接口信号或者设计中的任何信号</li>
<li>在类中的覆盖组也可以采集类的成员变量</li>
<li>覆盖组应该定义在<strong>适当的抽象层次</strong>上</li>
<li>对任何事务的采样都必须等到数据被待测设计接收到以后</li>
<li><strong>一个类也可以包含多个覆盖组</strong>，每个覆盖组可以根据需要将它们使能或者禁止<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123; red, green, blue&#125;color; </span><br><span class="line"><span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>] pixel_adr, pixel_offset, pixel_hue; </span><br><span class="line"><span class="keyword">covergroup</span> g2 @(<span class="keyword">posedge</span> clk);        <span class="comment">//每个时钟上升沿都采样</span></span><br><span class="line">  Hue:<span class="keyword">coverpoint</span> pixel_hue;        <span class="comment">//采样 Hue为采样任务的名称</span></span><br><span class="line">  Offset:<span class="keyword">coverpoint</span> pixel_offset;</span><br><span class="line">  AxC:<span class="keyword">cross</span> color,pixel_adr;<span class="comment">// cross 2 variables    3*16种全部</span></span><br><span class="line">  all:<span class="keyword">cross</span> color,Hue,Offset;<span class="comment">// cross 1 VARs and 2 CPs </span></span><br><span class="line"><span class="keyword">endgroup</span> </span><br><span class="line">g2 cg_inst=<span class="keyword">new</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="仓（bin）"><a href="#仓（bin）" class="headerlink" title="仓（bin）"></a>仓（bin）</h3><ul>
<li><p>关键词bins可以用来将每个感兴趣的数值均对一个独立的bin上或者将所有值对应到一个共同的bin </p>
</li>
<li><p>iff语句也可以用在bin的定义，它表示条件为false，那么右集该bin的时候，该bin的采样数自不会增长</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bit</span> [<span class="number">9</span>:<span class="number">0</span>] v_a;</span><br><span class="line"><span class="keyword">covergroup</span> cg @(<span class="keyword">posedge</span> clk);</span><br><span class="line">  <span class="keyword">coverpoint</span> v_a&#123;</span><br><span class="line">    <span class="keyword">bins</span> a=&#123;[<span class="number">0</span>:<span class="number">63</span>],<span class="number">65</span>&#125;;</span><br><span class="line">    <span class="keyword">bins</span> b[]=&#123;[<span class="number">127</span>:<span class="number">150</span>],[<span class="number">148</span>:<span class="number">191</span>]&#125;;</span><br><span class="line">    <span class="keyword">bins</span> c[]=&#123;<span class="number">200</span>,<span class="number">201</span>,<span class="number">202</span>&#125;;</span><br><span class="line">    <span class="keyword">bins</span> d=&#123;[<span class="number">1000</span>:$]&#125;;</span><br><span class="line">    <span class="keyword">bins</span> others[]=<span class="keyword">default</span>;  <span class="comment">//除了上面定义的合法值都属于default</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">endgroup</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//covergroup的参数也可以被传递到bin的定义中,做数值覆盖</span></span><br><span class="line"><span class="keyword">covergroup</span> cg (<span class="keyword">ref</span> <span class="keyword">int</span> ra, <span class="keyword">input</span> <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span><br><span class="line">    @(<span class="keyword">posedge</span> clk)；</span><br></pre></td></tr></table></figure></li>
<li><p>除了可以覆盖数值，还可以覆盖数值的变化</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">valuel =&gt; value2</span><br><span class="line">valuel =&gt; value3 =&gt; value4 =&gt; value5</span><br><span class="line">range_list1 =&gt; range_list21,<span class="number">5</span>=&gt;<span class="number">6</span>，<span class="number">7</span></span><br><span class="line">trans_item[* repeat_range ]</span><br><span class="line"><span class="number">3</span>[* <span class="number">5</span>]     <span class="comment">//表示3=&gt;3=&gt;3=&gt;3=&gt;3</span></span><br><span class="line"><span class="number">3</span>[* <span class="number">3</span>:<span class="number">5</span>]  <span class="comment">//表示（3=&gt;3=&gt;3）,（3=&gt;3=&gt;3=&gt;3）或（3=&gt;3=&gt;3=&gt;3=&gt;3）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//除了使用=&gt;来表示相邻采样点的变化，也可以使用-&gt;来表示非相邻采样点的数值变化，</span></span><br><span class="line"><span class="comment">//在=&gt;序列后的下一个时序*必须紧跟*=&gt;序列的最后一个事件</span></span><br><span class="line"><span class="number">3</span>[-&gt;<span class="number">3</span>]</span><br><span class="line">表示...=&gt;<span class="number">3</span>...=&gt;<span class="number">3</span>...=&gt;<span class="number">3</span></span><br><span class="line"><span class="number">1</span>=&gt;<span class="number">3</span>[-&gt;<span class="number">3</span>]=&gt;<span class="number">5</span></span><br><span class="line">表示<span class="number">1</span>...=&gt;<span class="number">3</span>...=&gt;<span class="number">3</span>...=&gt;<span class="number">3</span>=&gt;<span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//与[-&gt;repeat range]类似的有[=repeat range]也表示非连续的循环</span></span><br><span class="line"><span class="comment">//只是与-&gt;有区别的在于，跟随-&gt;序列的下一次值变化可以发生在-&gt;结束后的*任何时刻*。</span></span><br><span class="line"><span class="number">3</span>[= <span class="number">2</span>]</span><br><span class="line">表示..=&gt;<span class="number">3</span>...=&gt;<span class="number">3</span></span><br><span class="line"><span class="number">1</span>=&gt;<span class="number">3</span>[=<span class="number">2</span>]=&gt;<span class="number">6</span></span><br><span class="line">表示<span class="number">1</span>...=&gt;<span class="number">3</span>...=&gt;<span class="number">3</span>...=&gt;<span class="number">6</span></span><br></pre></td></tr></table></figure></li>
<li><p>如果coverpoint没有指定任何bin，那么SV将会为其自动生成bin，遵循的原则是：</p>
<ul>
<li>如果变量是枚举类型，那么bin的数量是枚举类型的基数（所有枚举数值的合）</li>
<li>如果变量是整形（M位宽），那么bin的类型将是2^M和auto_bin_max选项的较小值</li>
</ul>
</li>
</ul>
<ul>
<li><p>默认情况下，数值的变化可以针对四值类型变量进行覆盖，例如bin如果包含x或者z，则表示只有该变量对应位也为x或者z的时候，bin也才可以被采样到。</p>
</li>
<li><p><strong>wildcard修饰符</strong>可以使得bin中包含x，z和？的数值都将用来表示0或者1，也就是通配符的意思</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">wildcard</span> <span class="keyword">bins</span> g12_15=&#123;<span class="number">4</span>b&#x27;<span class="number">11</span>??&#125;;</span><br><span class="line"><span class="comment">//g12_15可以用来表示12到15之间的值，即1100，1101，1110，1111</span></span><br></pre></td></tr></table></figure></li>
<li><p>ignore_bins用来将其排除在有效统计的bin集合之外</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">covergroup</span> cg23; </span><br><span class="line">  <span class="keyword">coverpoint</span> a&#123;</span><br><span class="line">    <span class="keyword">ignore_bins</span> ignore_vals=&#123;<span class="number">7</span>,<span class="number">8</span>&#125;; </span><br><span class="line">    <span class="keyword">ignore_bins</span> ignore_trans=(<span class="number">1</span>=&gt;<span class="number">3</span>=&gt;<span class="number">5</span>); </span><br><span class="line"><span class="keyword">endgroup</span></span><br></pre></td></tr></table></figure></li>
<li><p>illegal_bins用来指出采样到的数值为非法制，如果illegal_bins被采样到，那么仿真将报错</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">covergroup</span> cg3; </span><br><span class="line">  <span class="keyword">coverpoint</span> b&#123;</span><br><span class="line">    <span class="keyword">illegal_bins</span> bad_vals=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; </span><br><span class="line">    <span class="keyword">illegal_bins</span> bad_trans=(<span class="number">4</span>=&gt;<span class="number">5</span>=&gt;<span class="number">6</span>);     <span class="comment">//illegal_bins被采样到，那么仿真将报错</span></span><br><span class="line"><span class="keyword">endgroup</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="覆盖点（coverpoint）"><a href="#覆盖点（coverpoint）" class="headerlink" title="覆盖点（coverpoint）"></a>覆盖点（coverpoint）</h3><ul>
<li>在定义coverpoint时可以不给名字或者给名字，我们建议给不同的coverpoint以不同的名字</li>
<li>这些有名字的coverpoint可以用来做更进一步的处理，例如在交叉覆盖率中使用某个coverpoint</li>
<li>可以通过iff在一些情况下禁止coverpoint的采集<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">covergroup</span> g4; </span><br><span class="line">  <span class="keyword">coverpoint</span> s0 <span class="keyword">iff</span>(!reset); </span><br><span class="line"><span class="keyword">endgroup</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="交叉覆盖率（cross）"><a href="#交叉覆盖率（cross）" class="headerlink" title="交叉覆盖率（cross）"></a>交叉覆盖率（cross）</h3><ul>
<li>covergroup可以在两个或者更多的coverpoint或者变量之间定义交叉覆盖率（cross coverage）</li>
<li>在对a和b产生交叉覆盖率之前，系统会先为它们隐性产生对应的coverpoint和bin，每个coverpoint都有16个自动产生的bin，两个coverpoint交叉以后将生成256个交叉的bin</li>
<li>除了系统会自动为交叉覆盖率生成bin以外，用户还可以自己定义交叉覆盖率的</li>
<li>bin binsof（）的参数可以是coverpoint或者变量，表示对应的bin总和，可以<strong>利用binsof（）对其结果做进一步的过滤。</strong><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i,j; </span><br><span class="line"><span class="keyword">covergroup</span> ct; </span><br><span class="line">  <span class="keyword">coverpoint</span> i &#123; <span class="keyword">bins</span> i[]=&#123;[<span class="number">0</span>:<span class="number">1</span>]&#125;;&#125;</span><br><span class="line">  <span class="keyword">coverpoint</span> j &#123; <span class="keyword">bins</span> j[]=&#123;[<span class="number">0</span>:<span class="number">1</span>]&#125;;&#125; </span><br><span class="line">  x1: <span class="keyword">cross</span> i,j;     <span class="comment">//因为两个变量都是32bits，所以交叉覆盖计算32*32位</span></span><br><span class="line">  x2: <span class="keyword">cross</span> i,j&#123; </span><br><span class="line">    <span class="keyword">bins</span> i_zero=<span class="keyword">binsof</span>(i)<span class="variable">.intersect</span> &#123;<span class="number">0</span>&#125;; </span><br><span class="line">  &#125; </span><br><span class="line"><span class="keyword">endgroup</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="指定覆盖率选项"><a href="#指定覆盖率选项" class="headerlink" title="指定覆盖率选项"></a>指定覆盖率选项</h3><ul>
<li>覆盖率选项按照在covergroup、coverpoint和cross不同的域中是否具备，下表做了归纳：</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1621067444892-a3380911-1fff-4196-9a68-a8c809479812.png#align=left&display=inline&height=337&margin=%5Bobject%20Object%5D&name=image.png&originHeight=570&originWidth=1162&size=192006&status=done&style=none&width=687" alt="image.png"></p>
<h3 id="预定义覆盖率方法"><a href="#预定义覆盖率方法" class="headerlink" title="预定义覆盖率方法"></a>预定义覆盖率方法</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1621067486566-4f67133a-62a8-46a6-9fb6-5e183b770aea.png#align=left&display=inline&height=351&margin=%5Bobject%20Object%5D&name=image.png&originHeight=621&originWidth=1248&size=327143&status=done&style=none&width=706" alt="image.png"></p>
<h2 id="从功能描述到覆盖率"><a href="#从功能描述到覆盖率" class="headerlink" title="从功能描述到覆盖率"></a>从功能描述到覆盖率</h2><ul>
<li>功能覆盖率应该基于对DUT端口或者内部信号的监测</li>
<li>功能覆盖率的有效性应该首先建立在测试通过的情况下，这还需要测试平台有自动检查（scoreboard/reference model）来保证对应的功能得到检验</li>
<li>在创建覆盖率模型时，同创建property（assertion）一样，不要贪大求全，而应该对每一个covergroup、coverpoint、bin和cross都做到简明扼要，尽量将逻辑和时序都拆分开，便于后期的覆盖率分析</li>
<li>选取一个适当的范围进行覆盖率收集，例如一个32位的整形变量，在收集数值时可以结合其与设计功能的特点，找到边界值、分段范围，再在合适的抽象层次上进行收集</li>
<li>采用统一的覆盖率编码风格，例如covergroup的名字，采样的方式，是否填写comment，覆盖率模型置干何处等。</li>
<li>要实现功能覆盖率的收敛，就需要按照以下步骤考虑：<ul>
<li>哪些功能需要测试</li>
<li>明白在什么条件下需要测试对应的功能</li>
<li>为了测试这些功能，需要提供什么样的测试平台组件以便提供激励和监测</li>
<li>测试平台如何检查这些功能正常工作</li>
</ul>
</li>
<li>由于功能覆盖率不是自动的过程，因此它需要将功能描述同设计实现对应起来</li>
</ul>
]]></content>
      <categories>
        <category>笔记篇</category>
        <category>数字验证</category>
      </categories>
      <tags>
        <tag>SystemVerilog</tag>
      </tags>
  </entry>
  <entry>
    <title>SV系统验证（8）——线程同步、通信和虚方法</title>
    <url>/2021/05/09/SV%E7%B3%BB%E7%BB%9F%E9%AA%8C%E8%AF%81%EF%BC%888%EF%BC%89%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E3%80%81%E9%80%9A%E4%BF%A1%E5%92%8C%E8%99%9A%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h2><h3 id="并行线程"><a href="#并行线程" class="headerlink" title="并行线程"></a>并行线程</h3><ul>
<li>Verilog中与<strong>顺序线程begin…end</strong>相对的是<strong>并行线程fork…join</strong>。</li>
<li>SV引入了两种新新的创建线程的方法，fork..join_none和fork…join_any。<blockquote>
<p>fork…join需要<strong>所有并行的线程都结束</strong>以后才会继续执行。<br>fork…join_any则会等到<strong>任何一个线程结束</strong>以后就继续执行。<br>fork…join_none则<strong>不会等待</strong>其子线程而继续执行。</p>
</blockquote>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1620527362355-8bef8582-6fa3-42d2-a93a-d18a85aad06e.png#align=left&display=inline&height=198&margin=%5Bobject%20Object%5D&name=image.png&originHeight=269&originWidth=644&size=37379&status=done&style=none&width=473" alt="image.png"></p>
<blockquote>
<p><strong>需要注意</strong>的是，fork..…join any和fork…join_none执行后，其一些未完成的子程序仍将在后台运行。<br>如果要等待这些子程序全部完成，或者停止这些子程序可以使用<strong>wait fork</strong>或者<strong>disable fork</strong>。</p>
<ul>
<li>wait fork 是等待<strong>当前语境所有的</strong>的fork语句块<strong>全部结束（并非放行）</strong>之后就可以执行。</li>
<li>disable fork 是关闭<strong>当前语境</strong>的<strong>所有</strong>未执行完的fork语句块。</li>
</ul>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span>:ini procl </span><br><span class="line">  <span class="built_in">$display</span>(<span class="string">&quot;@%t fork-join_any entered&quot;</span>,<span class="built_in">$time</span>); </span><br><span class="line">  <span class="keyword">fork</span> </span><br><span class="line">    exec(<span class="number">1</span>,<span class="number">10</span>);    <span class="comment">//任务一需要10ns</span></span><br><span class="line">    exec(<span class="number">2</span>,<span class="number">60</span>);    <span class="comment">//任务二需要60ns</span></span><br><span class="line">  <span class="keyword">join_any</span>         <span class="comment">//此fork块需要10ns放行，60ns结束</span></span><br><span class="line">  <span class="built_in">$display</span>(<span class="string">&quot;@%t fork-join_any exited&quot;</span>,<span class="built_in">$time</span>);</span><br><span class="line">  <span class="built_in">$display</span>(<span class="string">&quot;@%t fork-join_none entered&quot;</span>,<span class="built_in">$time</span>);</span><br><span class="line">  <span class="keyword">fork</span> </span><br><span class="line">    exec(<span class="number">3</span>,<span class="number">30</span>);    <span class="comment">//任务三需要30ns</span></span><br><span class="line">    exec(<span class="number">4</span>,<span class="number">40</span>);    <span class="comment">//任务四需要40ns</span></span><br><span class="line">  <span class="keyword">join_none</span>        <span class="comment">//此fork块需要0ns放行，40ns结束</span></span><br><span class="line">  <span class="built_in">$display</span>(<span class="string">&quot;@%t fork-join_none exited&quot;</span>,<span class="built_in">$time</span>); </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">wait</span> <span class="keyword">fork</span>;      <span class="comment">//由于第一个fork最长60ns全部执行完，第二个fork在第一个fork执行10ns后才开始，执行完的时刻为50ns时，第一个fork执行完的时刻为60ns时</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;@%t ini_procl exited&quot;</span>,<span class="built_in">$time</span>); <span class="comment">//因此两个fork全部执行完的时间为60ns</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//disable fork;  //一旦运行到此，所有的为执行完的fork都强制结束。</span></span><br><span class="line"><span class="comment">//  $display(&quot;@%t ini_procl exited&quot;,$time);</span></span><br><span class="line"> <span class="keyword">end</span></span><br></pre></td></tr></table></figure>


<h3 id="时序控制"><a href="#时序控制" class="headerlink" title="时序控制"></a>时序控制</h3><p>SV可以通过<strong>延迟控制</strong>或者<strong>事件等待</strong>来对过程块完成时序控制。</p>
<ul>
<li>延迟控制即通过#来完成。</li>
<li>事件（event）控制即通过@来完成。</li>
<li>wait语句也可以与事件或者表达式结合来完成。<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">#<span class="number">10</span> rega=regb;      <span class="comment">//延时控制</span></span><br><span class="line"></span><br><span class="line">@r rega=regb;       <span class="comment">//时间控制</span></span><br><span class="line">@(<span class="keyword">posedge</span> clock) rega=regb;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">real</span> AOR[];         <span class="comment">//wait表达式控制</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">wait</span>(AOR. size()&gt;<span class="number">0</span>)....;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="进程间同步和通信"><a href="#进程间同步和通信" class="headerlink" title="进程间同步和通信"></a>进程间同步和通信</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>测试平台中的所有线程都需要同步并交换数据。</li>
<li>一个线程等待另外一个，例如验证环境需要等待所有激励结束、比较结束才可以结束仿真。比如监测器需要将监测到的数据发送至比较器，比较器又需要不同的缓存获取数据进行比较。</li>
</ul>
<h3 id="事件（event）"><a href="#事件（event）" class="headerlink" title="事件（event）"></a>事件（event）</h3><ul>
<li>可以通过event来声明一个命名event变量，并且去触发它。</li>
<li>这个命名event可以用来控制进程的执行。</li>
<li>可以通过”-&gt;”来触发事件。</li>
<li>其它等待该事件的进程可以通过**@**操作符（边沿触发）或者 <code>wait()</code>（电平触发）来检查event触发状态来完成。<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">event</span> e1,e2,e3; </span><br><span class="line"><span class="keyword">task</span> <span class="keyword">automatic</span> wait_event(<span class="keyword">event</span> e,<span class="keyword">string</span> name);</span><br><span class="line">  <span class="built_in">$display</span>(<span class="string">&quot;@%t start waiting event %s&quot;</span>,<span class="built_in">$time</span>,name);</span><br><span class="line">  @e;</span><br><span class="line">  <span class="built_in">$display</span>(<span class="string">&quot;@%t finish waiting event 8s&quot;</span>,<span class="built_in">$time</span>,name); </span><br><span class="line"><span class="keyword">endtask</span> </span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span> </span><br><span class="line">  <span class="keyword">fork</span> </span><br><span class="line">    wait_event(el,<span class="string">&quot;el&quot;</span>);  <span class="comment">//开始时 等待事件1</span></span><br><span class="line">    wait_event(e2,<span class="string">&quot;e2&quot;</span>);  <span class="comment">//开始时 等待事件2</span></span><br><span class="line">    wait_event(e3,<span class="string">&quot;e3&quot;</span>);  <span class="comment">//开始时 等待事件3</span></span><br><span class="line">  <span class="keyword">join</span> </span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span> </span><br><span class="line">  <span class="keyword">fork</span> </span><br><span class="line">    <span class="keyword">begin</span> #<span class="number">10</span>ns-&gt;e1 <span class="keyword">end</span>;  <span class="comment">//开始10ns时刻 触发事件1</span></span><br><span class="line">    <span class="keyword">begin</span> #<span class="number">20</span>ns-&gt;e2 <span class="keyword">end</span>;  <span class="comment">//开始20ns时刻 触发事件2</span></span><br><span class="line">    <span class="keyword">begin</span> #<span class="number">30</span>ns-&gt;e3 <span class="keyword">end</span>;  <span class="comment">//开始30ns时刻 触发事件3</span></span><br><span class="line">  <span class="keyword">join</span> </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果将event换成bit，每次触发的时候反向，那么传入参数需要变成(ref bit e)实时监控信号变化</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>event类型传递的类似于句柄，自带实时监测功能。<br>@和wait一般没有区别，但同一时刻<strong>既触发又等待</strong>是时候，两者有区别。</p>
</blockquote>
</li>
</ul>
<h3 id="旗语（semaphore）"><a href="#旗语（semaphore）" class="headerlink" title="旗语（semaphore）"></a>旗语（semaphore）</h3><ul>
<li>旗语从概念上讲，是一个容器。</li>
<li>在创建旗语的时候，会为其分配固定的钥匙数量。使用旗语的进程必须先获得其钥匙，才可以继续执行。</li>
<li>旗语的钥匙数量可以有多个，等待旗语钥匙的进程也可同时有多个。</li>
<li>旗语通常用于<strong>互斥</strong>，对共享资源的<strong>访问控制</strong>，以及基本的<strong>同步</strong>。<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建旗语，并为其分配钥匙的方式如下：</span></span><br><span class="line">semaphore sm;</span><br><span class="line">sm=<span class="keyword">new</span>();   </span><br><span class="line"><span class="keyword">new</span>(N=<span class="number">0</span>);    <span class="comment">//创建一个具有固定钥匙数量的旗语,并生成N（默认为0）把钥匙</span></span><br><span class="line">get(N=<span class="number">1</span>);    <span class="comment">//从旗语那里获取一个（默认）或多个钥匙（阻塞型），钥匙可用返回1继续执行，钥匙不足，进程阻塞，排队拿取钥匙，等待队列先进先出（FIFO）</span></span><br><span class="line">put(N=<span class="number">1</span>);    <span class="comment">//将一个或多个钥匙返回到旗语中</span></span><br><span class="line">try_get(N=<span class="number">1</span>);<span class="comment">//尝试获取一个或多个钥匙而不会阻塞（非阻塞型），钥匙可用，返回1继续执行，要是不足，返回0，但不阻塞。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">semaphore mem_acc_key; </span><br><span class="line"><span class="keyword">int</span> <span class="keyword">unsigned</span> mem [<span class="keyword">int</span> <span class="keyword">unsigned</span>]; </span><br><span class="line"><span class="keyword">task</span> <span class="keyword">automatic</span> write(<span class="keyword">int</span> <span class="keyword">unsigned</span> addr, <span class="keyword">int</span> <span class="keyword">unsigned</span> data); <span class="comment">//写函数</span></span><br><span class="line">  mem_acc_key<span class="variable">.get</span>();  <span class="comment">//获取钥匙</span></span><br><span class="line">  #<span class="number">1</span>ns;               <span class="comment">//写1ns</span></span><br><span class="line">  mem[addr]=data;    <span class="comment">//写入数据</span></span><br><span class="line">  mem_acc_key<span class="variable">.put</span>();  <span class="comment">//还钥匙</span></span><br><span class="line"><span class="keyword">endtask</span> </span><br><span class="line"><span class="keyword">task</span> <span class="keyword">automatic</span> read(<span class="keyword">int</span> <span class="keyword">unsigned</span> addr, <span class="keyword">output</span> <span class="keyword">int</span> <span class="keyword">unsigned</span> data); <span class="comment">//读函数</span></span><br><span class="line">  mem_acc_key<span class="variable">.get</span>();  <span class="comment">//获取钥匙</span></span><br><span class="line">  #<span class="number">1</span>ns;</span><br><span class="line">  <span class="keyword">if</span>(mem<span class="variable">.exists</span>(addr)) <span class="comment">//读取数据</span></span><br><span class="line">    data=mem[addr]; </span><br><span class="line">  <span class="keyword">else</span> data=&#x27;x; </span><br><span class="line">  mem_acc_key<span class="variable">.put</span>();   <span class="comment">//还钥匙</span></span><br><span class="line"><span class="keyword">endtask</span> </span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span> </span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">unsigned</span> data=<span class="number">100</span>; </span><br><span class="line">  mem_acc_key=<span class="keyword">new</span>(<span class="number">1</span>);   <span class="comment">//生成钥匙</span></span><br><span class="line">  <span class="keyword">forever</span> <span class="keyword">begin</span> </span><br><span class="line">    <span class="keyword">fork</span> </span><br><span class="line">      <span class="keyword">begin</span></span><br><span class="line">        #<span class="number">10</span>ns; </span><br><span class="line">        write(<span class="number">&#x27;h10</span>, data+<span class="number">100</span>); </span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;@%t write with data %0d&quot;</span>, <span class="built_in">$time</span>, data); </span><br><span class="line">      <span class="keyword">end</span> </span><br><span class="line">      <span class="keyword">begin</span></span><br><span class="line">        #<span class="number">10</span>ns; </span><br><span class="line">        read(<span class="number">&#x27;h10</span>, data); </span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;@%t read with data %0d&quot;</span>, <span class="built_in">$time</span>, data); </span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">     <span class="keyword">join</span> </span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="信箱（mailbox）"><a href="#信箱（mailbox）" class="headerlink" title="信箱（mailbox）"></a>信箱（mailbox）</h3><ul>
<li>信箱mailbox可以使得进程之间的信息得以交换，数据可以由一个进程写入信箱，再由另外一个进程获得。信箱在创建时可以<strong>限制其容量，或者不限制</strong>。</li>
<li>当信箱<strong>容量</strong>写满时，后续再<strong>写入的动作会被挂起</strong>，直到信箱自据从中读取，使得信箱有空间以后才可以继续写入。不限制容量的信箱则不会挂起写入信箱的动作。<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建信箱的方式如下：</span></span><br><span class="line"><span class="keyword">new</span>(N=<span class="number">0</span>);    <span class="comment">//创建信箱，默认不限定大小（即N=0），传如正参数表示限定信箱容量</span></span><br><span class="line">put();       <span class="comment">//将信息按照FIFO顺序写入信箱，如果信箱满了，则put任务挂起，直到有新空间</span></span><br><span class="line">try_put();   <span class="comment">//试着按照FIFO写入信箱，但不会阻塞，写入成功返回1，写入失败返回0</span></span><br><span class="line">get();       <span class="comment">//获取信息同时取出数据，若信箱为空，get任务挂起，直到有信息可以读取，读取的信息会同时从信箱移除</span></span><br><span class="line">peek();      <span class="comment">//获取信息但不会取出数据，更像是一种拷贝，信箱中的信息不会被移除</span></span><br><span class="line">try_get()/try_peek();  <span class="comment">//试着取出数据但不会阻塞，若读取成功返回1.读取失败返回0</span></span><br><span class="line">num();       <span class="comment">//获取信箱信息的数目，通常结合读写信函数，防止被阻塞。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="参数化信箱"><a href="#参数化信箱" class="headerlink" title="参数化信箱"></a>参数化信箱</h4><ul>
<li>默认的信箱，在没有指定类型的情况下，可以储存任何类型的数据，但为了避免运行错误和类型不匹配，建议在声明时指定储存类型。</li>
<li>这种参数化信箱的方式可以在编译的时候检查类型不匹配的情况。<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> tb; </span><br><span class="line">  mailbox <span class="variable">#(int)</span> mb;   <span class="comment">//限定信箱内容类型</span></span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span> </span><br><span class="line">    <span class="keyword">int</span> data; </span><br><span class="line">    mb=<span class="keyword">new</span>(<span class="number">8</span>);        <span class="comment">//限定信箱容量</span></span><br><span class="line">    <span class="keyword">forever</span> <span class="keyword">begin</span> </span><br><span class="line">      <span class="keyword">case</span>($urandom()%<span class="number">2</span>)</span><br><span class="line">        <span class="number">0</span>: <span class="keyword">begin</span> </span><br><span class="line">            <span class="keyword">if</span>(mb<span class="variable">.num</span>()&lt;<span class="number">8</span>) </span><br><span class="line">            <span class="keyword">begin</span> </span><br><span class="line">              data=$urandom_range(<span class="number">0</span>,<span class="number">10</span>); </span><br><span class="line">              mb<span class="variable">.put</span>(data); </span><br><span class="line">              <span class="built_in">$display</span>(<span class="string">&quot;mb put data %0d&quot;</span>, data); </span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">           <span class="keyword">end</span></span><br><span class="line">        <span class="number">1</span>: <span class="keyword">begin</span> </span><br><span class="line">          <span class="keyword">if</span>(mb<span class="variable">.num</span>()&gt;<span class="number">0</span>) </span><br><span class="line">            <span class="keyword">begin</span> </span><br><span class="line">              mb<span class="variable">.try_get</span>(data);</span><br><span class="line">              <span class="built_in">$display</span>(<span class="string">&quot;mb get data %0d&quot;</span>, data); </span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">          <span class="keyword">end</span> </span><br><span class="line">      <span class="keyword">endcase</span> </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> mailbox <span class="variable">#(string)</span> s_mb; <span class="comment">//限定信箱内容为字符串</span></span><br><span class="line">  s_mb mb = <span class="keyword">new</span>(<span class="number">8</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="虚方法"><a href="#虚方法" class="headerlink" title="虚方法"></a>虚方法</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul>
<li>类的成员<strong>方法（变量不行）</strong>可加以修饰词virtual（虚方法）。</li>
<li>虚方法是一种基本的多态（polymorphic）结构。</li>
<li>一个虚方法可以覆盖基类的同名方法。</li>
<li>在父类和子类中声明的虚方法，其<strong>方法名、参数名、参数方向</strong>等都应该<strong>保持一致</strong>。</li>
<li>在调用虚方法时，它将<strong>调用句柄指向对象的方法，而不受句柄类型的影响</strong>。</li>
</ul>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> BasePacket; </span><br><span class="line">  <span class="keyword">int</span> A=<span class="number">1</span>; </span><br><span class="line">  <span class="keyword">int</span> B=<span class="number">2</span>; </span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">void</span> printA; </span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;BasePacket::A is %d&quot;</span>,A); </span><br><span class="line">  <span class="keyword">endfunction</span>: printA </span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> printB;         <span class="comment">//父类必须声明虚方法，声明后此函数优先级下降</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;BasePacket:: Bis %d&quot;</span>,B); </span><br><span class="line">  <span class="keyword">endfunction</span>: printB </span><br><span class="line"><span class="keyword">endclass</span>: BasePacket </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> My_Packet <span class="keyword">extends</span> BasePacket; </span><br><span class="line">  <span class="keyword">int</span> A=<span class="number">3</span>; </span><br><span class="line">  <span class="keyword">int</span> B=<span class="number">4</span>; </span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">void</span> printA;</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;My_Packet::A is %d&quot;</span>,A); </span><br><span class="line">  <span class="keyword">endfunction</span>: printA </span><br><span class="line">  <span class="keyword">virtual</span> <span class="keyword">function</span> <span class="keyword">void</span> printB;      <span class="comment">//子类可以不声明虚方法</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;My_Packet::B is %d&quot;</span>,B); </span><br><span class="line">  <span class="keyword">endfunction</span>: printB</span><br><span class="line"><span class="keyword">endclass</span>: My_Packet</span><br><span class="line"></span><br><span class="line">BasePacket P1=<span class="keyword">new</span>; </span><br><span class="line">My_Packet P2=<span class="keyword">new</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span> </span><br><span class="line">  P1<span class="variable">.printA</span>;   <span class="comment">//displays &#x27; BasePacket::A is 1. </span></span><br><span class="line">  P1<span class="variable">.printB</span>;   <span class="comment">//displays &#x27; BasePacket::B is 2&#x27;</span></span><br><span class="line">  P2<span class="variable">.printA</span>;   <span class="comment">//displays &#x27; My_Packet::A is 3.</span></span><br><span class="line">  P2<span class="variable">.printB</span>;   <span class="comment">//displays &#x27; My_Packet::B is 4. </span></span><br><span class="line">  <span class="comment">//在子类句柄赋值给父类句柄的时候，虚方法开始起作用</span></span><br><span class="line">  P1=P2;       <span class="comment">//Pl has a handle to a My packet object </span></span><br><span class="line">  Pl<span class="variable">.printA</span>;   <span class="comment">//displays &#x27; BasePacket::A is 1,</span></span><br><span class="line">  Pl<span class="variable">.printB</span>;   <span class="comment">//diaplaya &#x27; Hy Packet::B is 4 latest derived method</span></span><br><span class="line">               <span class="comment">//由于经过句柄赋值，终归是子类对象，虚方法会寻找子类的函数</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="静态转换"><a href="#静态转换" class="headerlink" title="静态转换"></a>静态转换</h3><ul>
<li>静态转换操作符不对转换值进行检查。</li>
<li>转换时指定目标类型，并在要转换的表达式前加上单引号’</li>
<li>Verilog对整数和实数类型，或者不同位宽的向量之间进行<strong>隐式转换</strong>。<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i; </span><br><span class="line"><span class="keyword">real</span> r; </span><br><span class="line">i=<span class="keyword">int</span>&#x27;(<span class="number">10</span><span class="variable">.0</span>-<span class="number">0</span><span class="variable">.1</span>);<span class="comment">//cast is optional </span></span><br><span class="line">r=<span class="keyword">real</span>&#x27;(<span class="number">42</span>);<span class="comment">//cast is optional</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="动态转换"><a href="#动态转换" class="headerlink" title="动态转换"></a>动态转换</h3><ul>
<li>将子类的句柄赋值给父类的句柄可以（子-&gt;父），在我们将父类的句柄赋值给子类的句柄时编译将会报错。</li>
<li>$cast（）系统函数可以将父类句柄转换为子类句柄，只要该柄<strong>指向的是一个子类的对象</strong>。（在父类需要访问子类变量的时候用到，父类句柄访问子类方法可以使用虚方法）</li>
</ul>
]]></content>
      <categories>
        <category>笔记篇</category>
        <category>数字验证</category>
      </categories>
      <tags>
        <tag>SystemVerilog</tag>
      </tags>
  </entry>
  <entry>
    <title>纳米电子学概述</title>
    <url>/2021/05/07/%E7%BA%B3%E7%B1%B3%E7%94%B5%E5%AD%90%E5%AD%A6%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="请简述弹道输运、相位干涉、普适电导涨落、弱局域化、载流子热化、隧穿现象以及单电子现象与库伦阻塞的物理含义"><a href="#请简述弹道输运、相位干涉、普适电导涨落、弱局域化、载流子热化、隧穿现象以及单电子现象与库伦阻塞的物理含义" class="headerlink" title="请简述弹道输运、相位干涉、普适电导涨落、弱局域化、载流子热化、隧穿现象以及单电子现象与库伦阻塞的物理含义"></a>请简述弹道输运、相位干涉、普适电导涨落、弱局域化、载流子热化、隧穿现象以及单电子现象与库伦阻塞的物理含义</h2><h3 id="弹道输运"><a href="#弹道输运" class="headerlink" title="弹道输运"></a>弹道输运</h3><p>首先在欧姆型导体中载流子的输运是扩散输运。所谓扩散输运就是导体中电子在电场作用下的运动不断受到各种散射机制的散射作用，电子的迁移过程是一个扩散过程。如果一个介观导体样品，其尺度小于载流子的平均自由程，在载流子输运过程中很可能就不会受到散射而通过样品。由于没有散射的作用，电子的运动仅遵从牛顿定律，被称为弹道(ballistic)输运，这种情况下，电子只有碰到了边界才会改变运动方向。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1620478354407-a09a2756-9533-4317-8d0e-e48719d8c417.png#align=left&display=inline&height=95&margin=%5Bobject%20Object%5D&name=image.png&originHeight=95&originWidth=294&size=11002&status=done&style=none&width=294" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1620477184479-213b4f00-114f-4bf2-990c-728400806834.png#align=left&display=inline&height=166&id=DhC2r&margin=%5Bobject%20Object%5D&originHeight=166&originWidth=476&status=done&style=none&width=476"><br>能够产生弹道输运的导体称为弹道导体，即不存在对载流子散射的导体。在一般的介质中电阻一般是由电子散射而产生，这可以是因为杂质、缺陷或者在平衡位置附近震荡的原子/分子引起的散射；也可以是由在气体和液体中自由运动的原子/分子引起的。而在弹道导体中并非没有散射就没有电阻，其电阻主要不同材料界面或不同几何区域的边界，除了界面势垒的反射，电子在弹道导体中的运动是弹性的没有能量损失。</p>
<h3 id="相位干涉"><a href="#相位干涉" class="headerlink" title="相位干涉"></a>相位干涉</h3><p>在量子力学理论中，当系统的尺度达到与粒子的德布罗意（de Broglie）波长可比拟的尺度时，粒子展现出波动-粒子二象属性。它的座标和动量，及能量和时间将满足测不准原理，体系的状态用粒子波函数描述。波函数具有幅值和相位两个特征参量，并遵从波的叠加原理。波的“叠加” 意味着波的两个波幅相加，这是不同于通常意义下的“混合”或“相加”。量子“叠加”性在“介观系统”的量子相位相干涨落效应中是非常重要，它将明确地呈现于观测到的物理性质中。例如，我们可以观测到电子的干涉和衍射现象。一般情况下波函数的相位是时间和座标的函数。粒子的量子行为会因增大系统尺度、大量粒子的热运动、以及被杂质的散射等因素被破坏掉，其结果使粒子量子相干性消失。然而，我们必须注意到这样一个事实：降低温度，会使对应的退相干时间增长。<br>微观系统中粒子的相位效应是明显的，一个最简单的例子是玻尔最早提出的氢原子的量子论，其量子化条件可以认为是电子绕原子核转动一周，相位变化为2Π的整数倍。<br>超导电性的研究中最先发现了宏观物理量与电子相位相关的量子效应。20世纪30年代初，发现了超导体的迈斯纳（Meissner）效应：置于磁场中的金属，当温度降低到临界温度以下时，变为超导体；达到稳定以后，磁场被排斥到超导体以外，即磁场不能深入到超导体内部。超导实际上是一种宏观量子现象。<br>相位干涉有两个条件：<br>①沿一闭合路径相反方向运动的两电子分波，这两个运动过程具有时间反演对称性<br>②当样品尺寸L≤L时，电子分波仅限制在数目较少的若干路径上运动，干涉的贡献显得非常重要。</p>
<h3 id="普适电导涨落"><a href="#普适电导涨落" class="headerlink" title="普适电导涨落"></a>普适电导涨落</h3><p>前述在一定的条件下观察到周期为ħ/e的电导谐振。只有当样品为环形结构时才能发生这种谐振。低温下不同，样品为简并，导电（或其他输运）过程主要是费米表面的载流子参与。杂质为散射势场的中心，载流子围绕它运动。<br>栅极电势或者由于所加磁场变化都会引起费米能的变化，载流子可能经过不同的路径绕过杂质，在这些路径上费米能略有差异。通过两个轨迹载流子相位的变化等价于通过A-B环的两个臂的情况，在这样的过程中可以产生e2/ħ的电导变化。<br>电导涨落产生条件：F&lt;&lt;l&lt;&lt;L≤L，满足样品是介观的，处于正常导电区域。这种电导的涨落的产生与费米能级的变化相关，在时间上是相当稳定的。电导涨落的幅值与样品的形状和空间维数只有微弱的依赖关系。涨落与散射中心在样品中精确位置有关，不同的样品有不同的涨落，因而这种涨落可以作为介观导体样品的“指纹”。电导涨落幅值的数量级是e2/h~4×10-5S,一个普适量，与样品特性无关。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1620477185010-b1e7b1a8-8d14-4347-a807-dc3a6fd69277.png#align=left&display=inline&height=295&id=O2NaC&margin=%5Bobject%20Object%5D&originHeight=295&originWidth=333&status=done&style=none&width=333"></p>
<h3 id="弱局域化"><a href="#弱局域化" class="headerlink" title="弱局域化"></a>弱局域化</h3><p>电子在固体中扩散运动时，以一定的概率返回它的出发点，这样的路径为闭合路径。 这两条路径是具有时间反演对称性的路径可以证明电子经过时间反演对称散射路径时，香味的移动是相等的。虽然大量电子扩散路径的电子分波的干涉趋于相互抵消，但是经过时间反演路径的电子波的干涉却互相增强了。这说明波在经历了漫散射后仍能产生一定量的回波（echo）。<img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1620477185435-486fd2c2-5d68-49d6-8f57-3e20b6111f2b.png#align=left&display=inline&height=395&id=KHt7h&margin=%5Bobject%20Object%5D&originHeight=395&originWidth=706&status=done&style=none&width=706"><br>由于电子波动性的效应，电子似乎更倾向于呆在原出发点，这就是所谓的“弱局域化现象”</p>
<h3 id="载流子热化"><a href="#载流子热化" class="headerlink" title="载流子热化"></a>载流子热化</h3><p>一般来说，弱场输运可以用弛豫时间近似方法处理，使得动量空间的分布函数产生刚性移动，载流子获得净的漂移速度，而保留用热平衡下的分布函数描述载流电子分布，并且载流子具有通常的费米能。载流子热化的情况下来自外加场的输入能量和电势导致粒子的动量，以及直线方向的漂移速度增加，分布函数不再是热平衡分布函数。这时主要的问题是需要找一个新的分布函数。经典的BTE的最强限制是仅限于外场与散射事件之间没有相互影响，或者每一个散射事件都是完全离散的，散射事件或过程之间没有相互影响。这一假设在强场或者纳米结构的几何限制中不再成立。<br>纳米结构的一个关键是输运不能孤立处理。量子动力学方程与边界有强烈的耦合，通过边界，方程与整个环境相耦合。</p>
<h3 id="隧穿现象"><a href="#隧穿现象" class="headerlink" title="隧穿现象"></a>隧穿现象</h3><p>势垒贯穿（简称隧穿）是量子力学中一种独特的现象。固体中隧穿现象，即金属电子的场致发射，也就是电场辅助电子从金属中热发射到真空。带间隧穿是电子通过带隙从固体的一个能带跃迁到另一个能带。共振隧穿概念是指电子的隧穿概率围绕某一个能量值以尖锐的峰值形式出现的隧穿。类似于通过光学滤波器的光强作为波长的函数，形成尖锐的跃迁蜂值。</p>
<h3 id="单电子现象与库伦阻塞"><a href="#单电子现象与库伦阻塞" class="headerlink" title="单电子现象与库伦阻塞"></a>单电子现象与库伦阻塞</h3><p>按照经典物理理论，电子不可能通过绝缘层构成的势垒，隧道结就像一个电容器。把隧道结连接到外电路，隧道结的充电能为Q=CV，V是所加外电压，Q是电极中电子相对于背景正电荷移动而感应出的电荷。人们发现这样小的隧道结势垒两边电荷分布之间的相互作用仍然能够用充电能Q2/2C来描述。<br>考虑到量子效应，电子有可能隧穿通过势垒。隧穿过程与电子在电极内部运动过程不同。电子必须以完整粒子形式隧穿通过势垒。每一次隧穿，电荷变化为一个电子的电量。<br>电子隧穿过程中，充电能的变化可以表示为Ec=e2/2C。电子在电极内部移动感应出的电荷Q可以是电子电量的若干分之一。<br>在一个小系统中，势能的改变有可能大于热能kBT,特别是在低温下。由于单一电荷的传输而引起如此大的静电能的改变可以在费米能处产生一个能量间隙，将阻止电子进入岛中，称为库仑阻塞。</p>
<h2 id="请简述量子点系统的共振隧穿现象以及物理模型"><a href="#请简述量子点系统的共振隧穿现象以及物理模型" class="headerlink" title="请简述量子点系统的共振隧穿现象以及物理模型"></a>请简述量子点系统的共振隧穿现象以及物理模型</h2><h3 id="量子点系统的共振隧穿现象"><a href="#量子点系统的共振隧穿现象" class="headerlink" title="量子点系统的共振隧穿现象"></a>量子点系统的共振隧穿现象</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1620477185733-c4d99ea6-7fa6-4b6e-b121-cfb23adeed44.png#align=left&display=inline&height=226&id=n32kW&margin=%5Bobject%20Object%5D&originHeight=435&originWidth=329&status=done&style=none&width=171"><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1620477186173-b9ea3f0b-2bc9-4718-9095-b9f47d1d39c6.png#align=left&display=inline&height=262&id=nlCWp&margin=%5Bobject%20Object%5D&originHeight=372&originWidth=576&status=done&style=none&width=405"><br>在这种纳米结构中，电子横向运动限制在槽形势阱中，如图6.2所示，势能包括抛物型部分和平坦部分。与传统的大面积的RTD相比较，这种结构称为零维共振隧穿二极管（ODRTD）。<br>高温下ODRTD的I-V特性曲线表现出与2DRTD基本相同的NDC。可是，在较低的温度出现一系列小的电流峰，叠加在NDC上。这些精细结构可以归因于通过量子点3D量子化态的共振隧穿。0D RTD中的隧穿一般远比的RTD复杂<br>在0D RTD中会出现一些特殊的问题，例如<br>     —由于非均匀限制势引起的横向模式混合<br>     —量子阱中电荷量子化<br>     —共振隧穿与库仑阻塞单电子隧穿互相影响<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1620477186536-d4ed987d-e0e6-4883-adfd-11a131637ce3.png#align=left&display=inline&height=320&id=E5eIX&margin=%5Bobject%20Object%5D&originHeight=320&originWidth=481&status=done&style=none&width=481"></p>
<h3 id="Reed零维共振隧穿模型"><a href="#Reed零维共振隧穿模型" class="headerlink" title="Reed零维共振隧穿模型"></a>Reed零维共振隧穿模型</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1620477186775-e28902e3-6fd8-47b5-a3af-92b50fd81d9d.png#align=left&display=inline&height=345&id=pOTE9&margin=%5Bobject%20Object%5D&originHeight=345&originWidth=531&status=done&style=none&width=531"><br>Reed引入两个量子数y和y’,分别描述电子在发射极和量子阱中的横向运动。<br>这样电子在这两个区域中的运动的能量近似表示为εy+Ekz和εy’+Ekz0，其中εy是第个横向模式的能量，Ekz是能量的z分量（=ħ2kz2/2m*)，z方向是沿着半导体异质结构生长方向。 Ekz0是量子阱中最低准束缚态的能量。<br>每当阱中一个能级与发射极一个能级对准，电子通过这一对能级隧穿到达集电极，产生一个共振电流峰。<br>如果y= y’，隧穿保持横向模式守恒（横向动量守恒），如果不是这样，则为横向模式不守恒隧穿。Reed等证实量子阱能级与发射极能级差是所加偏压的函数，并将它们与观察到的峰电压比较。计算结果与实验结果一致，这一事实表明横向模式不守恒隧穿对电流有贡献。</p>
<h2 id="请简述单电荷现象产生条件以及单电子系统的基本结构及类型"><a href="#请简述单电荷现象产生条件以及单电子系统的基本结构及类型" class="headerlink" title="请简述单电荷现象产生条件以及单电子系统的基本结构及类型"></a>请简述单电荷现象产生条件以及单电子系统的基本结构及类型</h2><h3 id="单电荷现象产生的条件"><a href="#单电荷现象产生的条件" class="headerlink" title="单电荷现象产生的条件"></a>单电荷现象产生的条件</h3><p>在两个电极之间有一个被称为岛(island)的孤立金属单元，三个导体之间有间隙（或绝缘体）。从源极到漏极的电荷输运必须通过岛。<br>假设通过源极与岛及岛与漏极之间的绝缘间隙的电荷输运是通过量子隧穿完成的，而且整个输运过程进行的很快，可以认为每一次仅有一个电子通过绝缘间隙。<br>相继通过一个特定隧道结的隧穿事件是彼此不相关的，并且构成Poisson过程。电子在从源极到漏极的旅行过程中，岛中电荷的变化必须是载流子电荷的量值。<br>对于普通的电子器件载流子的电量是一个非常小的量。可是，对于足够小的岛，当岛中增加一个过剩电荷，岛的电势升高就足以明显使隧穿概率减小。这种反馈效应的存在是在几十年前就提出了。<br>在这样纳米尺度的隧道结系统中，可以产生相当大的库仑间隙(Coulomb gap)。<br>应用这种结构可以研究栅极电压控制的单个电子电荷精度的电流，即单个电荷在受控状态下从一个岛到另一个岛的传输，<br>该现象背后的机制是利用了系统中一部分电荷与另一部分电荷之间库仑作用能的反馈效应。更普遍的情况下，这种反馈效应称为是单电子隧穿效应。这种现象可以在金属和半导体纳米结构中以电子或空穴的形式进行单电荷传输。</p>
<h3 id="产生单电子隧穿效应的条件"><a href="#产生单电子隧穿效应的条件" class="headerlink" title="产生单电子隧穿效应的条件"></a>产生单电子隧穿效应的条件</h3><p><strong>条件—</strong>：系统必须具有一个库仑岛，它仅通过隧穿势垒与其他导体相连接。隧道结“电阻”远大于电阻量子RQ=h/e2~25.8kΩ，即RT&gt;&gt;RQ。隧穿电阻是一个唯象的物理量。它定义为当电极两边加载的电压V固定时，V与电子通过势垒的隧穿率γ的比，即：γ=V/eRT。<br><strong>条件二</strong>：岛足够小，其库仑能满足EC&gt;kBT<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1620477187069-05673eec-edb0-4442-aa4f-a9065f1266c3.png#align=left&display=inline&height=191&id=g3YHv&margin=%5Bobject%20Object%5D&originHeight=236&originWidth=514&status=done&style=none&width=417"></p>
<h3 id="单电子系统的基本结构"><a href="#单电子系统的基本结构" class="headerlink" title="单电子系统的基本结构"></a>单电子系统的基本结构</h3><p>目前研究的能产生单电子现象的系统主要有两种类型。一种是金属一绝缘体结构类型；另一种是半导体二维电于气结构类型。当前大多数单电子实验是基于第一种类型的结构。<br>目前大多数金属一绝缘体单电子结构是用金属Al薄膜制造，利用光刻制造出岛的形状并且用氧化层势垒分隔开。在此情形下，电子气被限制在一个小的区域里，并通过厚度约为100mm的氧化层势垒耦合到外电路。隧道结的电容构成系统电容的主要部分。这种系统也是人们研究库柏对电荷效应的结构。<br>第二种研究单电子效应的实验系统是利用肖特基栅将GaAs/AlGaAs异质结构二维电子气限制在小的区域（岛）中。</p>
<h2 id="何谓介观？分析其与宏观、微观的区别。分析介观导体与欧姆导体的区别"><a href="#何谓介观？分析其与宏观、微观的区别。分析介观导体与欧姆导体的区别" class="headerlink" title="何谓介观？分析其与宏观、微观的区别。分析介观导体与欧姆导体的区别"></a>何谓介观？分析其与宏观、微观的区别。分析介观导体与欧姆导体的区别</h2><h3 id="介观"><a href="#介观" class="headerlink" title="介观"></a>介观</h3><p>介观是介于宏观与微观之间的一种体系。处于介观的物体在尺寸上已是宏观的，因而具有宏观体系的特点；但是由于其中电子运动的相干性，会出现一系列新的与量子力学相位相联系的干涉现象, 这又与微观体系相似，故称“介观”。</p>
<h3 id="介观、微观、宏观的区别"><a href="#介观、微观、宏观的区别" class="headerlink" title="介观、微观、宏观的区别"></a>介观、微观、宏观的区别</h3><p>微观尺度是原子核、粒子物理学研究原子核、基本粒子及与之相应的场的尺度。微观世界的各层次都具有波粒二象性，服从量子力学规律。<br>通常被认为是宏观的长度尺度，大致在1毫米至1公里之间。宏观体系的特点是物理量具有自平均性：即可以把宏观物体看成是由许多的小块所组成，每一小块是统计独立的，整个宏观物体所表现出来的性质是各小块的平均值，如果减小宏观物体的尺寸，只要还是足够大，测量的物理量，例如电导率，和系统的平均值的差别就很小。<br>宏观世界容易观察的物质层次。宏观世界一般服从经典力学规律，但是不同质的宏观世界具有不同的运行规律。<br>宏观是具有牛顿力学特征的物质存在状态，微观符合是量子力学规律的存在状态，而介观由于其具有量子力学和牛顿力学的双重特征，部分物质可能出于宏观和介观、介观和微观的双重状态。<br>介观尺度就是指介于宏观和微观之间的尺度；一般认为它的尺度在纳米和毫米之间。物体的尺寸具有宏观大小，但具有那些我们原来认为只能在微观世界中才能观察到的许多物理现象。介观粒子仍属宏观粒子，然而这种宏观粒子在低温条件下的实验结果，却表现出了微观粒子才有的量子效应，这种呈现出微观物理效应的宏观系统叫介观系统。它所服从的是介观物理学的规律，这是介乎微观与宏观之间的第三种规律──介观规律。</p>
<h3 id="介观导体与欧姆导体的区别"><a href="#介观导体与欧姆导体的区别" class="headerlink" title="介观导体与欧姆导体的区别"></a>介观导体与欧姆导体的区别</h3><p>欧姆定律能够成立的导体称为欧姆导体，欧姆导体的长度远大于电子的德布罗意波长、平均自由程、相位弛豫长度。导体中电子在电场作用下的运动不断受到各种散射机制的散射作用，电子的迁移过程是扩散过程。<br>介观(mesoscopic)导体表示介于宏观与微观之间的导体（1nm~1um），远大于像原子这样的微观客体，但是又不能大到成为欧姆型导体，介观现象和效应是波粒二象性与空间尺度限制下共同导致的。介观导体不遵从欧姆定律，而是会出现纳米结构的新现象例如弹道输运、相位干涉、普适电导涨落、弱局域化、载流子热化、隧穿现象以及单电子现象与库伦阻塞。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.yuque.com/attachments/yuque/0/2021/pdf/12924220/1620477504928-0fec869a-09a7-43c4-b198-b1b5e5ff8e07.pdf?_lake_card=%7B%22src%22:%22https://www.yuque.com/attachments/yuque/0/2021/pdf/12924220/1620477504928-0fec869a-09a7-43c4-b198-b1b5e5ff8e07.pdf%22,%22name%22:%22%E7%BA%B3%E7%B1%B3%E7%94%B5%E5%AD%90%E5%AD%A6%5B%E6%9D%9C%E7%A3%8A%5D.pdf%22,%22size%22:19843006,%22type%22:%22application/pdf%22,%22ext%22:%22pdf%22,%22status%22:%22done%22,%22taskId%22:%22u864a2eca-5b6f-4fb4-8c25-42a8224d57b%22,%22taskType%22:%22upload%22,%22id%22:%22u23dd058f%22,%22card%22:%22file%22%7D">纳米电子学[杜磊].pdf</a><br><a href="https://www.yuque.com/attachments/yuque/0/2021/ppt/12924220/1620477516055-15f3ac95-5b0c-4842-b795-6b3006894416.ppt?_lake_card=%7B%22src%22:%22https://www.yuque.com/attachments/yuque/0/2021/ppt/12924220/1620477516055-15f3ac95-5b0c-4842-b795-6b3006894416.ppt%22,%22name%22:%22%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%BB%AA%E8%AE%BA.ppt%22,%22size%22:14362112,%22type%22:%22application/vnd.ms-powerpoint%22,%22ext%22:%22ppt%22,%22status%22:%22done%22,%22taskId%22:%22ub452d132-d018-4256-9f02-dab02861801%22,%22taskType%22:%22upload%22,%22id%22:%22ua463fe1c%22,%22card%22:%22file%22%7D">第一章绪论.ppt</a><br><a href="https://www.yuque.com/attachments/yuque/0/2021/pptx/12924220/1620477518078-85bc04d9-1461-479d-a55b-6217c031029b.pptx?_lake_card=%7B%22src%22:%22https://www.yuque.com/attachments/yuque/0/2021/pptx/12924220/1620477518078-85bc04d9-1461-479d-a55b-6217c031029b.pptx%22,%22name%22:%22%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%85%B1%E6%8C%AF%E9%9A%A7%E7%A9%BF%E7%8E%B0%E8%B1%A1%E4%B8%8E%E5%99%A8%E4%BB%B6.pptx%22,%22size%22:5412250,%22type%22:%22application/vnd.openxmlformats-officedocument.presentationml.presentation%22,%22ext%22:%22pptx%22,%22status%22:%22done%22,%22taskId%22:%22u822bd4f3-1a26-4787-8101-04e8bf79a49%22,%22taskType%22:%22upload%22,%22id%22:%22udc94e1b1%22,%22card%22:%22file%22%7D">第二章共振隧穿现象与器件.pptx</a><br><a href="https://www.yuque.com/attachments/yuque/0/2021/ppt/12924220/1620477528756-b30676eb-059f-4cad-8b86-02821cde4a98.ppt?_lake_card=%7B%22src%22:%22https://www.yuque.com/attachments/yuque/0/2021/ppt/12924220/1620477528756-b30676eb-059f-4cad-8b86-02821cde4a98.ppt%22,%22name%22:%22%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%8D%95%E7%94%B5%E5%AD%90%E5%99%A8%E4%BB%B6%E5%92%8C%E7%8E%B0%E8%B1%A1.ppt%22,%22size%22:11172352,%22type%22:%22application/vnd.ms-powerpoint%22,%22ext%22:%22ppt%22,%22status%22:%22done%22,%22taskId%22:%22u064d79f5-b49b-41e7-8094-c78db86f284%22,%22taskType%22:%22upload%22,%22id%22:%22u9ffa0476%22,%22card%22:%22file%22%7D">第三章单电子器件和现象.ppt</a><br><a href="https://www.yuque.com/attachments/yuque/0/2021/ppt/12924220/1620477531020-2dc80ca7-8e56-4312-bbf9-6f350545d9c4.ppt?_lake_card=%7B%22src%22:%22https://www.yuque.com/attachments/yuque/0/2021/ppt/12924220/1620477531020-2dc80ca7-8e56-4312-bbf9-6f350545d9c4.ppt%22,%22name%22:%22%E7%AC%AC%E4%BA%94%E7%AB%A0%E5%8D%8A%E5%AF%BC%E4%BD%93%E9%87%8F%E5%AD%90%E7%82%B9%E5%99%A8%E4%BB%B6.ppt%22,%22size%22:9416192,%22type%22:%22application/vnd.ms-powerpoint%22,%22ext%22:%22ppt%22,%22status%22:%22done%22,%22taskId%22:%22ua30e25b3-6688-4f1f-9afe-90200381ac2%22,%22taskType%22:%22upload%22,%22id%22:%22ub23f2224%22,%22card%22:%22file%22%7D">第五章半导体量子点器件.ppt</a></p>
]]></content>
      <categories>
        <category>笔记篇</category>
        <category>器件</category>
      </categories>
      <tags>
        <tag>器件</tag>
      </tags>
  </entry>
  <entry>
    <title>SV系统验证（7）——随机约束</title>
    <url>/2021/05/02/SV%E7%B3%BB%E7%BB%9F%E9%AA%8C%E8%AF%81%EF%BC%887%EF%BC%89%E2%80%94%E2%80%94%E9%9A%8F%E6%9C%BA%E7%BA%A6%E6%9D%9F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>随着设计越来越大，要产生一个完整的激励来测试功能也变得越来越困难。定向激励的测试方法早已经<strong>无法满足</strong>检查功能完整性的要求。</li>
<li>SoC的集成度提高带来的模块之间交互的<strong>复杂度也是指数攀升</strong>，这就使得<strong>无法预测</strong>接下来用户使用过程中会发生什么样的状况。</li>
<li>随机-约束，两个词组合在一起就构成了目前<strong>动态仿真验证</strong>的主流方法。</li>
<li>随机约束测试（CRT，Constrained-Random Test）即能够产生你感兴趣的、你想不到的的测试向量，通过回归测试、替随机种子的方式来提高单位测试用例的覆盖率收集效率。</li>
<li>随机测试带来的<strong>额外负担是环境的复杂度会提高</strong>，因为从环境组件上考虑不再只需要发送激励的组件，而且还包括<strong>监测器、比较器</strong>等。</li>
<li>随机测试带来的<strong>环境复杂度</strong>还包括由于对环境复用和测试复用带来的组件封装要求，这会使得代码量加大。</li>
<li>这种额外的代码量、环境集成要求也随之带来了<strong>更加灵活</strong>、更<strong>易集成复用</strong>的验证环境。</li>
</ul>
<h2 id="产生随机数"><a href="#产生随机数" class="headerlink" title="产生随机数"></a>产生随机数</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> stim; </span><br><span class="line">  <span class="keyword">bit</span> [<span class="number">15</span>:<span class="number">0</span>] addr; </span><br><span class="line">  <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] data; </span><br><span class="line">  <span class="keyword">function</span>  <span class="keyword">bit</span> gen_stim(); </span><br><span class="line">    <span class="keyword">bit</span> success, rd_wr;    </span><br><span class="line">    success = randomize(addr, data, rd_wr); <span class="comment">//call std::randomize  使用系统函数调用随机数库</span></span><br><span class="line">    <span class="keyword">return</span> rd_wr;</span><br><span class="line">  <span class="keyword">endfunction</span> </span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"><span class="comment">//通过 系统函数std::randomize() 对一些变量即可完成随机化或者理解为产生随机数并赋予这些变量。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//我们还可以通过其它一些与随机数生成有关的系统函数来产生。</span></span><br><span class="line">$urandom();                        <span class="comment">//可以生成一个32位的无符号随机数。</span></span><br><span class="line">$urandom_range(maxval, minval=<span class="number">0</span>);  <span class="comment">//产生在max和min之间的无符号随机数</span></span><br></pre></td></tr></table></figure>
<h2 id="约束随机变量"><a href="#约束随机变量" class="headerlink" title="约束随机变量"></a>约束随机变量</h2><ul>
<li>以上我们<strong>独立地生成一些随机数</strong>，在面向DUT的随机激励发生过程中，为了符合协议、满足测试需求，我们还需要<strong>添加一些约束</strong>。这些“约束”会使得变量朝着希望他们变化的方向去随机。不但如此，这些约束也会对变量与变量之间的关系生效。</li>
<li>我们需要一个“载体“去容纳这些变量以及它们之间的约束这个“载体”即是<strong>类（在SV中只能是类）</strong>，而类的成员变量均可声明为“<strong>随机</strong>“属性，用<strong>rand或者randc</strong>来表示。</li>
</ul>
<h3 id="随机变量"><a href="#随机变量" class="headerlink" title="随机变量"></a>随机变量</h3><ul>
<li><p><strong>任何类中的整型</strong>（bit/byte/int）变量都可以声明为rand/randc。</p>
</li>
<li><p><strong>定长数组、动态数组、关联数组和队列</strong>都可以声明为rand/randc，可以对动态数组和队列的<strong>长度加以约束</strong>。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">7</span>：<span class="number">0</span>] len;</span><br><span class="line"><span class="keyword">rand</span> <span class="keyword">integer</span> data[]</span><br><span class="line"><span class="keyword">constraint</span> db&#123;data<span class="variable">.size</span>==len;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>指向对象的<strong>句柄成员</strong>，也可以声明为rand（<strong>不能被声明为randc</strong>），随机时该句柄指向<strong>对象中的随机变量也会一并被随机</strong>。</p>
</li>
</ul>
<h3 id="带有约束随机的类"><a href="#带有约束随机的类" class="headerlink" title="带有约束随机的类"></a>带有约束随机的类</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Packet;</span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] src, dst, data[<span class="number">8</span>]; <span class="comment">//The random variables </span></span><br><span class="line">  <span class="keyword">randc</span> <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] kind;</span><br><span class="line">  <span class="keyword">constraint</span> cstr&#123;src&gt;<span class="number">10</span>; </span><br><span class="line">                  src&lt;<span class="number">15</span>;&#125;         <span class="comment">// Limit the values for src </span></span><br><span class="line">  <span class="keyword">function</span> print();</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;src is %0d\n dst is %0d\n kind is %0d\n data is %p&quot;</span>,src, dst, kind, data);</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line">Packet p; </span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span> </span><br><span class="line">  p=<span class="keyword">new</span>();          <span class="comment">//Create a packet </span></span><br><span class="line">  <span class="built_in">$display</span>(<span class="string">&quot;before randomize&quot;</span>);</span><br><span class="line">  p<span class="variable">.print</span>;</span><br><span class="line">  p<span class="variable">.randomize</span>()     <span class="comment">//如果没有指定参数，那么值随机化含有rand属性的变量，如果指定了，按指定参数随机化</span></span><br><span class="line">  <span class="built_in">$display</span>(<span class="string">&quot;after randomize&quot;</span>);</span><br><span class="line">  p<span class="variable">.print</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//非组合型结构体可以声明为rand，非组合型的成员可以声明rand/randc。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  <span class="keyword">randc</span> <span class="keyword">int</span> addr = <span class="number">1</span>+constant;       <span class="comment">//非组合型的成员</span></span><br><span class="line">  <span class="keyword">int</span> crc;</span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">byte</span> data[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;   <span class="comment">//非组合型的成员</span></span><br><span class="line">&#125; header;</span><br><span class="line">  <span class="keyword">rand</span> header h1;            <span class="comment">//非组合型结构体，如果需要在类里声明结构体，声明时前面要添加rand</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加额外约束（临时约束）    </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] src;</span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] dst; </span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] data[<span class="number">4</span>]; </span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] kind;</span><br><span class="line">&#125; packet_t;</span><br><span class="line">packet_t pkt;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">  std::randomize(pkt) <span class="keyword">with</span> (src&gt;<span class="number">10</span>, src&lt;<span class="number">15</span>); <span class="comment">//添加额外约束（临时约束）</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="修饰符rand和randc"><a href="#修饰符rand和randc" class="headerlink" title="修饰符rand和randc"></a>修饰符rand和randc</h3><ul>
<li>对于rand修饰符，表示在可生成的范围内，每个值的可能性相同的（每次随机都从整个范围内随机选取）。</li>
<li>对于randc修饰符，它的值将会随机并且遍历其可取值范围（在整个范围内，每个数只可能出现一次）。<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] y;</span><br></pre></td></tr></table></figure>
<img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1620115797121-35a9bb65-9640-4afb-8304-0123b5a6c40b.png#align=left&display=inline&height=145&id=bPs0J&margin=%5Bobject%20Object%5D&name=image.png&originHeight=145&originWidth=428&size=21052&status=done&style=none&width=428" alt="image.png"></li>
</ul>
<h2 id="约束块"><a href="#约束块" class="headerlink" title="约束块"></a>约束块</h2><ul>
<li>有用的激励不仅仅是随机值，变量之间也有着<strong>相互关系</strong>。</li>
<li>没有约束的随机变量会包含许多<strong>无效的和非法</strong>的值，这会使得有效激励的产生变得低效。</li>
<li>需要用包含一个或多个约束表达式的<strong>约束块定义这些相互关系</strong>。</li>
<li>约束块支持整形通过set操作符来设置它们的可取值范围。</li>
<li>除了成员集合设置（以下代代码均声明在类中），约束块也支持设置可取值的同时也为其设置随机时的权重。<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">rand</span> <span class="keyword">integer</span> x,y,z; </span><br><span class="line"><span class="keyword">constraint</span> cl &#123;x <span class="keyword">inside</span> &#123;<span class="number">3</span>, <span class="number">5</span>, [<span class="number">9</span>:<span class="number">15</span>], [<span class="number">24</span>:<span class="number">32</span>], [y:<span class="number">2</span>*y], z&#125;;&#125;  <span class="comment">//可取范围：3、5、9-15、24-32、y-2y、z</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">rand</span> <span class="keyword">integer</span> a,b,c; </span><br><span class="line"><span class="keyword">constraint</span> c2 &#123;a <span class="keyword">inside</span> &#123;b,c&#125;;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">integer</span> fives[<span class="number">4</span>]=&#x27;&#123;<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">20</span>&#125;; </span><br><span class="line"><span class="keyword">rand</span> <span class="keyword">integer</span> v; </span><br><span class="line"><span class="keyword">constraint</span> c3&#123;v <span class="keyword">inside</span> &#123;fives&#125;;&#125;             <span class="comment">//可取范围：five数组的成员</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="权重分布"><a href="#权重分布" class="headerlink" title="权重分布"></a>权重分布</h3><blockquote>
<p>对于<strong>：=操作符</strong>，它们表示每一个值的权重是相同的。<br>对于<strong>：/操作符</strong>，它们表示权重会<strong>平均</strong>分配到每一个值。</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//操作符控制权重分布</span></span><br><span class="line">x在<span class="number">100</span>, <span class="number">101</span>, <span class="number">102</span>, <span class="number">200</span>和<span class="number">300</span>的权重是<span class="number">1</span>-<span class="number">1</span>-<span class="number">1</span>-<span class="number">2</span>-<span class="number">5</span></span><br><span class="line">xdist &#123;[<span class="number">100</span>：<span class="number">102</span>]：=<span class="number">1</span>, <span class="number">200</span>：=<span class="number">2</span>, <span class="number">300</span>：=<span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">x在<span class="number">100</span>, <span class="number">101</span>, <span class="number">102</span>, <span class="number">200</span>和<span class="number">300</span>的权重是<span class="number">1</span>/<span class="number">3</span>-<span class="number">1</span>/<span class="number">3</span>-<span class="number">1</span>/<span class="number">3</span>-<span class="number">2</span>-<span class="number">5</span></span><br><span class="line">xdist &#123;[<span class="number">100</span>：<span class="number">102</span>]:/<span class="number">1</span>, <span class="number">200</span>：=<span class="number">2</span>, <span class="number">300</span>:=<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="唯一标识"><a href="#唯一标识" class="headerlink" title="唯一标识"></a>唯一标识</h3><ul>
<li><strong>unique</strong>可以用来约束一组变量，使得其在随机后变量之间<strong>不会有相同</strong>的数值。<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">rand</span> <span class="keyword">byte</span> a[<span class="number">5</span>]; </span><br><span class="line"><span class="keyword">rand</span> <span class="keyword">byte</span> b; </span><br><span class="line"><span class="keyword">rand</span> <span class="keyword">byte</span> excluded; </span><br><span class="line"><span class="keyword">constraint</span> u &#123;<span class="keyword">unique</span> &#123;b, a[<span class="number">2</span>:<span class="number">3</span>], excluded&#125;;&#125;   <span class="comment">//a[2], a[3], b和excluded在随机化之后将包含不相同的数值。</span></span><br><span class="line"><span class="keyword">constraint</span> exclusion &#123;excluded==<span class="number">5</span>;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="条件约束"><a href="#条件约束" class="headerlink" title="条件约束"></a>条件约束</h3><ul>
<li>可以<strong>使用if-else或者 -&gt;操作符</strong>来表示条件约束。<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">mode==little -&gt; len&lt;<span class="number">10</span>；</span><br><span class="line">mode==big -&gt; len&gt;<span class="number">100</span>；</span><br><span class="line"></span><br><span class="line"><span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>]a,b; </span><br><span class="line"><span class="keyword">constraint</span> c&#123;(a==<span class="number">0</span>)-&gt;(b==<span class="number">1</span>);&#125;</span><br><span class="line"><span class="keyword">if</span>(mode==little)</span><br><span class="line">len&lt;<span class="number">10</span>; <span class="keyword">else</span> <span class="keyword">if</span>(mode==big)</span><br><span class="line">len&gt;<span class="number">100</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="迭代约束"><a href="#迭代约束" class="headerlink" title="迭代约束"></a>迭代约束</h3><ul>
<li><strong>foreach</strong>可以用来迭代约束数组中的元素，这些数组可以是长数组、动态数组、关联数组或者队列。<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> C; </span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">byte</span> A[]; </span><br><span class="line">  <span class="keyword">constraint</span> C1 &#123; <span class="keyword">foreach</span> (A[i]) A[i] <span class="keyword">inside</span>&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>&#125;; &#125;   <span class="comment">//A[]的成员在&#123;2、4、8、16&#125;中选取</span></span><br><span class="line">  <span class="keyword">constraint</span> C2 &#123; <span class="keyword">foreach</span> (A[j]) A[j]&gt;<span class="number">2</span>*j; &#125;         <span class="comment">//未限定A[]的size，则size默认是0，成员大小也是0</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constraint</span> &#123;</span><br><span class="line">  &#123; <span class="keyword">foreach</span> (A[i]) A[i] <span class="keyword">inside</span>&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">16</span>&#125;;  </span><br><span class="line">    <span class="keyword">foreach</span> (A[j]) A[j]&gt;<span class="number">2</span>*j; </span><br><span class="line">   A<span class="variable">.size</span>()&lt;<span class="number">100</span> &#125;                     <span class="comment">//限定数组大小之后，用VCS可以仿真出来，questsim无法仿真（不同仿真器底层不同）</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//数组缩减的方法做迭代约束</span></span><br><span class="line"><span class="keyword">class</span> C; </span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] A[]; </span><br><span class="line">  <span class="keyword">constraint</span> cl&#123;A<span class="variable">.size</span>()==<span class="number">5</span>;&#125;</span><br><span class="line">  <span class="keyword">constraint</span> c2&#123;A<span class="variable">.sum</span>()&lt;<span class="number">1000</span>;&#125; </span><br><span class="line"><span class="keyword">endclass</span> </span><br><span class="line">  A[<span class="number">0</span>]+A[<span class="number">1</span>]+A[<span class="number">2</span>]+A[<span class="number">3</span>]+A[<span class="number">4</span>]&lt;<span class="number">1000</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><ul>
<li>有时候在一些表达式中无法简单地来表述约束，可以在约束块中调用该函数来描述约束。<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>                             <span class="comment">//例如要计算合并数组中的1</span></span><br><span class="line">  <span class="keyword">int</span> count_ones(<span class="keyword">bit</span> [<span class="number">9</span>:<span class="number">0</span>]w); </span><br><span class="line">  <span class="keyword">for</span>(count_ones=<span class="number">0</span>; W!=<span class="number">0</span>; W=W&gt;&gt;<span class="number">1</span>)</span><br><span class="line">    count_ones +=w &amp;<span class="number">1&#x27;b1</span>;  </span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">constraint</span> C1 &#123;length ==count_ones)v);&#125;  <span class="comment">//约束中调用函数计数</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="软约束"><a href="#软约束" class="headerlink" title="软约束"></a>软约束</h3><ul>
<li>在没有soft描述时的约束，我们称之为硬约束，而带有<strong>soft描述是软约束</strong>。</li>
<li>软约束用来指定变量的默认值和权重。</li>
<li>如果用户在使用时，指定了外部约束对同一个变量做二次约束，用户定义了子类，也对同一个变量做二次约束时，那么硬约束可以软约束，并且不会导致随机数产生的失败。<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Packet; </span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">int</span> length; </span><br><span class="line">  <span class="keyword">constraint</span> deflt &#123;<span class="keyword">soft</span> length <span class="keyword">inside</span> &#123;<span class="number">32</span>,<span class="number">1024</span>&#125;;&#125;  <span class="comment">//软约束 长度可选32和1024  如果有多个软约束采用就近原则</span></span><br><span class="line"><span class="keyword">endclass</span> </span><br><span class="line">Packet p=<span class="keyword">new</span>(); </span><br><span class="line">p<span class="variable">.randomize</span>() <span class="keyword">with</span> &#123;length==<span class="number">1512</span>;&#125;          <span class="comment">//硬约束 长度为1512 优先级高于软约束</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="内嵌约束"><a href="#内嵌约束" class="headerlink" title="内嵌约束"></a>内嵌约束</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> C1; </span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">integer</span> x; </span><br><span class="line"><span class="keyword">endclass</span> </span><br><span class="line"><span class="keyword">class</span> C2; </span><br><span class="line">  <span class="keyword">integer</span> x; </span><br><span class="line">  <span class="keyword">integer</span> y; </span><br><span class="line">  <span class="keyword">task</span> doit(Cl f, <span class="keyword">integer</span> x, <span class="keyword">integer</span> z); </span><br><span class="line">    <span class="keyword">int</span> result; </span><br><span class="line">    result = f<span class="variable">.randomize</span>() <span class="keyword">with</span> &#123;x&lt;y+z;&#125;;    <span class="comment">//x采取就近原则（加上this也是指向C1），指向C1类型的对象f中的x</span></span><br><span class="line">  <span class="keyword">endtask</span>                                      <span class="comment">//如果需要指向C2中的x需要加上限定词local</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以上代码指向不明确不推荐重名，以下代码为较好的格式</span></span><br><span class="line"><span class="keyword">class</span> C; </span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">integer</span> x; </span><br><span class="line"><span class="keyword">endclass</span> </span><br><span class="line"><span class="keyword">function</span> <span class="keyword">int</span> F(C obj, <span class="keyword">integer</span> y); </span><br><span class="line">  F=obj<span class="variable">.randomize</span>.() <span class="keyword">with</span> (x)&#123;x&lt;y;&#125;; </span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>
<h3 id="local域指向"><a href="#local域指向" class="headerlink" title="local域指向"></a>local域指向</h3><ul>
<li>之前在使用内嵌约束随机时，对于<strong>同名的变量处在不同的域</strong>中可能会出现指向模糊的情况，之前我们已经给出了一种方法。</li>
<li>接下来我们可以通过<strong>local:：的域索引方式</strong>来明确随机变量的指即local:：指向的变量会在包含randomize（）方法的对象中。<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> C; </span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">integer</span> x; </span><br><span class="line"><span class="keyword">endclass</span> </span><br><span class="line"><span class="keyword">function</span> <span class="keyword">int</span> F(C obj, <span class="keyword">integer</span> x=<span class="number">20</span>); </span><br><span class="line">  F=obj<span class="variable">.randomize</span>() <span class="keyword">with</span> &#123;x &lt; <span class="keyword">local</span>::x;&#125;;    <span class="comment">//索引当前文本域中的x，即function中的x</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="随机控制"><a href="#随机控制" class="headerlink" title="随机控制"></a>随机控制</h2><ul>
<li>rand_mode可以<strong>使能或者禁止</strong>随机变量，当随机数被禁止时，同普通变量一样，不参与随机化。<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Packet;</span><br><span class="line"><span class="keyword">rand</span> <span class="keyword">integer</span> source value, dest value;</span><br><span class="line">... other declarations </span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ret; </span><br><span class="line">Packet packet a=<span class="keyword">new</span>;</span><br><span class="line"><span class="comment">//关闭所有变量的随机化 </span></span><br><span class="line">packet a<span class="variable">.rand_mode</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使能souce_value的随机化 </span></span><br><span class="line">packet a<span class="variable">.source_value</span><span class="variable">.rand_mode</span>(<span class="number">1</span>); </span><br><span class="line">ret=packet_a<span class="variable">.dest_value</span><span class="variable">.rand_mode</span>();</span><br><span class="line"></span><br><span class="line">randomize(source_value) <span class="comment">//使用randomize，不管变量在定义的时候有没有rand属性，传入参数都可以直接随机化，并且原来定义时候的rand属性在有参数之后不起作用。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="约束控制"><a href="#约束控制" class="headerlink" title="约束控制"></a>约束控制</h2><ul>
<li>类似于随机控制，一些约束块或者某个类的约束块集合都可以使用constraint_mode实现单个控制或者集体控制。<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Packet;</span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">integer</span> source value; </span><br><span class="line">  <span class="keyword">constraint</span> filterl &#123;source value&gt;<span class="number">2</span>*m;&#125;</span><br><span class="line"><span class="keyword">endclass</span> </span><br><span class="line"><span class="keyword">function</span> <span class="keyword">integer</span> toggle_rand(Packet p); <span class="comment">//实现反转</span></span><br><span class="line">  <span class="keyword">if</span>(p<span class="variable">.filterl</span><span class="variable">.constraint_mode</span>())</span><br><span class="line">    p<span class="variable">.filterl</span><span class="variable">.constraint_mode</span>(<span class="number">0</span>);  </span><br><span class="line">  <span class="keyword">else</span> p<span class="variable">.filterl</span><span class="variable">.constraint_mode</span>(<span class="number">1</span>); </span><br><span class="line">    toggle_rand=p<span class="variable">.randomize</span>();</span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="内嵌变量控制"><a href="#内嵌变量控制" class="headerlink" title="内嵌变量控制"></a>内嵌变量控制</h2><ul>
<li>在使用类的随机化函数randomize（）时，如果<strong>伴有参数</strong>，那么只会随机化这些变量（参数优先级高于声明优先级），而其余变量无论是否之前被声明为rand/randc，<strong>都将不会参与到随机化当中</strong>。<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> CA; </span><br><span class="line">  <span class="keyword">rand</span> <span class="keyword">byte</span> x,y; </span><br><span class="line">  <span class="keyword">byte</span> v,w; </span><br><span class="line">  <span class="keyword">constraint</span> cl&#123;x&lt;v &amp;&amp; y&gt;w;&#125;; </span><br><span class="line">  <span class="keyword">endclass</span></span><br><span class="line">CA a=<span class="keyword">new</span>; </span><br><span class="line">a<span class="variable">.randomize</span>();   <span class="comment">//随机变量:x, y</span></span><br><span class="line">a<span class="variable">.randomize</span>(x);  <span class="comment">//随机变量:x </span></span><br><span class="line">a<span class="variable">.randomize</span>(v,w);<span class="comment">//随机变量:v, w</span></span><br><span class="line">a<span class="variable">.randomize</span>(w,x);<span class="comment">//随机变量:w,x</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="思考问题"><a href="#思考问题" class="headerlink" title="思考问题"></a>思考问题</h2><ul>
<li>随机测试相比于定向测试，就你目前的认识，你认为有哪些优缺点？</li>
</ul>
]]></content>
      <categories>
        <category>笔记篇</category>
        <category>数字验证</category>
      </categories>
      <tags>
        <tag>SystemVerilog</tag>
      </tags>
  </entry>
  <entry>
    <title>SV系统验证（6）——类的封装、继承和包</title>
    <url>/2021/04/18/SV%E7%B3%BB%E7%BB%9F%E9%AA%8C%E8%AF%81%EF%BC%886%EF%BC%89%E2%80%94%E2%80%94%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E5%92%8C%E5%8C%85/</url>
    <content><![CDATA[<h2 id="类的概述"><a href="#类的概述" class="headerlink" title="类的概述"></a>类的概述</h2><blockquote>
<p>类的三要素：类的封装、类的继承、类的多态</p>
</blockquote>
<ul>
<li>类是一种可以包含<strong>数据</strong>和<strong>方法</strong>（function，task）的类型。</li>
<li>例如一个数据包，可能被定义为一个类，类中可以包含指令、地址、队列ID、时间戳和数据等成员。</li>
<li><strong>packet</strong>这个类可以在其中对这些数据做<strong>初始化</strong>，设置指令，读取该类的状态以及检查队列ID。</li>
<li>每一个packet类例化的具体对象其数据成员都可能不相同，然而<strong>packet类作为描述这些数据的抽象类型</strong>，<strong>将其对应的数据成员和操作这些数据成员的方法都定义在其中</strong>。</li>
</ul>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul>
<li>类（class）：包含成员变量和成员方法。</li>
<li>对象（object）：类在例化后的实例。</li>
<li>句柄（handle）：指向对象的<strong>指针</strong>。</li>
<li>原型（prototype）：程序的声明部分，包含程序名、返回类型和参数列表。</li>
</ul>
<h2 id="构建函数"><a href="#构建函数" class="headerlink" title="构建函数"></a>构建函数</h2><ul>
<li>SV并不像C++语言一样要求复杂的存储空间开辟和销毁的而是采用了像Java一样空间自动开辟和回收的手段。</li>
<li>因此SV的类在定义时，只需要定义构建函数（constructor）而不需要定义析构函数（destructor）。当全局没有任何一个句柄指向它时类的空间就<strong>自动释放</strong>了</li>
<li>类在定义时，需要定义构建函数，如果未定义，则系统会自助定义一个空的构建函数new（）（没有形式参数，函数体亦为空）</li>
<li>对象在创建时（对象天然是动态的，仿真之后才有值），需要先声明再例化，同时进行亦可。<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> packet_c;      <span class="comment">//类的声明</span></span><br><span class="line">  <span class="keyword">integer</span> command;</span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">int</span> inival);</span><br><span class="line">    command = inival;    <span class="comment">//new函数没有返回值，默认每个类中都有new函数，主要为了开辟空间和初始化句柄</span></span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> packet_m;      <span class="comment">//模块声明</span></span><br><span class="line">  <span class="keyword">integer</span> command;</span><br><span class="line"><span class="keyword">endmodule</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;         <span class="comment">//结构体声明</span></span><br><span class="line">  <span class="keyword">integer</span> command;</span><br><span class="line">&#125;packet_s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">  packet_m ml();      <span class="comment">//模块例化，只能在模块中，不能再initial中</span></span><br><span class="line">  packet_m m2();</span><br><span class="line">  packet_s s1=&#x27;&#123;<span class="number">1</span>&#125;;         <span class="comment">//结构体例化，可以在外部也可以在initial中</span></span><br><span class="line">  packet_c c1 = <span class="keyword">new</span>(<span class="number">2</span>);     <span class="comment">//开辟空间，句柄指向创建对象的头部</span></span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span>:ini_pro1</span><br><span class="line">    packet_s s2 = &#x27;&#123;<span class="number">1</span>&#125;;        <span class="comment">//结构体是静态的，在仿真之前就已经有值</span></span><br><span class="line">    packet_c c2 = <span class="keyword">new</span>(<span class="number">3</span>);    <span class="comment">//类例化，可以在外部也可以在initial中</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"> <span class="keyword">end</span> <span class="keyword">endmodule</span>           <span class="comment">//对象天然是动态的，仿真之后才有值，除非类中有静态变量，否则创建对象前不开辟空间</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="静态成员（变量-方法）"><a href="#静态成员（变量-方法）" class="headerlink" title="静态成员（变量/方法）"></a>静态成员（变量/方法）</h2><ul>
<li>类的成员（变量/方法）<strong>默认都是动态</strong>（automatic）生命周期，即每一个对象的变量和方法都会为其开辟新的空间。</li>
<li>如果多个对象为了共享一个成员（变量/方法），那么可以为其添加关键字<strong>static</strong>。</li>
<li>多个对象因此可以<strong>共享同一个成员</strong>变最或者方法。</li>
<li>访问该成员时，无需进行对象的例化。</li>
<li>成员方法也可以声明为静态</li>
<li><strong>静态的方法无法访问非静态成员</strong>（变量/方法）否则会发生编译错误。<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> packet_c;      <span class="comment">//类的声明</span></span><br><span class="line">  <span class="keyword">integer</span> command;</span><br><span class="line">  <span class="keyword">static</span> data;      <span class="comment">//静态变量声明，静态变量在仿真前就开辟了空间</span></span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">int</span> inival);</span><br><span class="line">    command = inival;    </span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span> </span><br><span class="line"></span><br><span class="line">moduletb3; </span><br><span class="line">packet_c cl, c2; </span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span>: ini_proc</span><br><span class="line">  <span class="built_in">$display</span>(<span class="string">&quot;packet_c static data is 80d&quot;</span>, packet_c::data); </span><br><span class="line">  c1=<span class="keyword">new</span>(<span class="number">10</span>); </span><br><span class="line">  <span class="built_in">$display</span>(<span class="string">&quot;cl. command=80d, cl. data=80d&quot;</span>, cl<span class="variable">.command</span>, cl<span class="variable">.data</span>); </span><br><span class="line">  c2=c1;      <span class="comment">//</span></span><br><span class="line">  <span class="built_in">$display</span>(<span class="string">&quot;c2. command=80d,c2. data=80d&quot;</span>,c2<span class="variable">.command</span>,c2<span class="variable">.data</span>); </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="this语句"><a href="#this语句" class="headerlink" title="this语句"></a>this语句</h2><ul>
<li>this是用明确索引<strong>当前所在对象</strong>的成员（变量/参数/方法）</li>
<li>this<strong>只可以用来在类的集静态成员、约束和覆盖组中使用</strong>。</li>
<li>this的使用可以<strong>明确</strong>所指向变量的作用域。<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Demo; </span><br><span class="line"><span class="keyword">integer</span> x; </span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">integer</span> x); </span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">this</span><span class="variable">.x</span>=x;         <span class="comment">//若是没有使用this，则默认采用就近原则，寻找最近的成员变量（最好使用this）</span></span><br><span class="line">  <span class="keyword">endfunction</span> </span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="类的赋值和拷贝"><a href="#类的赋值和拷贝" class="headerlink" title="类的赋值和拷贝"></a>类的赋值和拷贝</h2><ul>
<li><p><strong>声明变量</strong>和<strong>创建对象</strong>是两个过程，也可以一步完成。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">Packet p1;</span><br><span class="line">p1=<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>如果将p1赋值给另外一个变量p2，那么依然<strong>只有一个对象</strong>，是指向这个对象的句柄有p1和p2.</p>
</li>
<li><p>以下这种方式表示p1和p2代表两个不同的对象。在创建p2时，将从p1拷贝其成员变量例如integer、string和句柄等种拷贝方式称为<strong>浅拷贝</strong>（shallow copy）。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">Packet pl；</span><br><span class="line">Packet p2;</span><br><span class="line">Packet p3;</span><br><span class="line">p1 = <span class="keyword">new</span>();      <span class="comment">//只有经历过new函数才算生成一个对象</span></span><br><span class="line">p3 = p1;         <span class="comment">//句柄赋值，只有一个对象，但是有两条路寻找到（一个对象，两个句柄）</span></span><br><span class="line">p2 = <span class="keyword">new</span> p1;     <span class="comment">//浅拷贝，两个对象，但只能拷贝对象的内容，如果里面有嵌套的对象内容无法复制（下层对象句柄可以）</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="深拷贝和浅拷贝的区别"><a href="#深拷贝和浅拷贝的区别" class="headerlink" title="深拷贝和浅拷贝的区别"></a>深拷贝和浅拷贝的区别</h3><ul>
<li><strong>shadow copy</strong>，是一种简易复制，类似于原对象的影印本，<strong>只拷贝原对象的内容</strong>，<strong>不拷贝对象</strong>（用new操作符）</li>
<li>如果类中包含一个指向另一个类的句柄，<strong>那么只有高一级的对象（变量和句柄）被new复制</strong>，下层的对象的内容不会被复制（但是下层对象的句柄可以被复制，即复制后，两个对象指向同一个低一级的对象！）</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1618731781400-3617096b-9fa6-47aa-a69c-f48cd15d809e.png#align=left&display=inline&height=258&id=u708b33c7&margin=%5Bobject%20Object%5D&originHeight=258&originWidth=758&size=358879&status=done&style=none&width=758"></p>
<ul>
<li><strong>deep copy</strong>可将拷贝对象中所包含的对象拷贝过来（只能自定义copy函数，copy中需要调用new函数）<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Transaction;</span><br><span class="line">      <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] addr,crc,data[<span class="number">8</span>];</span><br><span class="line">      statistics stats;             <span class="comment">//子对象</span></span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">function</span> <span class="keyword">new</span>;</span><br><span class="line">           stats=<span class="keyword">new</span>();</span><br><span class="line">           id=count++;</span><br><span class="line">      <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">function</span> copy;   <span class="comment">//深拷贝函数</span></span><br><span class="line">          copy=<span class="keyword">new</span>();</span><br><span class="line">          copy<span class="variable">.addr</span>=addr;</span><br><span class="line">          copy<span class="variable">.data</span>=data;</span><br><span class="line">          copy<span class="variable">.crc</span>=crc;</span><br><span class="line">          copy<span class="variable">.stats</span>=stats<span class="variable">.copy</span>();</span><br><span class="line">          id=count++;</span><br><span class="line">      <span class="keyword">endfunction</span>               <span class="comment">//将每一个量都拷贝一遍</span></span><br><span class="line"><span class="keyword">endclass</span> </span><br><span class="line"></span><br><span class="line">Transaction src, dst;</span><br><span class="line">   <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">     src=<span class="keyword">new</span>();</span><br><span class="line">     src<span class="variable">.stats</span><span class="variable">.startT</span>=<span class="number">42</span>;</span><br><span class="line">     dst=src<span class="variable">.copy</span>();</span><br><span class="line">     dst<span class="variable">.stats</span><span class="variable">.startT</span>=<span class="number">96</span>;</span><br><span class="line">     <span class="built_in">$display</span>(src<span class="variable">.stats</span><span class="variable">.startT</span>);</span><br><span class="line">   <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1618731917155-ff7aa856-17f4-44b5-91d2-5b0f5e036886.png#align=left&display=inline&height=151&id=u892a3702&margin=%5Bobject%20Object%5D&originHeight=151&originWidth=508&size=153332&status=done&style=none&width=508"><br>参考：<a href="https://blog.csdn.net/yu1216338826/article/details/86551128">SV中shadow copy和deep copy的区别</a></li>
</ul>
<h2 id="数据的隐藏和封装"><a href="#数据的隐藏和封装" class="headerlink" title="数据的隐藏和封装"></a>数据的隐藏和封装</h2><ul>
<li>类的成员（变量/方法）默认情况下，即是<strong>公共属性</strong>的。这表示对于类自身和外部均可以访问该成员。</li>
<li>对于商业开发，类的提供方会<strong>限制一些类成员的外部访问权限</strong>，继而隐藏类成员的更多细节。</li>
<li>这种方式也使得类的外部访问接口更为<strong>精简</strong>，减轻了类的维护工作量，也使得类在修改时便于与旧版本保持兼容。</li>
<li>数据隐藏的方式使得类的测试和维护都变得更为简单。</li>
<li>对于成员的限定，如果使用<strong>local</strong>，则只有<strong>该类可以访问此成员，而子类或者外部均无法访问</strong>。</li>
<li>对于成员的限定，如果使用<strong>protected</strong>，则表示<strong>该类和其子类均可以访问此成员，而外部无法访问</strong>。<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Packet; </span><br><span class="line">  <span class="keyword">local</span> <span class="keyword">integer</span> i; <span class="comment">//只有该类可以访问此成员，而子类或者外部均无法访问  本地成员</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">integer</span> j;<span class="comment">//该类和其子类均可以访问此成员，而外部无法访问   内部成员</span></span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">integer</span> compare (Packet other);</span><br><span class="line">    compare=(<span class="keyword">this</span><span class="variable">.i</span> == other<span class="variable">.i</span>); </span><br><span class="line">  <span class="keyword">endfunction</span> </span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="类的继承和子类"><a href="#类的继承和子类" class="headerlink" title="类的继承和子类"></a>类的继承和子类</h2><ul>
<li><p>之前定义过的类Packet， 通过<strong>extends</strong>，LinkedPacket继承于其父类Packet，包括继承其<strong>所有的成员</strong>（变量/方法）</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> packet;</span><br><span class="line">  <span class="keyword">integer</span> i=<span class="number">1</span>;      <span class="comment">//例化对象时首先在这里开辟空间顺便赋初值（如果new中赋值，这里最好只声明）</span></span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">int</span> val);</span><br><span class="line">    i=<span class="number">2</span>;           <span class="comment">//然后再运行new函数，覆盖初值</span></span><br><span class="line">  <span class="keyword">endfunction</span> </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">function</span> shift()</span><br><span class="line">    i=i&lt;&lt;<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> linkedpacked <span class="keyword">extends</span> packet;   <span class="comment">//子类可以继承父类所有的变量&amp;方法，并可以进行增补</span></span><br><span class="line">  <span class="comment">//integer i=3;      //如果子类声明了i那优先索引的是子类的i</span></span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">new</span>();    <span class="comment">//不管子类有没有new函数，都会先默认调用父类的new函数，如果子类有再执行自己的new函数</span></span><br><span class="line">    <span class="keyword">super</span><span class="variable">.new</span>(val)   <span class="comment">//如果父类new有参数，那么必须在子类的new中通过super.new(val)完成继承，如果父类没有参数，系统默认调用继承</span></span><br><span class="line">    i=<span class="number">3</span>;</span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">function</span> shift()</span><br><span class="line">    i=i&lt;&lt;<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> tb;</span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span> </span><br><span class="line">    packetp=<span class="keyword">new</span>(<span class="number">3</span>);</span><br><span class="line">    linkedpacked lp;            </span><br><span class="line">    <span class="built_in">$display</span>（<span class="string">&quot;p.i=%0d&quot;</span>，p<span class="variable">.i</span>）;</span><br><span class="line">    <span class="built_in">$display</span>（<span class="string">&quot;lp.i=%0d&quot;</span>，lp<span class="variable">.i</span>）;</span><br><span class="line">    p<span class="variable">.shift</span>();</span><br><span class="line">    <span class="built_in">$display</span>（<span class="string">&quot;after shift p.i=%0d&quot;</span>，p<span class="variable">.i</span>）;</span><br><span class="line">    lp<span class="variable">.shift</span>();</span><br><span class="line">    <span class="built_in">$display</span>（<span class="string">&quot;after shift ,lp.i=%0d&quot;</span>，lp<span class="variable">.i</span>）;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></li>
<li><p>子类和父类存在重名变量或者函数，那调用子类的函数（如果没有使用<code>super</code>），子类如果没有才会调用父类的。</p>
</li>
<li><p>子类执行new函数，必须先调用父类的new完成继承，如果父类new没参数，则可以自动完成调用，如果父类new函数有参数必须在子类的new中通过<code>super.new(val)</code>完成继承</p>
</li>
<li><p>子类如果有相应的变量或函数那就调用自己的，没有的话就去父类找找。</p>
</li>
<li><p><strong>子类成员优先级高于父类</strong>，调用<strong>this、super</strong>则是明确调用域。但子类<strong>必须通过new函数</strong>继承父类。</p>
</li>
<li><p>子类句柄赋值给父类句柄，<strong>访问权限只有子类从父类继承的那一部分</strong>。</p>
</li>
<li><p><strong>父类的句柄不能赋值给子类的句柄</strong>，因为父类较小，会有非法空间出现。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">packet p=<span class="keyword">new</span>(<span class="number">3</span>); </span><br><span class="line">linkedpacked lp=<span class="keyword">new</span>(<span class="number">1</span>); </span><br><span class="line">packet tmp; </span><br><span class="line">tmp=lp;   <span class="comment">//子类句柄可以赋值给父类句柄，但句柄访问受限</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619320909037-d36f5ec2-5e18-449f-a67c-d800288cf971.png#align=left&display=inline&height=169&id=BkyE6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=457&originWidth=910&size=120923&status=done&style=none&width=336" alt="image.png"></p>
</li>
</ul>
<blockquote>
<p>写代码的好习惯：<br>1、所有的类都要写new函数（哪怕为空）<br>2、子类的new函数中，第一行先写上super.new()完成继承<br>3、子类的变量不要和父类重名，方法可以<br>4、在类中调用函数的时候最好写上this、super提高可读性<br>5、在包、类等初始化的时候加上后缀如pkt_a</p>
</blockquote>
<h2 id="包的使用"><a href="#包的使用" class="headerlink" title="包的使用"></a>包的使用</h2><ul>
<li>为了便得可以在多个模块（硬件）或者类（软件）之间<strong>共享用户定义的类型</strong>，SV添加了包（package）Verilog没有包的概念。</li>
<li>包的概念参考于VHDL，用户自定义的类型譬如<strong>类、方法、变量、结构体、枚举类</strong>等都可以在package…..endpackage中定义。<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pkg a;           <span class="comment">//声明包a</span></span><br><span class="line">  <span class="keyword">class</span> packet_a; </span><br><span class="line">  <span class="keyword">endclass</span> </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data; </span><br><span class="line">    <span class="keyword">int</span> command;</span><br><span class="line">  &#125;<span class="keyword">struct</span> a;</span><br><span class="line">  <span class="keyword">int</span> va=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">endpackage</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> pkg_b;           <span class="comment">//声明包b</span></span><br><span class="line">  <span class="keyword">class</span> packet_b; </span><br><span class="line">  <span class="keyword">endclass</span> </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data;  </span><br><span class="line">    <span class="keyword">int</span> command;</span><br><span class="line">  &#125;<span class="keyword">struct</span> b;</span><br><span class="line">  <span class="keyword">int</span> vb=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">endpackage</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> tb; </span><br><span class="line">  <span class="keyword">import</span> pkg_a::packet_a;   <span class="comment">//  导入包内的类</span></span><br><span class="line">  <span class="keyword">import</span> pkg_a::packet_a;</span><br><span class="line">  <span class="keyword">import</span> pkg_a::va;         <span class="comment">//  导入包内的变量</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">class</span> packet_tb; </span><br><span class="line">  <span class="keyword">endclass</span> </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data; </span><br><span class="line">    <span class="keyword">int</span> command;</span><br><span class="line">  &#125; struct_tb; </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span> </span><br><span class="line">    pkg_a::packet_a pa=<span class="keyword">new</span>(); </span><br><span class="line">    pkg_b::packet_b pb=<span class="keyword">new</span>();   <span class="comment">//  初始化一个包，和例化类的对象不同需要声明域pkg_b::</span></span><br><span class="line">    packet_tb  ptb=<span class="keyword">new</span>();</span><br><span class="line">    <span class="built_in">$display</span>(pkg_b::vb)         <span class="comment">//  直接通过域索引包内变量</span></span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="包的索引"><a href="#包的索引" class="headerlink" title="包的索引"></a>包的索引</h2><ul>
<li><p>方法一，直接通过域索引</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">pkg_a::packet_a pa=<span class="keyword">new</span>(); </span><br><span class="line">pkg_b::packet_b pb=<span class="keyword">new</span>();    <span class="comment">// 声明域pkg_b::索引包内的类</span></span><br><span class="line">packet_tb  ptb=<span class="keyword">new</span>();</span><br><span class="line"><span class="built_in">$display</span>(pkg_b::vb);         <span class="comment">//  直接通过域索引包内变量</span></span><br></pre></td></tr></table></figure></li>
<li><p>方法二，导入包中内容</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pkg_a::packet_a;   <span class="comment">//  导入包内的类</span></span><br><span class="line"><span class="keyword">import</span> pkg_a::packet_a;</span><br><span class="line"><span class="keyword">import</span> pkg_a::va;          <span class="comment">//  导入包内的变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pkg_a::*;       <span class="comment">//导入包内全部内容，编译器自己找</span></span><br><span class="line"><span class="keyword">import</span> pkg_a::*;       <span class="comment">//但这这种 非精确查找优先级会很低，在编译器找不到的时候，才会考虑这两个包</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="思考问题"><a href="#思考问题" class="headerlink" title="思考问题"></a>思考问题</h2><ul>
<li><p>类和结构体的联系和差别有哪些？</p>
<blockquote>
<p>联系：<br>1.定义属性用来存储值，并进行了封装;<br>2.定义下标脚本用来允许使用下标语法访问值；<br>区别：<br>1.类里面可以有函数方法，可以继承，结构体不行<br>2.类的成员默认动态，而结构体默认静态<br>3.类的成员权限默认public但是可以限定，结构体只能是public</p>
</blockquote>
</li>
<li><p>类和模块（module）的联系和差别有哪些？</p>
</li>
</ul>
<ul>
<li>为什么类的静态方法不能访问类的非静态（动态）成员变量？</li>
</ul>
<ul>
<li>如果有同名的模块，那么在编译过程中应该怎么解决“同名”问题？</li>
</ul>
]]></content>
      <categories>
        <category>笔记篇</category>
        <category>数字验证</category>
      </categories>
      <tags>
        <tag>SystemVerilog</tag>
      </tags>
  </entry>
  <entry>
    <title>使用SystemVerilog对Router进行验证</title>
    <url>/2021/04/16/%E4%BD%BF%E7%94%A8SystemVerilog%E5%AF%B9Router%E8%BF%9B%E8%A1%8C%E9%AA%8C%E8%AF%81/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在学习了SystemVerilog之后，检验学习成果最有效的方式就是真正的去实验一个项目，以下就是我的一个关于Router的验证过程。实验代码我会上传到<a href="https://github.com/Mr-southerly/router_verification">我的GitHub仓库</a>中，有需要的可以下载。</p>
<h2 id="设计模块介绍"><a href="#设计模块介绍" class="headerlink" title="设计模块介绍"></a>设计模块介绍</h2><p>实验中的待测试模块（DUT）是一个16输入，16输出的路由器，这个路由器的功能是把数据通过各个输入端（Input）发送到任意输出端（Output）。下面是最终完成的整个验证平台示意图。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1618569459855-33d9f017-78cb-4662-9766-1f27c36d714d.png#align=left&display=inline&height=784&id=ud2ce8c99&margin=%5Bobject%20Object%5D&originHeight=784&originWidth=745&size=351768&status=done&style=none&width=745"><br><strong>我们需要建立的几个文件：</strong></p>
<ul>
<li>顶层（Top）文件：router test top.sv</li>
<li>接口（Interface)文件：router_io.sv</li>
<li>待测试（DUT）文件：router.v</li>
<li>测试（Test）文件：test.sv</li>
</ul>
<h2 id="Do文件实现调试"><a href="#Do文件实现调试" class="headerlink" title="Do文件实现调试"></a>Do文件实现调试</h2><p>在做验证的时候，每次修改完代码后都要经历一遍编译仿真，鼠标要点击数次，作为一个懒人，肯定是要想实现自动化实现这个流程了，网上一搜果真可以实现，只需要编译一个do文件，看了看参考的文章，动手写了一个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vlib work</span><br><span class="line">#创建一个lib名叫work</span><br><span class="line"></span><br><span class="line">vmap work  work</span><br><span class="line">#将新建的work映射到虚拟的空间</span><br><span class="line"></span><br><span class="line">vlog router.v test.sv router_test_top.sv</span><br><span class="line">#编译当前工程中的文件，注意被include的文件就不要放进来了</span><br><span class="line"></span><br><span class="line">vsim  work.router_test_top  -t 1ns -sv_seed random</span><br><span class="line">#开始设定仿真参数以及仿真work库中的顶层模型，顺便随机初始化随机种子</span><br><span class="line"></span><br><span class="line">add wave -position insertpoint  \</span><br><span class="line">sim:/router_test_top/intf_io/clock \</span><br><span class="line">sim:/router_test_top/intf_io/reset_n \</span><br><span class="line">sim:/router_test_top/intf_io/din \</span><br><span class="line">sim:/router_test_top/intf_io/frame_n \</span><br><span class="line">sim:/router_test_top/intf_io/valid_n \</span><br><span class="line">sim:/router_test_top/intf_io/dout \</span><br><span class="line">sim:/router_test_top/intf_io/valido_n \</span><br><span class="line">sim:/router_test_top/intf_io/busy_n \</span><br><span class="line">sim:/router_test_top/intf_io/frameo_n</span><br><span class="line">#添加波形查看器，并将需要查看的波形导入其中</span><br><span class="line"></span><br><span class="line">run -all</span><br><span class="line">#运行</span><br></pre></td></tr></table></figure>
<h2 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h2><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul>
<li>自学关于V0实验指导视频（腾讯课堂）的Lab1/Lab2/Lab3指导内容，了解VO实验是如何构建测试平台、发送激励和完成数据监测的。</li>
<li>完成第一次、第二次在线实验直播指导，学习实验的思路和培养目标，即在构建一个干净简洁的验证结构基础上，实现对DUT的激励和监测。</li>
</ul>
<h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><ul>
<li>可自行根据VOLab1-3的实验代码内容，参考并且完成属于自己的验证环境（coding by yourself）。</li>
<li>应该利用task/function来完成对DUT的激励和监测。</li>
<li>利用struct作为激励的发送和监测数据类型。</li>
<li>利用不同类型的数组来生成或者保存激励数据和监测数据。</li>
<li>利用module和interface作为验证平台的层次结构以及与DUT之间的媒介。</li>
<li>利用参数传递、或者函数调用等来完成接口（interface）从测试顶层（top）到验证组件的传递。</li>
<li>利用$display函数来将每次激励的数据信息和监测的数据信息都打印出来。</li>
<li>在所有的数据发送给DUT，并且由DUT全部发送完毕之后，调用$finish0来结束仿真。以上验证结构中，应该至少包括stimulator组件（module）、monitor组件（module）、接口和DUT，以及你认为需要的其它组件，并且利用结构绘制工具（Microsfot Visio，或者draw.io等结构框图绘制工具均可）绘制验证环境的结构框图，并且作为稍后第6周的打卡作业来提交。</li>
</ul>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><h2 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a>实验二</h2><h3 id="准备-1"><a href="#准备-1" class="headerlink" title="准备"></a>准备</h3><ul>
<li>提前学习V0的实验4-5，掌握如何转换这些类（数据包packet，验证环境组件generator、driver、monitor、checker/scoreboard）。</li>
</ul>
<h3 id="要求-1"><a href="#要求-1" class="headerlink" title="要求"></a>要求</h3><ul>
<li>需要让整个验证环境结构变得完整（补充上checker），从module的硬件层次转为由类来构成的对象之间的软件层次，即完成验证环境中各个组件从module转为class。用任何一种办法，相继发送多个数据包，前后实现遍历所有的入口，以及所有的出口，组合次数、效率都不限制。</li>
<li>（选做）实现一个测试场景，即同时给两个不同的channel（入口）发送数据至不同的目标端（出口），同时检查设计是否能够支持该激励，如果设计可以支持，那么验证环境的checker也应该支持相应的数据检查。</li>
</ul>
<h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><h2 id="实验三"><a href="#实验三" class="headerlink" title="实验三"></a>实验三</h2><h3 id="准备-2"><a href="#准备-2" class="headerlink" title="准备"></a>准备</h3><ul>
<li>能够有完整的验证组件包括generator、stimulator、monitor、scoreboard</li>
<li>验证环境能够将数据比对的信息及时打印出来，并且控制仿真的结束和最后的测试结果统计打印（例如比较数目、测试是否通过）</li>
</ul>
<h3 id="要求-2"><a href="#要求-2" class="headerlink" title="要求"></a>要求</h3><ul>
<li>能够实现验证环境可以同时对router的16个输入端口进行激励输入。</li>
<li>能够实现多个通道的随机输入（目标地址DA随机）。</li>
<li>能够解释清楚scoreboard的执行逻辑。</li>
<li>能够解释清楚测试代码结束测试的逻辑（仿真何时停止、如何停止）。</li>
<li>能够绘制自己验证环境的结构（在接下来的第10周打卡作业中提交实验3的验证结构框图）</li>
<li>（选做）根据自己的验证环境结构，独立实现你自己的scoreboard代码。</li>
<li>（选做）避免从generator或stimulator将激励数据直接发往scoreboard，而创建独立的monitor监测router的输入端数据，并且将监测的数据发往scoreboard。</li>
</ul>
<h3 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h3><h2 id="实验四"><a href="#实验四" class="headerlink" title="实验四"></a>实验四</h2><h3 id="准备-3"><a href="#准备-3" class="headerlink" title="准备"></a>准备</h3><ul>
<li>按照第4次实验的视频指导，能够使用手动编译的方式或者使用Tcl脚本命令完成单步编译和仿真执行，并且收集覆盖率。</li>
<li>同样根据第4次实验的指导，能够理解提供的用来执行回归测试的脚本（从编译、仿真、覆盖率收集以及合并）。</li>
</ul>
<h3 id="要求-3"><a href="#要求-3" class="headerlink" title="要求"></a>要求</h3><ul>
<li>将路桑提供的接口文件替换掉你环境中的接口文件，该接口文件具备收集功能覆盖率的功能呢。</li>
<li>使用单步Tcl指令来收集覆盖率，或者提供的回归测试脚本来批量化收集覆盖率和测试结果。</li>
<li>使用Questasim的verification management功能中的browser，来查看覆盖率数据文件（UCDB）、并且分析设计的代码覆盖率和验证环境的功能覆盖率，使其能够尽可能达到100%。</li>
<li>对于没有达到100%的部分覆盖率，能够给出合理解释，为什么无法达到该覆盖率，是否激励不够需要更新测试（请继续更新测试用例，提升覆盖率），或者由于设计自身的原因，无法达到100%覆盖率，需要剔除该部分数据（exclude）。</li>
<li>（选做）对于一些时序部分的检查和覆盖，我们还可以交给断言assertion或者任务task去实现（检查和覆盖），所以你还可以进一步分析断言的覆盖率，并且通过修改stimulator、test验证组件，继而提高断言覆盖率。请对以下设计的接口时序描述，采用SV property （属性）去描述，实现检查或者覆盖。</li>
</ul>
<p>注意：请在调试断言时，添加有关的仿真选项，即在vsim的命令选项中，添加-assertdebug -assertcounts<br>1.1.输入时序检查<br>1.1.1.framen拉低后，持续为低的第4拍，din应该保持为高持续5拍。<br>1.1.2.frame n拉低后，持续为低的第4拍，valid n应该保持为高5拍（不一定再拉低，如果下一拍可以发送无效数据的话）。<br>1.1.3.valid n保持为高超过5拍，接下来valid n应该保持为低，且持续的周期数应该是8的整数倍（有效字节周期，目前设计只支持接受byte即8-bits的整数倍）。<br>1.1.4.frame n拉高后的下1拍，valid应该拉高。<br>1.2.输入时序覆盖<br>1.2.1.frame_n拉低后，持续为低的前4拍，valid_n的取值可能为{0，1}（不关心valid_n信号的高低）。<br>1.3.输出时序检查<br>1.3.1.frameon拉低的下1拍，validon保持为高（下1拍不一定立即拉低，如果有无效数据的话）。<br>1.3.2.frameon拉高的下1拍，validon拉高。<br>1.3.3.当！validon&amp;&amp;！frameon第一次满足时（输出包的DO），到valido_n拉高且frameo_n为高时，中间经过valido_n为低的周期数，应为（8*N）。<br>1.4.输出时序覆盖<br>1.4.1.当！validon&amp;&amp;！frameon第一次满足时（输出包的DO），到valido_n拉高且frameon为高时，validon还可以拉高和拉低（输出数据包时，可以在frame有效期中，不连续发送数据，即valido_n可以为高）。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1618571340146-eba8a833-d692-49f6-b7e2-241a755d7fc0.png#align=left&display=inline&height=651&id=ucbcdc276&margin=%5Bobject%20Object%5D&originHeight=651&originWidth=722&size=256202&status=done&style=none&width=722"></p>
<h3 id="结果-3"><a href="#结果-3" class="headerlink" title="结果"></a>结果</h3><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://shimo.im/docs/axk6MwD8D8IpFeqr/read">路科V0实验指导</a><br><a href="https://blog.csdn.net/u010301542/article/details/51501011">Modelsim之 DO文件简介</a></p>
]]></content>
      <categories>
        <category>项目篇</category>
      </categories>
      <tags>
        <tag>SystemVerilog</tag>
      </tags>
  </entry>
  <entry>
    <title>清明踏青记——天津</title>
    <url>/2021/04/10/%E6%B8%85%E6%98%8E%E8%B8%8F%E9%9D%92%E8%AE%B0%E2%80%94%E2%80%94%E5%A4%A9%E6%B4%A5/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码输错啦，要是不知道密码就别再试了" data-whm="哎呀，这些解密的内容可能会改变，但您仍然可以查看一下">
  <script id="hbeData" type="hbeData" data-hmacdigest="b39d112daf431704d6720bcb175f178fb85826e225d4470e05fb18dd8dbbf3e3">ff28bc83845b8663ceb8d4fcab5cdbbd623656fc28862cb4fe7edf8f4c936ec52f845fbffd36c5d05fb7403a8885b222615a2cc0ab297ccbf485a1c10c2c22653057a3a6c2ecad960c345f52094ad495b4fb01c11337797ee32c59c783165e1d583aa7e4aa0aacbda1936a307038dc96044253a7334c36cece38c904b3a312f9a35d91c4268fae16e4c12d24e2c58d08400c66d342cb1d0a57b18c6a458ff05446c95cbc37f30625f82ebd04ab429ad597587dbdde3fb2e599105fe813f74cb86e7c6f775a3503f500627bb69508b1995d1a0b3fa8fc7abf6a13274c1f903b5dc4bd2aed2637f9df3d8dd71d1e89d50a66188a10bb38d8a5f09aaf9d2b44094dea1d3626b27bee9fec1fd98d10daaf0bd38713289c4d51593325f0e3ec4540de417cb2eb4225f4a8b8887a1b48e2b3986b419aa70f0066802ba793d3ddf3ad34d48ca53d48c8150327d6e07a79b3b8f0206c6f806238d0f7db594941848fab5e2409c2e3146d6a10834700e6e87e8a090aa9f30979c90a126d38004249d5a1c7747f668a150684a5cf8851f9e22e53856c16c95e1449fe2610a8ed5707610f19f320d7e49382f90c03040b85941ee49b8756fcfe2674d69b5defab6fe68dcc64f50dde52c756f42aba76f3c71cedaa2d832ac3c86d86c5a405e3a2277c7023ac7dd7d98834737a28c61cd4f1c345a0f0ccfbeb2ce38a4fcc94b6c3bcb0ed1065a2d453a13b096a50f9ecb9117b17f735762e20a5e89db50fe70c9485f30df862f4fe3327dd1c8d56953a65ee7715d90b040834d361dee1954887dd020f806ce30620b4f3df85a794d02cfeb68ae405676c040aa2c8535c5f2f872e323f67dee737a69b3edbdcf562be5a561a599b8df897db42bf67d0e7b7d1e7be5e0f98f96153f364710ef4873533b962e296e369bd871b6a56988e1c458b07a93bef31ed8c36b357a56a9ac797406638cbe32eb92309ee0ef48d26c54963d431f7bb5dc685ec454f3d9f6b9eb5c0dabb8868a4941876a1e63aa5555f395f4cb5878888f02b11c321fdcd8c716ce2e876ef2c4833b96665f0efab3e0aa7246ad54e4b2e14eef61c2db9727011c7b30a24e2cf5fae971ce962e78c7484bfee18985ddebd8721c2c264170d25d12a62d099847d81786a67ebef26c016dc4b80aac897c0d8685a43656d6426cf6e6ecbe5f9b7060031104632a09b9d5d1a6a1019d8942e8c3a4226d29a2e800ae64990a16fd7c0324740dcf5506dac61fcbcbf9c78713f0c216ae4d5a92aa2d2db46117188659c3d71f4927f6c18362491b367f1ae4ef96a60e05d6695e5367a63387b2f147847e13cc919cde70c6fce2225882852cdf801686f741c4c72c3a33c07a6672482728a45d91b51f97d56a6266f7bef8b7168cae94496bf3be9bca2a1a25bc8c2834c695bcdf094f9ff30de53935908c2ecec6f3041f31797bfd2fbe8c71a5fe84e38499476cacca8fdd73518ed1bffe7e7502f6529de72df9a50ffe167cf2200cd7134a927a7d886d714dd72d4bb465a9707a2aa66491f63b4c1102ccf7af70954624036cda445b0b8fa269c0cdcd5945ecbf32c44ded889c4f52817fba19c28a86c263ea37a83b2fc92448c2bf9b61bde35fb94bc886daddcefc2435314b7910f29e85e292814f3b8e8606bc2e960f73028a6285ee83df67226e56504957bac694696fcd18e0cbb8d33b5fccee0c8e331b7751de4051a7792d530d9e2ede917d0e2898ab0851bb3a1e7953848b728c95f35882da9732ce97c946b220a2a2aad10e54b1194876be7b40ab81375a55069d58bc87422c01dee410e54cda4ff90393e307a625b27e8f8dd7e95e2bc73e86a1e06c931bac6b7e3d2ba5c91260488c767e115beff956d778a0827f4d6c6e8c476328afbeeb9aa6f72db30cab94fcdd66ad0ee10592baf6bebc171467a26b04f095996b4a6d8b602843a1efb3b9c6002739172b9ed4de3db59a8a21420fd60b44470c2e67c0709561f88aaed55874a9d6f0260102ba0a28aa9750e3aaa0815b557578edf63a9d5d45a15b3989f0522f5ff03cbb564cea56aaee2addba379fcb6a5e1ec4797fefc5af0c47d44774990c61f3ce42321c06090d4fd8686f57ad3240613b849eb114c4025a869b1f043bf17018acc08c0f723f9ab0fce53ef4fb8e195330f5a5ea1c774f6d5e664c84c6d091a4dc02374bd2daeb992441775aaae974e1e6f0ecfd985cdc1c0d6d73ac0e549ad38879e6b4551b1df3155bb34110ee27c7e2d854d197298396b53ad4bef74c7b24d1e5b28192e8cd39191b9e4d8d2e00e0aede51308c23fc48fb35f06a9d30532d218c7a021beb37e0605ea105a6dc81ce20edb2bfff873ce071234a5e5a179583916b13992b6ee47e3a66fce4d749aa042385e06b53f461ca8208c3b598df395887ba2a8797fc2ffae8c6a8c9f476b8f9c87a3a6136d5c21ed1e5934d87bd3e6175d9c0db679306ebb87bc8f65fca42e223e3151b37d5106b15c01255f12c98ca54bb8ceb4b3735191a0688056008f3ea9185454827003a3e95d385b7e6c0bcf31df3749f4a5f7a705919ac40f7b7933fc7cf7727b2c9f39d54b62baa25a5da329586464ca03d62e7570a615bcfb3b1a055db7ff650c2850d04a8c261e61290119b945dfc28a0a40569e83731d438a19342447f6c16f41cf2757c388360a524cf199759640b51e495f6bb0bf0a295ca21ea722b1cb6936fe7cf351921ed4c853de55b76cfc4a56b71b4af26f356edd71ccb0deb3a899ff7f1a7aba490ab856217981227363118db678a6c6f178491a6a1da5885591ca12533abf71f5976a0614b90546617152aabec0d161bf8f541bfc6d1329cd355135b90b88750883c119da173023f5aa0edec18e8dcc2c303e35dac154723194e92cd78ba048a09e2cdb2b778a760aa27b5204c44fd6078930aa34ac68670dac791ef5c043e6c3765d0f64640074a973d2fc71b4d344c885c157be04002814b5c8e184968a3fc6cbde2b985bcd3aacd75abb68c3024eae1642dd887215137e656285163ecb6d03d03dafcffc56ebc947fafefee173677d0afac02be95acf69161ea4088a76fa172e88245d67d4b20fe8c94bcd3b64a68f435f62d2992296b89632968040363a29e45fc2a325b27655fb4244133cf4062505aa8f6f7970abff306c2604374404714c42c1fe98dc2d34dc819894fc4ee15442f7572239e5d08cd5d5dbfdc30e37cf1a52b9ca1232ee79dd0d142b85e4a30b80ce5874bf31cf35926a41099f3b54db4ff33e7baa37dcdbdbc7781c9451a778d70d2008f0a76255bda08cdcc02d68faa01c87580b62b076cae6fe890af1191b2ed1a2f0f2efdd572651037f76795ca2852f049ff5e26962c8ac1a57e4ca8edc54b3e552bc59c5b79ec2bcd2887a99237a720a06a849717491b7ac6d569a6cf0aa47436c7df2599ab20ac9ed08264556b35ca9de4a11d74a1af3f0d8b125b04f6cb14c232c1866c082222169d24aa5931f1003681a3234bc30259dd6fbcd18a6fd4f1304f17f24af3b19fc203078fc64b351961a0708f57ab8b106e7451fd4ce1f7a6d12abda2aa00fa812fce2d5ae85700cf628e95169765959b5fcf91bf775a178b4ee58120fe641dd2cdb9e6d496642ac9ce38bf351b3df7708c9ad98c0dbc1c2b367b027a2b439cb6e5ded16b85fd5b040e3eab2c7352ef66a3ca3f06558e80bbefdee7c5b894c4423b80f0019cd184e11c28325c0747629b00aa9ed81304db7390097e9eeefe418debba982a90be2d82a5baeb12f2b223e232f1aa58f5f0206d46232aaef82263fab61d9d5ea013e88b227041f6db8e2f9a594214750e9107df57c4e1ae5c48b69226718c5df83ae222ead33cdf1774ce24c55b27ae5aa3b7d3c7cb4f19737cddb6dbe1e3c77cf9a0991600a91c6e06341be71b222b4c42260f5e2637ffd3f5f45f67f4585513c0264ff8bcf4cfab0800c6b8a7800ca86828ac4b0cddfe25f2926c36cb8f837c990456838bda30f76e3a5f41b39c4c64c87166b67b6012c2d2fc5570c359bac42ff434093abf2a0514a141a45c15b29fc068cc57884fd0edb3adead2789e8059640ef79d52e99b5161b33500182b153601f412b5948362bee02790446eeef9d085cbf3cba96dd9e4294ea1eda83d2450d23e1f4bd285f4628ae07723c3bb1d8dec09277b88b3221e111604421ee90dc2d8f5ff9a6bfd4ca489ce19f9457365beea84ebd84f7b2bc1367ad0bf49a48a55464303b0564f45d8d721f5d8fd7595f06b0aabf93374c4f827a82589f22b70798383904324cd0f4398b5e60a261bf6e2b632ad045083458868469cbd5ccb0957074e155325ab65dc061a1a1c993a9b17e4251597c4605d7a245dcaf3215f9f08e4805a5062c74916fe8623a471dbaa83ba3cab9d5d6254e5955e33047f0e104121572566a11f9da77ff82810ab26e3877a8ce43c70cc65fbe862dfb8c75eea035948ba4318a888fcca905b8c4980d59df02090dcdc49bd9c5223d81e62fefca31a8d542c7a6c36519631bb0dc69d01fa9c9b251271d39d97418728f68ce22e07b420f1d771feaed39fb09176ba641d82c57a8d4fc1f1648262d3c29605d90438ce1b575b054bf5003c42de636d2f3167f53283522e7488353830f141ded9fb646b5497da8232cdfc650d029d8f3d9afd7dfbd9a4bc86fc2cc7639018e9336a55723e0d085c6b2fed6cbe483473aff1e4ce11a7ace34466248976b2da9f72323116fe01d7bb458bd4450929f84891e1a686478c86a58346f5cfe07967f039a9e5ed23a6c47a3807cc4e11efe2a9324e44701fc267d50a40e457343a4fc3f5dc5d95f427dcf4469a5fff314e096e098b579655b7a2ea6b2c3084bd5649823896bc08c4752d30ba35ecbbb9eb631ec691e61c913e7f5f6fb790b0e24d122808aff8ec6e64565a3d8dfdaf76e567806e2e1bcefe92c8becf949f2a24f2bfe3496bcc5d32337986ebd794296166b6e3737fb38ab6e93ce2b58b7324794499b3e3f5ba489e683bf15d8a2a3c7d8cde9828616405c4a0ea7d2181b8474c1c40223ae18205b08872bd42d8a2577327105faf9b7627a23dd3beb75910dbbc3d126df6e8e7eef20aedc77d68a0cc6b1ccf1ad76a88cf720a8628c4b5a423c56c8e9d39e8a564dca3907fbf6e0ef7c4178aa6bce152ef286152b10e859e8cffe2640226a7988e4dcdedaec359b3a704d4bb8b6e23f4d8aba05d9dad750a0387d68bfc7751caa7eca02a7cee5f45eedd77c29072e884f8260ec5677d25aba697a41a987ae178564f9232b1469a0840f0bd17dc37701adc30a336da061749520a2365a3a30deb9183ed76f753022785fb7eac7cf1689a0b4a7d2ba822b40fa7e3c19940152f129c29a0cb80494f30114b929ee31db9741d41ab2b9a4f7f5baa609e31f4db5d0b4dcaf3fc41f6e621143afaed1e913bc6f4a45fe38b9c136ff8fc443d5351ba65e575b3e181bcf57c3ec54a3706cf04cfac6bc992bb9983f8c20bb7a08aee65cfdf36f600a6e60cdd219149e98cc0af1ba34792d0294e701bb9a2f8f33e9f116a9b88041cd65abdba84e6b38c73b5fbe692306a23962e4ee4a94c73bb50bd93bfab615f12bc9fd392417627bd7f4942df4a9cadad4cbb9d69887102c5aa0208b11d6ccec3994aeba7f88349df520ba80c90a9167ca9fe915f0b582a118dc5f335a1c8a39821fb27a8f55167756717013613d1a9132f3336233196bfa73fc8c7ded16febfa9bd402212500f462e3c498b6d289450b1bd1d6eec5f3691ccf0086e1a19470e1528d47faf5d46f80c2f55728e2ce2e5fddfc7b9e555ab66629026b1253d5a31bc7d57ad33d7021029029251e6da4751aee842ea440eefd83d183827d422d5d76d31d801684cc5f8196397f64deb375072765a9e3d456c2f31bef7edd67839aa716f7e572bdcbbca8b54fcd295b825eda5d75e97947f2c4a3675c24b1762e6bcf6541269905bf13d7c00d8e4f6731b049cb619702645a0a43573badf3849223c3c77546bea594e940af5a6a793c1eedfbde75239027d7c4909264364d20cbf2fcef1a171c999723b430e393c354b1e55ea39a38bc9a4e82ab63e7e7db26b5d45b58fd8d23529d4476792ec65b6d0ab1c2383eb8dbb0e2bece5f8fb6e62be2a5b2d2e011b1ee3009eaa831d950f2963ee2648c8a60958ff10f3595fa2fa9a380a96d6c01ede66c91aefd07b20e95b274eb5859e4c0223d291a5270471e77e909faf3c5c82fe8f532c0ce4f0b133c6a1fd6ee45a0673b13dbe22d4d64fbdbc53f5d6f2b2c883665f17e27fe7fb5be241300c867a9fd20c3c55a26dedc7d7b2e9f2a6b0e317e4f5243b058b24eaac024ebd72277c8f0bff21850edd665350b523aa9052df9be4e29ac05b3e5ab1fb805b522db07562005f7bee95f893aed30ed8b6fdfa57ffd2d64feb148ffefa24de9de97a985f667b064786286f7ac4426d4e89d01fc12a137429e54bf9d9026a06b5f61b70979e8de65ffc0d92a2f213c46f6517b5535a14a4c4b4c9510fc1a9c834e0a12bb27a83eee3f90e69d19abff70ba4216458394f4ab28e3e7849951cd9406597700884c94dabf2bfcf07a397eb7a623daeb03bb5b06f90e6ba4d5184b0f42adbb0ffd5654bf0ce5b6fcdac275085ca018afc1769da224ff29690f332ff8706a5fa90443595d73a91a2222aca46b79e77df78c043a05d95cd9e4d8e4f209dab4c072725c96bae5fbf61a3817e7c6b8b6d8239de611f80acb5e62a77090afd28e3fcdcbe4bb28862aee93d43213588c0e9d0491d1585c97936cde5b6303101c49371d5074201798db5d5cbb2fc02155e6998e7731b18bcf0fc4ba7076b198bd1a890c18a0700b3e6b108f47fde889fd081e2de9ffd30a0b658d5427b2e3823a35bbd611229b8d063d7ba1c57b90f7008a58524f13fba7f59b87eb6b9a0c89de381c765531c8fbaaef264a42280b84f75f5f42c79d698a4fc7810db512fc4c0c35355eb0d6cc7e7f8300515bf7039f71b74ec590e9f78af079691d5e3a9d50fed053727d8448689981b7253e80034665525c5cdc22d4398da3951deb42b19e7b25787a7a76aad765781d23f35722404e090b1ce0e736b7444c0d6a926c245ca3d80ad3736346458bb48f80c34298c5a5fa3d640b06694d7e0eecf4c4148665058d94f6f4965cd221dfc3f226935bbda71a4549eef54e3e4085ac5a0b9ef5371592636daf44773bd899d2bebed3e81ee2e32c640cda26afc53c387264a0ac84672735c08d4c5023e97b2e893258d0d0e52eed74f70db427e2fe17b58db0544626449dbe5f14080057834ecbc9883334e059a84637ade1c2e28475f5f1fdd084b417bcaa3f0d787ce5dee1e6f2f50bcbd11d4fd3a44f7edb5347b776cc2ba6bbd924f3890f669e48d5febc279dbf06fddc3783c4a5f1ad8b581590c47b0fd4e3a1472088a9289f848a356c1105aa477acaca4e6ffeeace84318213007b78fd62068748a8a98b68a524d66a29e0999de9218a3a0e610e829dcfb7b0f4c9cae3e825f78c9e9257a793094279564c2b422fbbe87d1724a317f5367e19facba1f99955df442456ee22b84ce49bc0c376dddaf069fe61534be0e4c61f370f31ed6cbf3e70669c31c3627c6a8a480546834335957ab5a914d2146f9a3930ec966be749a4626efd20915eeb3879a1281549ef7dbd951cdf298dc45a29239d3827eaf75184ed1e0695df30f2bcd4aa09b5e04d5cabe95cd0c8eb1f477a00c49f85f2681ca2fa646f86053c75a1ee268361e402535c8d5708db1871eb78d85540cecab7e3f216010368fc4236c38a7b1c9d47005062221c4cc9718840f0a400d4d08b500731c1fd6eb9ddc2f5f3f2dfe758d0737d49356982c04f5c0ace77ab3c64b86bc5f94b8b5143afcd61ad9dcddabe01d9fefb4c9b49640d859998b20090e6d0d94272c54da66b7d457ea53b9fdb6293d632feb704ae3e28e287fd718566e2fbfcfa8a121bbe6ad8c0caccbfbec506c049e7c6deba81f1b6cf733c8f58812fe4b43335ee81055d9c3d3c8eb6c9f0a429aabb9031db430433422f99f9a955d817e468a22b4760d0034a361361c3e596913891d56345568da68118f2bac3759c300b2eb0edfa9a6227ea3e0666588c7893254c2f4fa560e18012ed355f14a1255126e2c8753f2e10cc98aedbca6a3a3cb1d19dad35a9f8653c0ec674fc4c16234f25eec038ba530b8252d692d8a852f4add3b3d0cf911761712c8859848e66aa7b183972da01b0a7b670c7801d7990711727455fc401797b4b340d31efa066910122118aab64c72e6dc1192f5b41b25da36d324f3ec6af26f32ea07b06ee0ef35bcfb42855472fd3663ef2b6549f8b265515e1c21be3f9b2d61ee2736704bf2ddbc4eba81655824a0c63864a1faa09c0490d914ab8fddc0c26ce0e24c82e35ce9ce797d38a44c2ef540ef2f2fd9cfabbab2af3a507b15edade929f9b6c27adc838d6e6bae7bd53de71a2d6574edea47f23b387fdd8b9f26f65be15d8e8336e4e12ef092c110d289f2cdbfec817cf35ab9cd2da73d5a83604474c4404f7d00d74e2c4f3a129b4507804916eab6210c801eddb7256bbfdcf783150ebe5a39c2939789b2e6a7583b4243b27f3cda7fe69f2efea119d505ec81603ce2ea35f8338ecbea473b8960f29f4c9dece71a6ab71309ba9d71b174d2ae6b4854111c382c730de5490aa9f65469aba79bfab2c365d6bedcc999c80ae63f5655c8084651fa8e3a4ce2171520595b3913dddf0e8247a3af02b60332238f364382a27c84e08d290c3426adbea66a454d39b30b17e882c6935e21952b371e1c088edee3d7c004f9144128f213b411ab4cfa6a23b188da803b41f8ee2bc2269ee6490b745a0f7cafd0d078be9d8cd372657d180f7daa6b55a680bbe85030aaf18aad9c919cb26d38109befc8e7c52393fca5226b7928382f27c0549d8ed864cb5cff3ffc216f642712f61cd7f9e26456d0ce0a3d27b511ecccff5709aac07a9b1ad5f01b248496ee8c9585b6e8541eca914877d33b212464ebbd3b2a8fd6f6caf65b77face3ea9c76ca87bc966063314587a9f1de8327f298f4c0032611f84e040a473d3fd4431520fc8c4cfa607227c93ee3da17f247cd2e7fd60dc0550e443f8e59f88468c6493c3a01de26e54898f571355d9d4dcd5dfd440f961874467338b94ae605c77494fd360a3c7fd076f5530ed296a1bf1ab5373ebcec95831aebaf2e85aa9226f0de90856fb94d3dc2a2366004ad13e48d2a76dd894a7b16ce38cfec5f0dbb957526c223b3eec929fa82697758688b853b6477828868fad2fa195c8b3eea47c772acce117b62e0bb3e8639b4b1d20381b6412aee31287f85c8238094c563b389066292112b1095896d15c81e9b1adafbdfef42b13e21419bd55ebffdf63229d3f39e39abcd729e8304700af51111dccfb82d81d604315dac2c9a9611684436791f9788bfcd4edba92a127b2c4632b2924107431fa5bfe388c64c132bc8796ee6c9fcbbe02a253af33811f05d33e93927cc5705db3fe828370a2d84a83e5e2a1d9129a1791e81f16d115082dbca3fc102dec5e3f1db6f1a4b0efb33b37bd10b6a986eb1390e1f2b49066b63705968f63825cf17425cd2f9c09097560139a9a11ab5f99ccc6817ae6d629cb11d5f127ef84c7a19c967f90a14cea906ea424b803038b70c54c111dd38dc474b245e6b94655bf575dc5ecd2cb262cdbfcd54832a6ace1f76b331107b1fb640058c3a53fdcecc3391370ed36eaf3370105e547c6eb62938e4d79a22f0bb8b38a7a7ddb1ad6fba7029c9cea7e689badff4e6a36051964a41923c9b834547c6ae97d01a20bf7263d40338fb93d57f2b60dbaa351d2bc115b4bc28117f062a7dfcfa8c8fc9ca6ad0f127e4baa52c5903492d56fdbf81c06b0c57ceb891e8528de4b8434a307e4b49d83c6fd47d8868a0138d3159fb50e4d1b294c628d6a9bb326aacfd490e3659eb6ab5fd7e82c8c6d67508f98f72bef082918807d85c1279d75c58cabb62e258fbd36ffe9d0e991adb6c59fe04ccd9aea0d6ffe311d3afb41b894367dc1cef612aaf624e12f517e6ad27b8be21fea046583c8ead395fcb9eabdea12200d302bc997f22498572a9b5c3804fdc97b79ff5bc1ffb9e78870fd096414c48cdfa15bd42660146256dc232d555375a877a46534f9d3276c4dfacb989ad4dd017db02eee0ccb6f11ce66f6b3373594abc65e5f42ec8c61fe35e74ae80efb208273a84074337100efb0c8792f7011f7e444158cf27cfc5564ea40a97e154dfee051786e328c810c462404ad28a30b2076bb5d82979acf662bd2c1c9849c22e0930968f31e918fd004e5641b0b62b93b1517d8c12a8d779d4073b3023e5ab336cd351fef2236650f0f8cfe3fa5b6d0965f3f44b78219da164cd4ac7723e4f10afb2d3e811edd28eaf02e1bafecaa4bb4f9fd1bb0b5c5ebdf220cdb64997d0bc135a8e75b41732d9f44d46f7ca4b91e7f88ab0a68a3e0efc135bd3cce8b3c8e137d3d2cf50707e92921d294fa71fbda980a21d2c5d977078b686f6717b43c1d1019a68f43324f1e3d92ce2039252eae4feb8103823a1a32b11c974971066ff7c3b88adc3de8f13fabd4d83771f5bbdc98b5c4f54900eb4b07412107b9e6e9c41020c17a30ab9474adbc0b8fe8460abcd49ef8d27497e208c8787d43b9b937a940cfed11265511c1d2faef4423dfb4c0da0341b7ca081e661119620d1587ace24c04364912c2d4618cde5ea86633efa71aec1f3e72fc57bdb1b00b09700edb2f232c1cc0c3a62a2866801840d2a28af93f7cdd4aaddf11c82323ecdbafcf52abecddcb09c2f69cb7ab90b69dbd930f6d67d73bb442512b81a35455d5591510e2184a6c5733019cd6858345a46033c86a0697eadb0968429ced50d0f8e765af3a04b6c2d0ea884ad0a7252c2ee5647f68780cc01051d31effe0c1b1102abb2ebe3dfe5d65edf513ce3065b0585f4629764e4df1af61e7cd70cfbf43161767b1051a6079edb16726f5628a530757506603206ffdc05791a5c2917c97eb99f7d3991d3e9eb6c53144bcbb3647582f238df62fc6a26933d088ad155a6b89f43495f3b3b35ec665d291b54f242c356c3d4b0a5a7bc1ec746e4af23eefc8154dc3c4a35a87a01f51649600b41ff74f80b8e07d17783d41d947702a1936c95509bef47db2aedf2edc69086bbf8853e883595fe667e9464d546e709c0befd588017b3f189cf4ef28752771ba4bc941a73f7b9e24964eec97e227a9ae56246d642480f9b1e369b8a4c62576176292fbf3863a57f6027e3136a4bc97c6cdbf5a8ad333dffbf9d8386dcfd629b032b49d96118c7894b4e3c6f6888cda86d3be4fac9f2ba061caf46c8264d7ba1b0007e74348e3d4686acaaf10866a359309bdb608a05c7982faef7a1358dcb532d34ab3cd50a7cf517d143f3e2193b7269ca86fbbb5d63c000bad159a22bb36c03303cc44b41dd4bed924fc9e9c7616f9b519cd12399db83e95a91baab509be60a1ecf966f898df65b53a7fc7e138b556e1c44010f02d034c1daef6d5ed85ead220473714499daa855cc2294a7073b6a7c9ccdda13583480054c0f3d9124b6698d0a711361859ef11524799c8a42b3d14ff525fc5750c2080e8823856d0784d1993e552c9fd54c975fb1cc1ca3d7ee0ab949e8bc7afaf8d300af58b034a47d62aa3ed8692ae5fae02d92c97bb3b56c2cb7b07e9d53d47ef0876b94ba7027a4332d9187b73559415af0ee471156390c5c4a6e8e38745bdb8f73588e07e0fb271fc9f1efb9bebe6649a60e779b7e77b8efb4ccf25875e3422f121d7f57b2a3f4cb83005174afb55dd1b6164b0211842ca189b2ec5c1b8402f630d8f1fe0b264a5c3f02c0724f324b1d1a7cc7bc8e4e88a5e3ea9db09c62631c83ce1432b1ce2233d8cd4187578ccdb7aaab71fb8490196ab31999116a9e0cc824ef63096e473fdd73ae8fc8bcf8b1f8386f75b0cbcf66c1f7fd9006bd6d7c45cd6ed6e79e35ca8446a5209034592a9094e5d4f122316b080e55d9d19e9657a68566150eb89650564ba3ed930885301c7e3275d90e870692f9c07fbbe069939374995e8eb00cbc8f09d2dbd67592767ff53838ca3b2fb0e57d2f548dd12f726ba76da3c6dc26cbf1efcd8b087a6cdac7bc0dffcd79efe31b86e126f89d48f5964bebd8a308f545b7acd09f91aa9f60895e9cb253bd6a92b60234efb4435930b6c3140d591ad93cc3894c579fef85e8d3e235f0ee853bd5d0701a8cd1643d1f5cca0210ffc58c1297c5c249a634ad40d853c21fddc3eb60d13bce8ca9a4a23f09b090cc7257d881eeb1bccdac4e221496957f6377fdc7d1a5d2d1ddfc51474e30a2c4681e575f7a62405eff7030afcfda7b152cde2726b96555926d0e06fd8944ed1a335a0783de7bd5c24ab42987e7a8f2e576260cce56c784198017d8350f5c2868733609c0464135f75c1e7bb07e8b5a1f82068366cbcd338a858e4d6608e27518eb2c0dbf52079796f27e5584c4e0f6bc6719c71ce4e35b817e82b6386cd6d50a670c9445f5453c7b575cd79d12f4d9803c9b420d817fdf152d126dd9c25388ba239675cbbe7acfc6a23ee2e1bdf3b65b944e7de95e359f84900fde04232dc389aa5a85e06e669a340509dccdc1b65f0e0f9d3fcef71400965427245c8c1e80c6838d4a95eadd4bad12710e6c0d75752bfee84da2f7a95ddce42e3fd8da48f0a4fac4f718029ddaedc376fbada3f6c793f2d50cdb024004fc76f9c8065938f6bb939bd781877feac035b4769cd7837d1ac6a4ad11d91f37f17b7ccf3d5b0b41364b44b59bad3b4059e181bdd54d1fda01bab04cb38727427803d7116e5c0aef6409531a5041fb01e50108c986a11499f0f94fed906c502a7736c1bc0550d7b86f60f156a74b1f011a65de5b933381c18ef3f8228ad2ab1463048b5e690b0fc3f67ed62a05a92c0b1944bdda08f3cfe0147d2909b1af83153f8cb8096f4515ec59fe42baa60d1ec0f231d67e7929d949c5ffab0f86cf819d757ea5940a6a47bbe6c20c346237e7f039a344ede407cb9af619f00ddb2f5cd9acef9f0c64f8ee812b284572d9cdf55248cfacadb8a4bcb6ef7f6ae37e6c26378e40443f0c26e32f3bca0283d72c018f3c46b328a9e7f213dc0ae202f1ad3b76c7493aec89c9b1a3f8dbc0242ae0081a31858916a5b256cb808a0c5cbac9353f6b157be5fe08a03ae075d3d13ee5941325a181cd6f08e32227659b2beef25faf89f9c684714accede9ebc68e72ab0c995424f6df974b0c05dc7196a1e9ead1016068151f708796d2e1d3339070b084703eff8d775808b34d2fe6114b8ee67b90765f4157de29f0410e9dc89c9a7619f02c360f9cca5a7b2a3daffe7a393c47888178c92bc7c01695507bbed3b5d5071494595580fbebe3609ea23f4e8514532bca9fd9a94483090028916802d9efbc6e250ecbefb509ffcb3a901ec7b1ef268d521fe8d4cf417e5b9e867bf11276622a091ba2dcb6cac400475ca99fce498cbc9dbd44f68fff1eae43fa92736e93e488f8057e97dd67b6057cad93b0b668cce38dcee8d7bb950079a9bdbe951d9182a5509f79bbf51339346ca9f587c580152ad1ad2f0e05f1da1172d91efb3a2d26c1de18bb80760a3d26e8c51a34b1772cb8cd5b4f19ecd41d02f07b393df2ac18ef9637972182520a3c18febdb51b7697b1b26355b48734a0ddfd89722520a24885d21e52b618be6bc867a6e545c869536913c0eb22955ff3f01ea42fd2bc59150a088f625b895df74ee025d664ee60a9f75d55bb5736bd20ca472e27f7945faab25791ebd3a2a2993f04a943f4f1b622ef439f8b6f2c132f24d045405b7716a2d36a030f43c21b820e22e1752216d7c5c4ec263aab46fd82cfbfa29a3ba594410df4d08f1743abce88d3a494a0fa502228aec4e6489491f6f6cf72adb445227fde55b5bfbcf780409ae431d8f0e1f18b50a3255e4160ff37e91b095eb8ea4b8047d76382c0a782982b81c4f10635b4da570a1d8f736b11007cdf7fce328bf34c88b7259f3bd835ffcbd288a45fe4e98c03fc2eedabc4fa9c34cfbc0ed0b4c5566e2045dcdf765ffa6f9833aa683e4441bee351e314eccf8673cc2e2fc70e361240bb5c82e7cf4fc52b5efa1f7e6fa04bf54c0d9e187dfd2641eeac18c3725afba0a63a2857fa7ae2e24618d591b63cba5faea3a71125c14e28c4d85f5b58304aa2c3cbb7cf027562d8482cb93326081bb4867b01c431658e0c05a2ec28e8078585666a41dde1fbb32c3148c2c6ed9b90f68606fd7881ec020dca9f79b893df32194805fe94dd9f9182f9def2810d9e2b7c2dc37d15cd72c28ae5733f38c95f4bb7e2be061e8200cf0bda2a40d1464c41aa645a0519074851cd319e984db6c0c88152e4d5b903c96d35f888b9969708f06cf3d59d7f354eeadf004b4054852bca37b9984c81e8a9203b938a76316360752248f3d09e441d001d2606330e41cd5ca3d842b68e2c7b2e81402f133139288e70d826ac8aaf1cfdec99c4ec6f6b0bf218641446d41fffcb8d43eef68e7693c41c59a2db88553b4bd62f3eec4482828400b4142eea83614be5696f0ace2523310ec953b4214d2f11bbd61323ccce305aa2f24158e5267a61c0443297381a2c15c0213933ecf6edd8f5cabf50d90b0d27f4c3deb9ae6df98d8cdb586b7a775cfcb79ff0394087a4ba126bdefc1d5dfe11d9eaed099bb2716bd1370e5f140c71a35ae40910255687707651c454e581a2f490251a894832ec075ef6afc75fcbf12b7bc3c0c9d2240ec4e71856d154b1d3a888296da2692b183b2ea5622f515f12d75ce64e416088c57323177e63643b566b48f7f2c209a8fe2be00f417bd2c38573259bf7fb7d5a6997a4926d1d526841948d1babd59c5b1f3d7a0c4af3aefd7d09151f5ea2e53ced0e0e1f36a029c6ea24fdeeebb661561f52164b03368ee98e9002fdaebe34b3fdd2725988af6d1aa7eabfcae05a5488fd97b6f1c51189172a8a62bda8e4f2bc960427e97b06157380a3197643a62c8ef368bc78785637e4779239ea828862ab6229ba286e08e0f1918f9bf1a0677b0a90bf7de059629bbc6b5c33671d395dcefa35f96d994882679580256ec3d0f932e52e4eb419dd0dc12f0889e2081d79d8943be8828e7fac89dfaccaf9753853b29c76e00a2856b0d17abdb20e06df0a6c9a1be31a4d5cadac3b9d85792febcf857278dc7be6e523f9ff05fdbf9edeffa63ea1759db0276b37a150e50b2cf3301a340df22cc95429ddd4e60e19257839d4fa8145ab44dd048197fd87561e46eb2a985f55bcfbc7b7d8c7f7fa103630170fee3461c9a5dffd478187a0ba702fbd27b79a0d2870c4cf51d6610f49626694e1d4fa6d060655698138b723b75f1c62c5af56ac86d99a055a8b01c957092b681ebe20630df7094af785210c1339098dd158c906700b1115969aaead0cfd2f4bd50d8add88b009b0ad05392bb9b60d7515a01b7442c4a6a2d414ebc5870cb16ac647e60c31ff0efe916a694a7e2bcc8d26b4e3d74a7643d7f913c599e43d5f8902391737d1f6467b3ded6d501e0cf0afc8b3e366207559461dc119f6d6bdecff696360b4bbe7ec275329584c1505e5cc791b1f794607aa17306096e1bc1d37b04b3122bdd24364a4a08bf8ae4548783d0801c841dffc205a1dc5c7337f628a960b0a1c46b2faa2d6ed5576069e537f359f3bcf272675082c94b38261928d4cee900f6efad20964ecd967e9cceff991c99b47a2a14f8e544ae6e2f68cac092bc1281c2bbaa06d0730c62664e2ce6334430e475a7a1b7e606ca9d47eadf74178c8bf14c6e47eb4a52952c1cb00ad511dd260748cb1ea9c47f0e8fa40707e2427edf9e56879e934d329847ac4fb0ed917c0f3a9e7b6e89e2d8d5099044ab279746fc0b01ee5306958484a531cf7a2611191eaaea3abc2eea6ce8884bb6a8a0615862a630239b0f28dbba7d03ea871efab7c8867b9e58dce25bda365588a93905291daf5051c281d6b0986ad6607ec71eab1493e81885fa95497865e735f18ce2c67ff07b0c2d43731475f8c68e4cb5008ef85fffd4eedf7a4f4c28f80b215dd7ec0e29c53bf91cc56f7f405ebfb860f777521ed6fb188417b44ea3a0818cf095e49f67c01fbece709914480e594e56a7594a25cf48c85d5b1580a3a0e271449058bdf5ff5af1e2605268903ecb68bced988a2827d3acc1e414b95a94db8a9172d1b55858e470e0ff4b1ee063f83f399706192efd46a1bc823e88067702bd7fa871122465dbacadbb382af4a44f5ea650256dc3b6de9e9922d7bf699d6642e6ad653de909fe70efcf4e3bbfbe60d3d7c0f92ac59b753a31d3468e576a5682294cd8ae614ef0e204eeee7897943b364da8b9d19d05ccef5aa6bc6fdd7101ff9a283e0051328198dcdb1b2abc42d7818cc7e439d4687a40e1bde9014fb1dcd78e25cb74785403e30c1ab299a9c565b4f831647e6c74bba2ca6a486c53a3ebec88f4aae7bcd9818adcfc692d91a390be6e970e403ebb50695050ae05e5f5b795f91255cd20317371b4d743a1e23e13f2433bf6b0cbbad1de72006e3ad8d9f865d954ad0a0983dedb2d6ba787bc5804c1fa22903f9d85b2afdb007b95a378bba56d2fe23408426326cf08c3cbc2eec160e7900a439ddc4e691ac06a93d6468b2d78cf857f70aaa24f987e02c5d77f43df0e5247f499e48f0d048ec2e4281fac5d3008e6bbf81adf1e04baf029d95073c3ed25db4f0204e41e6d352d6cfca2094f1c3e8b4947c508e26be945b28fe39bc04c4bec46d62c13ea2e774969510150064527ec39c1306b2e10ebf52191f8466185a97daa4288912fe57fbc2ceba43c16110a9095a9699d23f9ca23c9f1368a31221bffccfe52a6d009318472a6d5a1747d22acf5fd4218b48923efee817a26bc97e20c5b5c6c2125a908237690f08093510a71ccb74e2c21b3046fdb8920c9cf607882bc7cc599cfd2bd667c2558db0416a5a7601eff0edce47be7f536afee4818ffea3e66ad25e4a9d3989ecf12bae3c43683c6dcf4ae6c65623dd4fc0911d1b489b9f206d5e66b34c12c0123e3fee303ee2948d3aa8a6c1627aeb43eb97ca7e587191a60bcbbae40d7145f2f695d09953be0947b5886d08f0e70c7717aab824ae1b57a1c0db956aa49dc5605f21ca24196b7e152afeb783a5b708462393dda7b0fde785c593150704a3de5ca27ca0cc08be94815d7f64bd64e0ce17f3f9d60686dff83315b3fee24d10a9650cfb43a96431134019a9fb303485471e8629b41f21940f0d15fdaadaa4c25954d322ec3941b09bf1ef9d2c975279511e02c5d48085d2aef1895d98835d9b9fa0ccdc320b4040c406a998f4760229223bbb576f135066aa760de10de264484654209d4018611b8e0168e93106bec9d77623b9e54b0f1c306cffa79542b394ef9fc901d69cb511a145150c99886d51cd4e14df55511e25d48178be5784685517a8047f79c257b2d093da38d7c69875de1fd83015ee5371285c077c917d0b52c1d5cef319e4372e869879655587e2cafdfee1d6b6d1f5a64468660d48df39645e23d17f55ee88b0d8e576f3a9a351877c749962330d7af2b25a60fb9a613fb7ab7c643f96d43f113595d59a982af681e5727dfb79b30a91f1223bf6679aad97cdf7a1370a65b36cfe117efe9b6e21532e867411d513464098005d0bd5be66bac2101593c4890a7f771f6e8b6167add183931254a8f265d73180363868937e6048d7283eaeb40b948a22ead5b021396d2031cbec161f6e55b8a559870cafd815abb5f0a1a0a40ea431d0ce170ded80aa574a742b655bfde9c14471e89fb4ba21832a3ba125de1d78eaf0a5cc3f8cdf9843c3e4cd3cbb4066c932c73ebb9e0928a18f04ced9ce24ead2de26e4a69b143efe03d9ddaad000b4bd92ac0e0d10ba74841dc700c42a5072a8c4580d0a83692fd7f127e1a5c13274077d155a11520e94cc569f14af709bf61ae4df9fd200ec73f87fea44f70d039fada50fb68fc4adeca3316893e137818228a0a86c9060d3add5e147549af5e99ad9f69a1c2ec7bc8d5c37adb0b03a8df7c30f71396c6d181828f14dade8afacd3a188da742852a5a1a0e00040cf9c5453e6322f7c1a9e3219018432590b56d5f6c5f5e6a3497b4d9b9ad13a9778fa82ff755338e50af918a25ab5993a1aaa2d5abb88873e9a4b477d6d46c877a2a44346048409e5755ce69fa53cd222b88dbf407dfd5a81fdf3d4bfeeb18a438b9eb1f8c676bd0115d36393c95202c18dd2e09ea06cc2a1f682bbac5366ef2055f63a8732cc6534227bdfc702c587f558f4e86d2dfd719ec4331bbdd298eea7d63c4fad7824ad4e22b13d6f2c718628fdb424db3b5454f1d630074520f2bae320c2ed9c9e939768e51b6e32a363d44b55001360b6f628d4d0c3d5188ed7c824a76c125114d68ec4427e5bc9560cbb676de8ec55a5a843bd83dd4c397293636abfa9c157ef6dc0c92a80d41bc6f72d6377e5f0bc833915bb743674a4c6405cafef5dc06c4646b3f63f66012f1d9432d7cae9601fae9960ed2f02d2710f25ec0410c5d27f11901477635fb2f702dada7ad2517ea5b71aa7ab5642ff9e6758de80b814ac49ade48e20043fec86104627f5618ff17c96d5be13cb6c114d1d0246f810e8a75937e1efda9f4f44426db41eece633cf2affa95ad89389a63c491e5a3a405ec3f804a66b6c69e4513a0b52eda0159990ebc3cdf6c153cdb2db2529eff55a13d2e342b4a90736d53b308b0070d66995ca8bb708439b9455b84a362e0e384ca8042efa35c864a467f0911ddfcba42933c32760096da407c467bdec372aed993bd439d08d0402ea46d36bb093edaca55acb9d94afbdf09f7b4ff8a51c52bbe4ee40f15996967e28a9146b8003bf1508e399668f6b9bdc3eb05ef0c209eba9c995a514b230f5c511744d6949b08791018ba7bd8ce48cb7de1575f05084bed8990bde3e22b45927e0496b6bc04559da36d8e3546f38c60d2ed142d658cad0b659a613a47903481d3cb55918596413d403afd38e1eccd9205a2cb73aca130ec76569a9413d96e2ffcc5efc32442aaa2148ba49ce866d97ce456fc2543c98fac82a0f5ff683e8db7bb375f2c3e9e3725219f6b3c1fda1165aaedc0ed79b11038b0c66c0bfd2828c9edbf68070e3811cc39afadd503ed9afc5899f8c0511b61d3e7efc4a5bb72e93e05b5dbb1612dd8955e83036b61d951a190ea167558e60d6b55fd60bcac7e6915fa42221ea17af1cee8867bcc5fbb61d8d15c637440f44983d9e188124ef128b1d26fcea35fec1d0abfcacf56ecf1db96f4f08dfe325d2c24eb6e0be043bd1c5dc858149d69f28922ff78ecefc3e091b0d768b432c573d53596e06dd7f442690c2ffcf5751642c0d0b1f13ade6c6c1c01afd4f2fb7d8975f06eba9a3e1c6ad25164e56a52f23bf1160a61b7eeb123d499d2173dea0f99015a5e351a63e5704434aa6173378d2a48c2ff64e0100796384bfedee423edadc7c5661745351a5b99f0584a06904b665c644579398f0e82f0d3445e03680d0bf95802923132bc0b0a227114fe07d883c146ac9ffb5e2a8302fc9c1c7dbb28cdac97a1a6abc22b6cc5947de6d735553b02c4d6adf34bb829e3ab4c0c30942eff3e5f5629b0d93c888e2e2ded56dc2f451a8c96ba30b4c9e0cd0465dbab0872ec32bef3ea8a2aa91efab2b1e1601ea128f972a17446ce3cf33a40a25fbbb120bcea4bfb89a89bcdd8c76efb91b1dffb21ea4ec3e6ffd2d9ade85ec74f5abf9ba97a497ebffcef3d5cec6c1e978015a5d3dc91f1f6abb25ec6193f52dab1508a38906ab06aa8cfa66eb50d43c6fe7d732add95d774ef3507c7a0d91c9c61f1625233e25cbf196963bd1f58db6d7f376679392a906e5896df2b0e80080ad10229cc4e75201426e9c4816eb6f155c180b5463b6ae2b07b9c394107ba7a0bf58b4d8a3dbd7ae26c5aa7c04f8f566f137c2aee66045057094da5db02b9d5d2dce4e58c08501856778c1bf131f4952bea51a761f5eba288e4b85bf3e2268660da3d5b8a17b21f19d7b09907aa16ceb84193575586f967b21506438b9ab98e118b0f8569a752292a40d5346388d541d9ea34124cd916c151f5465f31dc0e911d274b89f957c3ab9d351df08352ecb4ab83ee7b3c920ac24595c64a3f1275508927972702e2ad9f906ad239c9a2e5e5669083efd10b77a12debcc485b6930d126546397f217e63f5255f8e8868b453a872a8cdcd27755f3eeb973fae0ce95bb55bb4571e04bd68dcfd06b02c57d35ec713fed7e16297fd2679e59046875abea15ff7c8f72b83810a0bec92cef5c5103e2984de000fb81cacff4c29ad13dbaaa22282266107bd6030b272574ddd706305a3cc9e77bf550576a52dfa0fe6ccc0c8f9cd32d458c9fbc52fccf136a57820c3d9b303d6afc951e78ccbddb4bfb6e00cc3d7ee0bd1461e87e3e3be9da77811b8dc6526e564d42af488edfb4dcd6a537538210484f4220b90f5aad5ea99375baa405bdbc9c12d721e0a9893ce0694b947f120c376b84b33718e8797cb4efc966d79b23856adf60e3e3655b17a58af99e8f1e140d5a82430e736ce59f66420af4e74c8aaf13154573d60b47038aa6c3b1a5d4b3c433c44dcfbec82f86cd15373e2c287ce370b7eb2022ab16797c59d8b64eaf720b5001e7b786afb3335c3aa6da9cddc31ed8168dd344968ed84169b10696e8848997655eed69025860b6e46f81bc23ed3eb30df1f69017d4a7ccacbfde506df13364aec0427c43d097e48a8fe756dfde869e98bd8a671ca021e1437ff073bed1f7a0920b4ebaa4e1f6962f13fd5aedf0640597f642699ab33fc8f6504ead0cd1986db4a5e297be0102ca076e105c8aab03bf7959bd27b25efbd43c6dd02fcf2ed15911d889179590302e93ac648f6488209a37cb8ac5d8dc2f7ee3ec33beaa9ce7cd72812523f85f8425dc5d2e0608958decdee31c7644d8119a810751cd8d193c5eae52db4289a4e4584a957e12d05265a9d0ce3493dea5a96a6b9539c0128a0028904972c07fb6bcb6b684e2a186a0b2984f82c28852170edf50c9859bbb169b62fe2e04fedc92d3b9a5ecd45994c32c084fb7cc08034f71314f44addcd573aaefc94bcf991481a4deec9326a7d19f6b8bf34060c0eff5bc490a60bc2e85eeb9c012a4d4d63cfe4398d24b3c08b40179f676b2383f6b057ca8f6db15e8520112591a25d1be2a8a11ca0838ac8f20ad7487276fd0be4058bf84cb08178085592e8fbaf13fd9a0abe6dc8ffb4292a36c984d5964d79d412d94771658d1422aa4bd666f1f184961e29708ebc8097fd8f5ccfcbc5bfb8ddcc4fc4b71fb0ca4031e2557f6082d4857b53ba3d1bf89e842940f62bfc8f2b37ba6a571a868dfa789e641ad8212ab671ab8fe2b8869d036a022250e47758a43359cf36f517672ff9f88994c6d837b936d816746e02d00de7aa56301ea928575bfa9b793c7e510ee44a212d7769d261299cd4747c9aed9f2fc69aa060cc476f6a4fea778b962dd8ed83b8f74fb7df0780199f8f4c26083a5fa5465647dbf13b511dbae82f1ea956bd990b339ddd1c6808fa9b9cca2838711e77e9869eba311989184bff7178b27d115554a6ce5dbfc8c2455ab47e8edd06143fea8aca305935fdb22f43795da7651c4762cbeefb6b7959e9e26355898a37943e0d53e09d9df58aa9602485abfa4aaee26bbaa28ffc09ea7eb893fe29040d0a82d069143e16be8c47b3ecd23dbd34b4e70843fc0c2251379d7b0d608c7eeb99d993aa6731e721a26147a07fb19052ef56462ad0fcbdce9d3abe073d19feb4ecc46d2c09ac78582c92a5ea13ee02126a053a8366e667ddde628d9328595bb893c667cd36174fdad6e14d9dc56a8d4d63af1abb7e142e51f41e059771b7c48e7e99857c1fdba34dc7416a77afe1702f3626479781f6e13d0c3239973522cb786274e679f2d366678454a3e81b6eac132278ab63dd2539a37ae258f318a4770c628c786a13fad5f87f95653ac0e849473f67c91b3f5d6eee11920f0e3d7aec81bc1f728df291bc9197faabfd0ab92c0a16b1c9fdb4323f1622658281195bd75a67176ad481469a3c9ca5fc40b5d1bdba900c80d293adc13f8aded361ebb7292cd067904f2e1c14609c3bc44864930eceef7c0d38bb89081f73a446905df4ef66fb6d77bae101559e67a1396b81de200c7387fbfb9e5c9dbe69afea527907ad29003e4fcf70d61d7ee46aa9082f9ca851065414b576d4550588200767c3b4b327e56d505637c164618f186a9ccfb1cc3a309530b9fd3dd4ecadc4e4a519c712195f592b30ee0f72b89db6ce313669378503787f31676c14cd2278831e7cc142dcbcced4ff9afa33c1b86a59ff9540089415ef6968090947c73ebbdba3ffed2e4e1f8119ae3294bf2551d525ec4550d8932f5dfd524c7c21dc2d578332b6b16963a22efa739742d44509356e2c994b94996f57df1613bf1854dc7221e291bc306ce4a3696a72bf4096e63522b78eaf942f6c5797831c4a177e775862b8b99b6ebc3cc40a3fdfcf45e1f8fe387deb0899e960d05ae228baa2175df4eb55572be0807caf8d0048b2941411ee65bd35df016e807c67c8d02bf14ace99ffa4e2fbb28218742e95400f14d6dbcbd4091409ea5ea7afaccc457833a21584ce2ba8fad0688de7d12647c0863126d5af08bc3711c1239af7f2e689a97cfe2342fc72ecf1bcf7a3e0cdd9ace52ed9f56078a7f60398b49393a1ff45e64ecf8258065f6062cd0adc2da4f7111ba2a656284be12b555d2194e9a7c1e19f52d487d6d4fdc8eaf846c168b4829e07092b178a2c7676972c53a732270eb85a032901f27a0685fdf33bc9584abc49ad616242eb72f1b62b070371d6f9f61af8031cd81013e91040e2892559afdaffaccc91c22246202bb6fd95aebedbdacbb2b0e1c504c76a795333836ac034fba48865b31f187af5ffac0a0e5a34ab1beac7eccc022a71141d2ad9e8f1fe7d9a01695f4280221abc2c86d44dce7e1d66593521daaa254674f4a644b5f647bfe706f0dced4a3dd1e9f9e624b4255e68d5ff75a45f8870da63a405c07b0edd97495286272d86a8d925b3e9e37e0b5e645a0038864c6a41e9b9dafa429270c2ffff371195d4976942a46be99f8fbde837cfaf097e408fece189ad2024a4ba4a87f214b95c92400b5e1786bb7fa51aa2c824236da3efcfab26ffcde40771a18926651277b071771c9d42d5df519fb357f45b0be8897a775ad0449014c6276b50b84c46bede7a6b5b021487d88659c875ba78aa0cabd32cbaeaf3107cf20874805139e6ddb0272c7f3cde5d4ccaceaee3b4d5491c89b45677dea6bc9bb71c9a79dbb2c16d31f68b1558a104e1294c42d3663f24b934e7d7739a9f3adc57dc8f12166858e595379319382738f54ed2d8f21806b60d291324487a98507c113565da795d64108a75f0411312e06788da8f6f9150cfa2dfed91f2eb46341a560250e257aee5b03c5a90c310e5a9cb4f7226785b708da048fa29f89c34e8a212449a8e52774a07429d030982a33297cd3251e10c55d1ec234ef9d57c5d1da9e037b04aad473840f6d0323941c60bfe60db254ba275d246aebc1b0f6f0eddaa68fdd320be23908b32197873fc1cf8868aba806346c7f92790ceacb0db2510369810d68607c95aaf3c241663a86b098884b9136065904da1c580d1c923003559f108f800dcfb6482cc68673bccefb0f2ed6d9b3e64697c5032ffc5c0f7bd47017f293aa12e86c1cff6dc6d54871f1312c43ec57855f0cf114de2bfbe26a8ee9f91831d5ddf3198cd9f4cec7d5cfa849beb5779cb16f1bfa5b5a8567e52be387db98cb9beb623c0db5f4b92c5a2b769f51aa385c8e43101f5ce2f2937d8652c9e6ad7da19d388bf9f42872d424a9b0918b249ad6ca07f4684bff3142e7a4def89ea8d7d6169652ce1aabb4b718134df523cc913763beb4740802a30fb29f4d121ffc6559a58d3b3492aebd44f29b7cf639227bed9a876394b9781d03a2cf63ecb700e8593430a39e85a9fff8536744464affb00e65bb6ec69ae00ddf16c4ecaf9d2162794589f08de8ee7468730b8099daf67c96777746211cd9a8077e67f2743adaf23627b3e19fbc25f36ebc1fdf89572d3f14484cf12c26e1b9a49d1e8314cc522e2d840fd6b486a4b9042188aba6e2bf505aa80a51933d324a3412b756fc6ba6fca136b9431a76245ff62ed1d4611c05bd9c83dc923970324b209e2b0627a5aaec12243e46520edd8a5d757f66204d37153ee719aa8fdc57ff1f3adc830899c82bfe085990ee73fa6af5a92c81b4d379450fbcdfbc9b4e52b961d157d3afe30f14ee9b458f6eac40f1f0f67d3c1c05a8d956a98945f52fe87ded49636bbcab33a211e71138459c01fdf4ef4d67719d0363874215097ed22513a11b5cbc5e9da6018f186a36ae8f2dfaf4e9badcdbaa571e25a4ce725f029350590e24bfcbfef65e11d38244e22564e34abbe4ae6b8d6137f10f11fe375280fddbb0ca5abb44b3b2d2e8c4db567a02eeded6ca066a3e462a5a8eb947ad71fcc64aa73dc5b315f64311e89590db942ff0b505b289f776bdb50f82e0a1ca7d75e593cba86774d91983e50c4a917ecfe161c581dd3760ed23c20ef5d834b0a3b4d70a0bfdbf990cefdb56a930903fc004c0eba865bf53856db168f5b39c5a7f4385f5aaaca4f69d2bd04afa0153687f9c5721527b07b196985cf764a75f43dbbae5102fcf78df1b61bc9cbbaea2efadaf508d0a749a001aed2f2b6f5d98a064f5dd7d91fa00f4e36d174d3ee22437931afef4b84d127ae95bac2930f6c2ca0f66f2a8d879d5abc86769e40953853cdaa9e14d1b035cda9957bd963349157614281b21eebf9b0816cba698797c722a57560e5b06a6a4e2ce23ab30fcb76e1e720694023514e1784fb474f6053dfee4071e9c27556ea86f2fb5ab7686fbc2e9b928562282da8eb21c1ff0e75ad061c4d4d84d88c0d496621e18843ae41fa61de227f867c2acdf2d781ba8b81e3a15398add680663b629bbcc6d49f3df932b4194a4b5925a6b4ae8bf833e249e06a6a15c2ff2ba224531510b08b51cda99c2828f02fcf894a6a9c0e0de72570155dd6f3220cff540346cfc245d3779fbe59f250c29ec9f87d28e962087ff347cc5e10d98c2592c95668472f180acf357acc429b482057501beaa6ccba2243fe52a8684ec64b8e9ed4ea1a9b62a4b71192a353638b2ba61e899e54c25a0674f540e40d805f6af170ea7723c6ea00bfd5621672bf375dd1404e2d71a26363369c27662d0807ed39ab75d6df8e6fb13a012e8a8456c479d60717612e60fbf17adbc2279c5fe0c71abbe335e970a96350c18ba0a2e592de498e9005a09a63fe876d538f6f85891430c0b95a10c8db1422cfb850f245d8366a16e3188be8fe456925f635b9d7d6ad3aa3aec63dda2a6c0c9095e771f62b210a0844ff3e5fefe38ab4934a6c8a0095466c9b7fbd2c62e2302ef02e71b9355addc428cd50b57dbd9ef4c613fed3be10a5e0c8b4295c67739bf1a34a9b02f4693eb49211e072cad80b9018378c38b399908654725e897bfd7e87ca85a330f6d8dd84bbb7d4ee39af6c10789d37dc6cbcfbf138466f266d69ca93091c5eac8d574ad193479825b76643e0e50deaa71aea282dc72f79d20521885d4a20d654b95781ea0753ef4d48279707600f18be37f6ce90d28ac6d65665eff3c21353d2e0202d25734e62ab800ca8542208bdaa3a45186fa9481b7c61951f79432ac335efcfaa06768405b236eebe1f25aeeb67a61a006d78da35fb217839ce344da912b6bc918b960c0885e9bf4bb71790f9e89227b5eb3db916f52d065736337b60ebd8b1aa816541c861bff12598eb267712b0b6ba2f7688bf0cd229d71cc3f24cee018b6bdc5c526e3c898126d420b5a220ec2145aa9dcff924c31c92603a007cbbb42e368fea5e47333ed856ec6212831f323eba91bb7781342e3ed91f02e7f4b0ef28aacfdb20471490934271e8b37e78f34054ab079f8740523b1f19c44b56f1282c10be2ccd1e35f16afad0b2853b35fe8200a2b689921f97f077c5e78bd318aaae778f18d1e481aa778a32b4efbede2eeced51455e696073a1b26056a6289e78fa429569fbc8cd3a11186b08a2bfae31c8923e03010264cd555ced69736daba70e71d010a947e82e01152ad09c129f70a4e4bd09a712a522ebb438c71abbb8d8a29571bed48819078980c0aad04cae1288de3ace7dc02b4aedc10d8bf98c7e9733f8b5e85e946f30f6512416fd3c6021f4bdf8a8431852b789353ef3e2e3b5db49e59cbc862db0055f0b3a9d890b6b5a84efcd93eaf2d3bb81ee2595f326017949eab396e0eb0c84f9ae4ebb0c19ccdfd1f96403c717fddebdf65211201aed10bf187c2bdb9c5ff56818e4af04de76f459e38300f9fa6f50d4cdaf2d5a52196b4057b42236f85a7f29d7e271b4805be380fa0bd60787bbb23ee5ce2ebd479278e9680dd01efa93f55dc43da622e2948a354b14e2c14fdd15bda0a9dfd3a8e1ad7f2317b9b83e94b49954ab733978761680eb805715200aa61ca9c091f7298789da5284c5468d2cbe1b2db7537321dd29af1c2dd1c6d09a1109673af0e7922fc92079ae9244018029629732572cde9ff231c5dc75b2cc22d121b45433a4b88c3644f4e6e898a9b0b22f29cd3dc701de1329ebc31b0261d1bb1586c6a36fda50787e1c9317afa5387bc0f263043cf00c341f8a278a7d5c48a889c382120f6b24f570e9d8a62bd786c58a9dbea7c47e8797d0bbd38c46e870034d35a51643c84d02b63637ae12d0f727fa4427e55926af221436cde07e640268aa989bf900cee913583529b518326cc455da2e4edc0419ca086964cc740d95968a0</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输入密码，查看文章</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>旅游篇</category>
      </categories>
  </entry>
  <entry>
    <title>SV系统验证（5）——数组</title>
    <url>/2021/04/09/SV%E7%B3%BB%E7%BB%9F%E9%AA%8C%E8%AF%81%EF%BC%885%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h2><h3 id="非组合型（unpacked）"><a href="#非组合型（unpacked）" class="headerlink" title="非组合型（unpacked）"></a>非组合型（unpacked）</h3><ul>
<li><p>对于Verilog，数组经常会被用来做数据存储，</p>
<blockquote>
<p>例如 reg  [15：0]  RAM  [0：4095]；   //memory array  4096*16-bit</p>
</blockquote>
</li>
<li><p>SV将Verilog这种声明数组的方式称之为<strong>非组合型声明</strong>，即其中的成员之间存储<strong>数据都是互相独立</strong>的。</p>
</li>
<li><p>Verilog也不会指定软件去如何存储数组中的成员。</p>
<blockquote>
<p>wire  [7:0]  table  [3:0]；//   4*8-bit</p>
</blockquote>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1617880207229-9b8a1da9-b145-4095-9f77-5f86c710e54a.png#align=left&display=inline&height=181&id=UKuiF&margin=%5Bobject%20Object%5D&name=image.png&originHeight=181&originWidth=432&size=73462&status=done&style=none&width=432" alt="image.png"></p>
<ul>
<li><p>SV保留了非组合型的数组声明方式，并且扩展了允许的类型，</p>
<blockquote>
<p>包括<strong>event，logic，bit，byte，int，longint，shortreal和real</strong>类型。</p>
</blockquote>
</li>
<li><p>SV也保留了Verilog索引非组合型数组或者数组片段的能力，这种方式为数组以及数组片段的拷贝带来了方便。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a1 [<span class="number">7</span>:<span class="number">0</span>][<span class="number">1023</span>:<span class="number">0</span>];  <span class="comment">//unpacked array   //8*1024-bit</span></span><br><span class="line"><span class="keyword">int</span> a2 [<span class="number">1</span>:<span class="number">8</span>][<span class="number">1</span>:<span class="number">1024</span>];  <span class="comment">//unpacked array   索引的时候高维在左边，低维在右边</span></span><br><span class="line">a2 = a1;               <span class="comment">//copy an entire array </span></span><br><span class="line">a2[<span class="number">3</span>] = a1[<span class="number">0</span>];         <span class="comment">//copy a slice of an array</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明数组（非组合型）的方式，以下两种皆可 (单位元素 数组名 数组大小)</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] data [<span class="number">1024</span>];   <span class="comment">//1024*8-bit</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] data [<span class="number">0</span>:<span class="number">1023</span>]; <span class="comment">//1024*8-bit</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="组合型（packed）"><a href="#组合型（packed）" class="headerlink" title="组合型（packed）"></a>组合型（packed）</h3><ul>
<li><p> SV将Verilog的<strong>向量</strong>作为组合型数组声明方式</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] select;  <span class="comment">//4-bit&quot;packed array&quot;</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">63</span>:<span class="number">0</span>] data;    <span class="comment">//64-bit&quot;packed array</span></span><br></pre></td></tr></table></figure></li>
<li><p>SV也进一步允许多维组合型数组的声明</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>][<span class="number">7</span>:<span class="number">0</span>] data;  <span class="comment">//2-D packed array     4*8-bit  (单位元素 数组大小 数组名)</span></span><br><span class="line"><span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>][<span class="number">7</span>:<span class="number">0</span>] data;    <span class="comment">//2-D packed array       </span></span><br></pre></td></tr></table></figure></li>
<li><p>组合型数组会进一步规范数据的存储方式，而<strong>不需要关心编译器或者操作系统的区别</strong>。</p>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1617880640629-b7143ebe-44c4-4a34-af4b-ce697ff95e09.png#align=left&display=inline&height=62&id=Bi2HW&margin=%5Bobject%20Object%5D&name=image.png&originHeight=62&originWidth=496&size=24955&status=done&style=none&width=496" alt="image.png"></p>
<blockquote>
<p>1个word 大小32-bit   对于二值逻辑来说，32位用一个word存放、对于四值逻辑来说要用两个word存放</p>
</blockquote>
<ul>
<li><p>组合型（packed）除了可以运用的数组声明，也可以用来定义结构体的存储方式（<strong>连续存放</strong>）</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="keyword">packed</span>&#123;</span><br><span class="line">  <span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] crc;</span><br><span class="line">  <span class="keyword">logic</span> [<span class="number">63</span>:<span class="number">0</span>] data;</span><br><span class="line">&#125;data word;</span><br><span class="line">data word [<span class="number">7</span>:<span class="number">0</span>] darray;<span class="comment">//1-D packed array of</span></span><br><span class="line">                       <span class="comment">//packed structures</span></span><br><span class="line"><span class="comment">//连续存放，节省空间、易读取</span></span><br></pre></td></tr></table></figure></li>
<li><p>组合型数组和其数组片段也可以灵活选择，用来拷贝和赋值等</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>][<span class="number">7</span>:<span class="number">0</span>] data;            <span class="comment">//2-D packed array </span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] out = data;           <span class="comment">//whole array </span></span><br><span class="line"><span class="keyword">wire</span> sign = data[<span class="number">3</span>][<span class="number">7</span>];           <span class="comment">//bit-select </span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] nib = data [<span class="number">0</span>][<span class="number">3</span>:<span class="number">0</span>];   <span class="comment">//part-select </span></span><br><span class="line"><span class="keyword">byte</span> high_byte;</span><br><span class="line"><span class="keyword">assign</span> high_byte = data[<span class="number">3</span>];       <span class="comment">//8-bit slice </span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">15</span>:<span class="number">0</span>] word;</span><br><span class="line"><span class="keyword">assign</span> word = data[<span class="number">1</span>:<span class="number">0</span>];          <span class="comment">//2 slices</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> [<span class="number">1</span>:<span class="number">0</span>][<span class="number">2</span>:<span class="number">0</span>] arr [<span class="number">3</span>:<span class="number">0</span>][<span class="number">4</span>:<span class="number">0</span>];    <span class="comment">// 四维数组 4*5*2*3  (混合型数组)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h2><ul>
<li><p>组合型（packed）数组初始化时，同向量初始化一致</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>][<span class="number">7</span>:<span class="number">0</span>] a = <span class="number">32&#x27;h0</span>;           <span class="comment">//vector assignment </span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>][<span class="number">7</span>:<span class="number">0</span>] b = &#123;<span class="number">16&#x27;hz</span>, <span class="number">16&#x27;h0</span>&#125;;  <span class="comment">//concatenate operator </span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>][<span class="number">7</span>:<span class="number">0</span>] c = &#123;<span class="number">16</span>&#123;<span class="number">2&#x27;b01</span>&#125;&#125;;    <span class="comment">//eplicate operator</span></span><br></pre></td></tr></table></figure></li>
<li><p>非组合型（unpacked）数组初始化时，则需要通过 <strong>‘{}</strong> 来对数组的每一个维度进行赋值。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> d[<span class="number">0</span>:<span class="number">1</span>][<span class="number">0</span>:<span class="number">3</span>]=&#x27;&#123;&#x27;&#123;<span class="number">7</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">5</span>&#125;,&#x27;&#123;<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line"><span class="comment">//d[0][0]=7</span></span><br><span class="line"><span class="comment">//d[0][1]=3</span></span><br><span class="line"><span class="comment">//d[0][2]=0</span></span><br><span class="line"><span class="comment">//d[0][3]=5</span></span><br><span class="line"><span class="comment">//d[1][0]=2</span></span><br><span class="line"><span class="comment">//d[1][1]=0</span></span><br><span class="line"><span class="comment">//d[1][2]=1</span></span><br><span class="line"><span class="comment">//d[1][3]=6</span></span><br></pre></td></tr></table></figure></li>
<li><p>非组合型数组在初始化时，也可以类似结构体初始化，通过 ‘{} 和default关键词即可以完成</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a1 [<span class="number">0</span>:<span class="number">7</span>][<span class="number">0</span>:<span class="number">1023</span>] = &#x27;&#123;<span class="keyword">default</span>:<span class="number">8&#x27;h55</span>&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="数组赋值"><a href="#数组赋值" class="headerlink" title="数组赋值"></a>数组赋值</h2><ul>
<li><p>以下是组合型数组的赋值方法</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>][<span class="number">1</span>:<span class="number">0</span>][<span class="number">7</span>:<span class="number">0</span>] a; <span class="comment">//3-D packed array  2*2*8-bit</span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1&#x27;b0</span>;         <span class="comment">//assign to one bit </span></span><br><span class="line">a=<span class="number">32&#x27;hF1A3C5E7</span>;          <span class="comment">//assign to full array </span></span><br><span class="line">a[<span class="number">1</span>][<span class="number">0</span>][<span class="number">3</span>:<span class="number">0</span>]=<span class="number">4&#x27;hF</span>;       <span class="comment">//assign to a part select </span></span><br><span class="line">a[<span class="number">0</span>]=<span class="number">16&#x27;hFACE</span>;           <span class="comment">//assign to a slice </span></span><br><span class="line">a=&#123;<span class="number">16&#x27;bz</span>,<span class="number">16&#x27;b0</span>&#125;;         <span class="comment">//assign concatenation</span></span><br></pre></td></tr></table></figure></li>
<li><p>非组合型数组的数据成员或者数组本身均可以为其赋值</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> a [<span class="number">0</span>:<span class="number">3</span>][<span class="number">0</span>:<span class="number">3</span>];</span><br><span class="line">a[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">8&#x27;h5</span>;                 <span class="comment">//assign to one element </span></span><br><span class="line">a[<span class="number">3</span>]=&#x27;&#123;<span class="number">&#x27;hF</span>, <span class="number">&#x27;hA</span>, <span class="number">&#x27;hC</span>, <span class="number">&#x27;hE</span>&#125;;   <span class="comment">//assign list of values to slice of the array</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h2><ul>
<li><p>对于组合型数组，由于数组会被视为向量，因此当赋值左右两侧操作数的大小和维度不相同时，也可以做赋值。</p>
</li>
<li><p>如果当尺寸不相同时，则会通过<strong>截取或者扩展右侧操作数</strong>的方式来对左侧操作数赋值。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bit</span> [<span class="number">1</span>:<span class="number">0</span>][<span class="number">15</span>:<span class="number">0</span>] a;   <span class="comment">//32 bit 2-state vector </span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>][<span class="number">7</span>:<span class="number">0</span>] b;  <span class="comment">//32 bit 4-state vector </span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">15</span>:<span class="number">0</span>] c;      <span class="comment">//16 bit 4-state vector</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">39</span>:<span class="number">0</span>] d;      <span class="comment">//40 bit 4-state vector </span></span><br><span class="line">b = a;               <span class="comment">//assign 32-bit array to 32-bit array </span></span><br><span class="line">c = a;               <span class="comment">//upper 16 bits will be truncated </span></span><br><span class="line">d = a;               <span class="comment">//upper 8 bits will be zero filled</span></span><br></pre></td></tr></table></figure></li>
<li><p>对于非组合型数组，在发生数组间拷贝时，则要求做左右两侧操作数的维度和大小必须严格一致。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] a [<span class="number">2</span>:<span class="number">0</span>][<span class="number">9</span>:<span class="number">0</span>];    <span class="comment">//3*10*32-bit</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">0</span>:<span class="number">31</span>] b [<span class="number">1</span>:<span class="number">3</span>][<span class="number">1</span>:<span class="number">10</span>];   <span class="comment">//3*10*32-bit</span></span><br><span class="line">a=b;    <span class="comment">//Iassign unpacked array to unpacked array 维度相同</span></span><br></pre></td></tr></table></figure></li>
<li><p>非组合型数组<strong>无法直接赋值</strong>给组合型数组，同样地，组合型数组也<strong>无法直接赋值</strong>给非组合型数组。</p>
</li>
</ul>
<h2 id="foreach循环结构"><a href="#foreach循环结构" class="headerlink" title="foreach循环结构"></a>foreach循环结构</h2><ul>
<li><p>SV添加foreach循环来对一维或者多维数组进行循环索引，而<strong>不需要指定该数组的维度大小</strong>。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum [<span class="number">1</span>:<span class="number">8</span>][<span class="number">1</span>:<span class="number">3</span>];</span><br><span class="line"><span class="keyword">foreach</span> (sum[i,j])</span><br><span class="line">  sum[i][j] = i+j;      <span class="comment">//initialize array</span></span><br></pre></td></tr></table></figure></li>
<li><p>foreach循环结构中的<strong>变量无需声明</strong>。</p>
</li>
<li><p>foreach循环结构中的变量是只读的（可以引用不能修改），其作用域<strong>只在此循环结构</strong>中。</p>
</li>
</ul>
<h2 id="系统函数"><a href="#系统函数" class="headerlink" title="系统函数"></a>系统函数</h2><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$dimensions</span>(array_name)     <span class="comment">//用来返回数组的维度。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">$left</span>(array_name,dimension) <span class="comment">//返回指定维度的最左索引值（msb）。</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">2</span>][<span class="number">7</span>:<span class="number">0</span>] word [<span class="number">0</span>:<span class="number">3</span>][<span class="number">4</span>:<span class="number">1</span>];</span><br><span class="line"><span class="built_in">$left</span>(word,<span class="number">1</span>) <span class="comment">//will return 0</span></span><br><span class="line"><span class="built_in">$left</span>(word,<span class="number">2</span>) <span class="comment">//will return 4</span></span><br><span class="line"><span class="built_in">$left</span>(word,<span class="number">3</span>) <span class="comment">//will return 1</span></span><br><span class="line"><span class="built_in">$left</span>(word,<span class="number">4</span>) <span class="comment">//will return 7</span></span><br><span class="line"><span class="comment">//与left()类似的，还有&#123;right，low，high&#125;(array_name，dimension)。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">$size</span>(array_name, dimension)      <span class="comment">//可以返回指定维度的尺寸大小。</span></span><br><span class="line"><span class="built_in">$increment</span>(array_name, dimension) <span class="comment">//如果指定维度的最左索引值大于或等于最右索引值，那么返回1，否则返回-1。</span></span><br><span class="line"><span class="built_in">$bits</span>(expression)                 <span class="comment">//可以用来返回数组存储的比特数目。</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>][<span class="number">7</span>:<span class="number">0</span>] a [<span class="number">0</span>:<span class="number">15</span>];         <span class="comment">//$bits(a)返回512   16*3*7</span></span><br><span class="line"><span class="keyword">struct</span> <span class="keyword">packed</span> &#123;<span class="keyword">byte</span> tag;</span><br><span class="line">               <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] addr&#125; b;</span><br><span class="line"><span class="built_in">$bits</span>(b);           <span class="comment">//返回40</span></span><br></pre></td></tr></table></figure>
<h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><ul>
<li><p>与之前的定长数组相比，SV还提供了可以重新确定大小的动态数组。</p>
</li>
<li><p>动态数组在声明时需要使用[ ]，这表示不会在编译时为其制定尺寸，而是在仿真运行时来确定。</p>
</li>
<li><p>动态数组<strong>一开始为空</strong>，而需要使用<strong>new[]来为其分配空间</strong>。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> dyn[], d2[];  <span class="comment">//peclare dynamic arraye </span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span> </span><br><span class="line">  dyn = <span class="keyword">new</span>[<span class="number">5</span>];                <span class="comment">//A:Allocate 5 elements  默认5个0</span></span><br><span class="line">  <span class="keyword">foreach</span> (dyn[j]) </span><br><span class="line">    dyn[j] = j;               <span class="comment">//B:Initialize the elements </span></span><br><span class="line">    d2 = dyn;                 <span class="comment">//C:Copy a dynamic array </span></span><br><span class="line">  d2[<span class="number">0</span>] = <span class="number">5</span>;                  <span class="comment">//D:Modify the copy</span></span><br><span class="line">  <span class="built_in">$display</span>(dyn[<span class="number">0</span>],d2[<span class="number">0</span>]);     <span class="comment">//E:See both values(0 &amp; 5)</span></span><br><span class="line"></span><br><span class="line">  dyn = <span class="keyword">new</span>[<span class="number">20</span>](dyn);         <span class="comment">//F:Allocate 20 ints&amp;copy </span></span><br><span class="line">  dyn = <span class="keyword">new</span>[<span class="number">100</span>];              <span class="comment">//G:Allocate 100 new ints</span></span><br><span class="line">                               <span class="comment">//old values are lost </span></span><br><span class="line">  <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] vec1, vec2, vec3;</span><br><span class="line">  vec1 = <span class="number">&#x27;h11223344</span>;                      <span class="comment">//11223344</span></span><br><span class="line">  vec2 = &#123;<span class="number">&#x27;h11</span>, <span class="number">&#x27;h22</span>, <span class="number">&#x27;h33</span>, <span class="number">&#x27;h44</span>&#125;;        <span class="comment">//00000044</span></span><br><span class="line">  vec2 = &#123;<span class="number">8&#x27;h11</span>, <span class="number">8&#x27;h22</span>, <span class="number">8&#x27;h33</span>, <span class="number">8&#x27;h44</span>&#125;;    <span class="comment">//11223344</span></span><br><span class="line">  </span><br><span class="line">  dyn<span class="variable">.delete</span>();  <span class="comment">//数组清空操作 </span></span><br><span class="line">  `&#123;&#125;或者<span class="keyword">new</span>[<span class="number">0</span>]  <span class="comment">//数组清空操作</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li>
<li><p>内建方法size()可以返回动态数组的大小。</p>
</li>
<li><p>内建方法delete()可以清空动态数组，使其尺寸变为0。</p>
</li>
<li><p>动态数组在声明时也可以完成其初始化</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bit</span> [<span class="number">7</span>：<span class="number">0</span>] mask[]=&#x27;&#123;<span class="number">8&#x27;b00000000</span>,</span><br><span class="line">                 <span class="number">8&#x27;b00000001</span>,</span><br><span class="line">                 <span class="number">8&#x27;b00000011</span>,</span><br><span class="line">                 <span class="number">8&#x27;b00000111</span>,</span><br><span class="line">                 <span class="number">8&#x27;b00001111</span>,</span><br><span class="line">                 <span class="number">8&#x27;b00011111</span>,</span><br><span class="line">                 <span class="number">8&#x27;b00111111</span>,</span><br><span class="line">                 <span class="number">8&#x27;b01111111</span>,</span><br><span class="line">                 <span class="number">8&#x27;b11111111</span>&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><ul>
<li>可以在队列的<strong>任何位置</strong>添加或者删除数据成员。</li>
<li>可以通过索引来访问队列的<strong>任何</strong>一个成员。</li>
<li>通过[$]来声明队列，队列的索引值从0到$（**最后一个元素为$**）。</li>
<li>可以通过内建方法<strong>push_back（val）、push_front（val）、pop_back（）和pop_front（）</strong>来顺序添加或者移除并且获得数成员。</li>
<li>可以通过insert（pos，val）来在指定位置插入数据成员。</li>
<li>可以通过delete（）来删除所有数据成员。<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> j=<span class="number">1</span>,</span><br><span class="line">q2[$] = &#123;<span class="number">3</span>,<span class="number">4</span>&#125;,    <span class="comment">//Queue literals do not use()</span></span><br><span class="line">q[$] = &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;   <span class="comment">//&#123;0,2,3&#125;</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span> </span><br><span class="line">  q. insert(<span class="number">1</span>,j);    <span class="comment">//&#123;0,1,2,3&#125; Insertj before ele #1</span></span><br><span class="line">  q. delete(<span class="number">1</span>);      <span class="comment">//&#123;0,2,3&#125; Delete element #1</span></span><br><span class="line">                     <span class="comment">//These operations are fast </span></span><br><span class="line">  g<span class="variable">.push_front</span>(<span class="number">6</span>);   <span class="comment">//&#123;6,0,2,3&#125; Insert at front </span></span><br><span class="line">  j=g<span class="variable">.pop_back</span>();    <span class="comment">//&#123;6,0,2&#125;   j=3</span></span><br><span class="line">  q<span class="variable">.push_back</span>(<span class="number">8</span>);    <span class="comment">//&#123;6,0,2,8&#125; Insert at back </span></span><br><span class="line">  j=q<span class="variable">.pop_front</span>;     <span class="comment">//&#123;0,2,8&#125;   j=6</span></span><br><span class="line"><span class="keyword">foreach</span> (q[i])</span><br><span class="line">  <span class="built_in">$display</span>(q[i]);    <span class="comment">//print entire queue </span></span><br><span class="line">  q<span class="variable">.delete</span>();        <span class="comment">// &#123;&#125; Delete queue end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> j=<span class="number">1</span>, </span><br><span class="line">  q2[$] = &#123;<span class="number">3</span>,<span class="number">4</span>&#125;,     <span class="comment">//Queue literals do not use </span></span><br><span class="line">  q[$] = &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>&#125;;    <span class="comment">//&#123;0,2,5&#125; initial begin //Result </span></span><br><span class="line">  q = &#123;q[<span class="number">0</span>],j,q[<span class="number">1</span>:$]&#125;;        <span class="comment">//&#123;0,1,2,5&#125; Insert 1 before 2</span></span><br><span class="line">  q = &#123;q[<span class="number">0</span>:<span class="number">2</span>], q2, q[<span class="number">3</span>:$]&#125;;   <span class="comment">//&#123;0,1,2,3,4,5&#125; Insert queue in q 字符拼接可以，无法用insert插入队列</span></span><br><span class="line">  q = &#123;q[<span class="number">0</span>],q[<span class="number">2</span>:$<span class="number">1</span>&#125;;          <span class="comment">//&#123;0,2,3,4,5&#125; Delete elem.#1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//These operations are fast </span></span><br><span class="line">   q = &#123;<span class="number">6</span>,g&#125;;        <span class="comment">//&#123;6,0,2,3,4,5&#125; Insert at front </span></span><br><span class="line">   j = q[$];         <span class="comment">//j=5 pop back g=q[0:$-11;//&#123;6,0,2,3,4&#125; equivalent g=&#123;q,8&#125;;//&#123;6,0,2,3,4,8&#125; Insert at back </span></span><br><span class="line">   j = q[<span class="number">0</span>];         <span class="comment">//j=6 pop_front g=g[1:$];//&#123;0,2,3,4,8&#125; equivalent </span></span><br><span class="line">   q = &#123;&#125;;           <span class="comment">//&#123;&#125; pelete contents </span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="关联数组"><a href="#关联数组" class="headerlink" title="关联数组"></a>关联数组</h2><blockquote>
<p>由于处理器在访问存储时的访问的随机或者散乱的，这意味个测试中，处理器也许只会访问几百个存储地址，而剩下大的地址都将被初始化为0并且浪费了仿真时的存储空间。</p>
</blockquote>
<ul>
<li>关联数组可以用来存放散列的数据成员。索引类型可以为<strong>任何类型</strong>，而散列存储的数员也可以为<strong>任意类型</strong>。<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span> </span><br><span class="line">  <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] mem [<span class="keyword">int</span> <span class="keyword">unsigned</span>]; </span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">unsigned</span> data,addr; </span><br><span class="line">  <span class="keyword">repeat</span>(<span class="number">5</span>)<span class="keyword">begin</span> </span><br><span class="line">    std::randomize(addr,data)<span class="keyword">with</span> &#123;addr[<span class="number">31</span>:<span class="number">8</span>]==<span class="number">0</span>; addr[<span class="number">1</span>:<span class="number">0</span>]== <span class="number">0</span>; data <span class="keyword">inside</span> &#123;[<span class="number">1</span>:<span class="number">10</span>]&#125;;&#125;; <span class="comment">//随机生成数据 </span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;address:&#x27;h80x,data:&#x27;h80x&quot;</span>,addr,data); </span><br><span class="line">    mem[addr]=data; </span><br><span class="line">    <span class="keyword">foreach</span>(mem[idx])</span><br><span class="line">      <span class="built_in">$display</span>(<span class="string">&quot;mem address:&#x27;ha0x,data:&#x27;h80x&quot;</span>, idx, mem[idx]);</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="缩减方法"><a href="#缩减方法" class="headerlink" title="缩减方法"></a>缩减方法</h2><ul>
<li>基本的数组缩减方法是把一个数组缩减成一个值。</li>
<li>最常用的缩减方法是sum，它对数组中的所有元素求和<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> b[$]=&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> w;</span><br><span class="line">w=b<span class="variable">.sum</span>();      <span class="comment">//14=2+3+4+5</span></span><br><span class="line">w=b<span class="variable">.product</span>();  <span class="comment">//120=2*3*4*5</span></span><br><span class="line">w=b<span class="variable">.and</span>();      <span class="comment">//00000000=2&amp;3&amp;4&amp;5其它的数组缩减方法还有product（积）,and（与）,or xor（异或）</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="定位方法"><a href="#定位方法" class="headerlink" title="定位方法"></a>定位方法</h2><ul>
<li><p>对于非合并数组，可以使用数组定位方法，其返回值将是<strong>一列</strong>而非一个数据成员。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> f[<span class="number">6</span>]=&#123;<span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">6</span>&#125;;  <span class="comment">//Fixed-size array </span></span><br><span class="line"><span class="keyword">int</span> d[]=&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;;     <span class="comment">//Dynamic array </span></span><br><span class="line"><span class="keyword">int</span> g[$]=&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;        <span class="comment">//Queue </span></span><br><span class="line">tq[$];                       <span class="comment">//Temporary queue for res </span></span><br><span class="line">tq=g<span class="variable">.min</span>();                  <span class="comment">//&#123;1&#125;</span></span><br><span class="line">tg=d<span class="variable">.max</span>();                  <span class="comment">//&#123;10&#125;</span></span><br><span class="line">tq=f<span class="variable">.unique</span>();               <span class="comment">//&#123;1，6，2，8&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用foreach也可以实现数组的搜索，不过使用find…with查找满足条件的数据成员时，更为方便。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> d[]=&#123;<span class="number">9</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>&#125;;</span><br><span class="line">tq[$];</span><br><span class="line"><span class="comment">//Find all elements greater than 3</span></span><br><span class="line">tq=d<span class="variable">.find</span> <span class="keyword">with</span>(item&gt;<span class="number">3</span>);       <span class="comment">//&#123;9，8，4，4&#125;</span></span><br><span class="line"></span><br><span class="line">tq<span class="variable">.delete</span>();                <span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">foreach</span>(d[i])</span><br><span class="line">  <span class="keyword">if</span>(d[i]&gt;<span class="number">3</span>）</span><br><span class="line">     tq<span class="variable">.push_back</span>(d[i]);</span><br><span class="line"></span><br><span class="line">     tg=d<span class="variable">.find_index</span> <span class="keyword">with</span> (item&gt;<span class="number">3</span>);        <span class="comment">//&#123;0,2,4,5&#125;</span></span><br><span class="line">     tg=d<span class="variable">.find_first</span> <span class="keyword">with</span> (item&gt;<span class="number">99</span>);       <span class="comment">//&#123;-none found </span></span><br><span class="line">     tg=d<span class="variable">.find_first_index</span> <span class="keyword">with</span> (item==<span class="number">8</span>); <span class="comment">//&#123;2&#125;d[2]=8</span></span><br><span class="line">     tg=d<span class="variable">.find_last</span> <span class="keyword">with</span> (item==<span class="number">4</span>);        <span class="comment">//&#123;4&#125;</span></span><br><span class="line">     tq=d<span class="variable">.find_last_index</span> <span class="keyword">with</span> (item==<span class="number">4</span>);  <span class="comment">//&#123;5&#125;d[5]=4</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="排序方法"><a href="#排序方法" class="headerlink" title="排序方法"></a>排序方法</h2><ul>
<li>可以通过排序方法改变数组中元素的顺序，可以对它们进行逆向或者乱序的排列。<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> d[]=&#123;<span class="number">9</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>&#125;; </span><br><span class="line">d<span class="variable">.reverse</span>();           <span class="comment">//&#123;4,4,3,8,1,9&#125;</span></span><br><span class="line">d<span class="variable">.sort</span>();              <span class="comment">//&#123;1,3,4,4,8,9&#125;</span></span><br><span class="line">d<span class="variable">.rsort</span>();             <span class="comment">//&#123;9,8,4,4,3,1&#125;</span></span><br><span class="line">d<span class="variable">.shuffle</span>();           <span class="comment">//&#123;9,4,3,8,1,4&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="思考问题"><a href="#思考问题" class="headerlink" title="思考问题"></a>思考问题</h2><ul>
<li>链表和SV中的哪些数组类型（定长数组、动态数组、队列、关联数组）相似，相似的特性有哪些？<ul>
<li>从存放方式来看，定长数组、动态数组、队列都是连续存放，关联数组和链表是非连续存放</li>
<li>从查找数据上来看，链表和关联数组依靠指针来维系顺序，查找低效，但增、删、改方便</li>
<li>队列借鉴了链表的数据结构特点，依靠更多的指针维系元素前后关系</li>
</ul>
</li>
</ul>
<ul>
<li>如何使用动态数组来实现队列的几个方法（1）function void push_back（T val），（2）function T pop_front），（3）function void insert（int POS，T val）。可以在module中，通过声明一个动态数组 int array[]，并且实现以上三个方法，再通过在initial begin.…end过程块中测试、打印以上方法的结果来完成代码实现和测试。需要提交代码截图和测试的打印结果。</li>
</ul>
]]></content>
      <categories>
        <category>笔记篇</category>
        <category>数字验证</category>
      </categories>
      <tags>
        <tag>SystemVerilog</tag>
      </tags>
  </entry>
  <entry>
    <title>SV系统验证（4）——验证环境结构和组件</title>
    <url>/2021/03/30/SV%E7%B3%BB%E7%BB%9F%E9%AA%8C%E8%AF%81%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%E9%AA%8C%E8%AF%81%E7%8E%AF%E5%A2%83%E7%BB%93%E6%9E%84%E5%92%8C%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>测试平台（testbench）是整个验证系统的总称。</li>
<li>测试平台包括验证结构中的<strong>各个组件</strong>（层次）、<strong>组件之间的连接关系</strong>（通信）、<strong>测试平台的配置和控制</strong>。</li>
<li>从更系统的意义来讲，它还包括编译仿真的流程、结果分析报告和覆盖率检查等。</li>
<li>从狭义上讲，我们主要关注验证平台的结构和组件部分，他们可以产生设计所需要的各种输入，也会在此基础上进行设计功能的检查。</li>
</ul>
<h2 id="测试环境结构图"><a href="#测试环境结构图" class="headerlink" title="测试环境结构图"></a>测试环境结构图</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1617765993597-f26ffd2c-f0fb-454a-8da2-fa5ff15aabd4.png#align=left&display=inline&height=277&id=qc4xy&margin=%5Bobject%20Object%5D&name=image.png&originHeight=385&originWidth=580&size=29627&status=done&style=none&width=417" alt="image.png"></p>
<ul>
<li>首先编译：RTL（DUT）、TB</li>
<li>各个组件之间是相互独立的、</li>
<li><strong>验证组件与设计之间</strong>需要连接（接口连接）</li>
<li><strong>验证组件之间</strong>也需要进行通信（信箱）</li>
<li>验证环境也需要<strong>时钟</strong>和<strong>复位</strong>信号的驱动</li>
</ul>
<h2 id="验证语言应用趋势"><a href="#验证语言应用趋势" class="headerlink" title="验证语言应用趋势"></a>验证语言应用趋势</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1617772537297-ed4d9f01-0944-4b01-9ba1-87ed9153e141.png#align=left&display=inline&height=364&id=Etq6x&margin=%5Bobject%20Object%5D&name=image.png&originHeight=364&originWidth=591&size=79748&status=done&style=none&width=591" alt="image.png"></p>
<ul>
<li>近年来SystemVerilog的使用比例明显占据<strong>主导地位</strong>。</li>
<li>SystemC和C/C++在验证部分也有其应用空间。</li>
<li>借助于语言的统一趋势，方法学（UVM）的统一也已经完成。验证初学者赶上了一个好时代，一个再纷乱繁杂的统一时代。</li>
</ul>
<h2 id="验证环境组件"><a href="#验证环境组件" class="headerlink" title="验证环境组件"></a>验证环境组件</h2><h3 id="激励发生器"><a href="#激励发生器" class="headerlink" title="激励发生器"></a>激励发生器</h3><ul>
<li>Stimulator（激励发生器）是验证环境的重要部件，在一些场合中，它也被称为driver（驱动器）、BFM（bus function model，总线功能模型），behavioral（行为模型）或者generator（发生器）。</li>
<li>Stimulator的主要职责是<strong>模拟与DUT相邻设计的接口协议</strong>，只需要关注于如何模拟接口信号，使其能够以真实的接口协议来发送激励给DUT。</li>
<li>Stimulator<strong>不应该违反协议，但不拘束于真实的硬件行为</strong>，还可以给出更多丰富的只要协议允许的激励场景。</li>
<li><strong>比真实硬件行为更丰富的激励</strong>，会使得在模块级的验证更加充分，因为它不但验证过了硬件普通的接口协议情景，还模拟出更多复杂的、在更高系统级别无法产生出来的场景。</li>
<li>Stimulator的接口<strong>主要是向DUT之间连接</strong>，此外，也应该有时钟和复位的输入，确保生成的数据同DUT的接口一侧是同步的关较精细的stimulator还可以有其它的配置接口用来控制接口的数据生成。</li>
<li>Stimulator也<strong>可以有存储接口数据生成历史的功能</strong>，这可以用来在仿真运行时或者结束后查看接口数据，方便统计或者调试。</li>
<li>从stimulator同DUT的连接关系来看，我们可以将其进一步分为两种：<strong>initiator（发起器）和responder（响应器）</strong>。</li>
<li>就我们要验证的MCDF来看，与<strong>下行通道从端（channel slave）的连接或寄存器接口的连接</strong>，这两部分的stimulator都属于initiator，它们的功能是主动发起接口数据传输。</li>
<li>与MCDF formatter接口的连接，该stimulator则属于responder，它的职责是对接口的数据发送请求做出响应，而它本身不会主动发送数据。</li>
</ul>
<h3 id="监测器"><a href="#监测器" class="headerlink" title="监测器"></a>监测器</h3><ul>
<li>Monitor（监测器）的主要功能是<strong>用来观察DUT的边界或者内部信号</strong>，并且经过打包整理传送给其它验证平台的组件，例如checker（比较器）。</li>
<li>从监测信号的层次来划分monitor的功能，它们可以分为观察<strong>DUT边界信号</strong>和观察<strong>DUT内部信号</strong>。<ul>
<li><strong>观察DUT边界信号</strong>。对于系统信号如时钟，可以监测其频率变化；对于总线信号，可以监测总线的传输类型和数据丙容，以及检查总线时序是否符合协议。</li>
<li><strong>观察DUT内部信号</strong>。从灰盒验证的手段来看，往往需要探视DUT内部信号，用来指导stimulator的激励发送，或者完成覆盖率收集，又或者完成内部功能的检查。</li>
</ul>
</li>
<li>如果没有特殊的需要，我们应采取<strong>灰盒验证</strong>的策略（而非白盒）。观察的内部信号应当尽量<strong>少</strong>，且应当是<strong>表示状态的信号</strong>。不建议采集中间变量信号的原因在于，这些信号的时序、逻辑甚至留存性都不稳定，这种不稳定对于验证环境的收敛是有害的。</li>
<li>可以<strong>通过接口信息计算的</strong>，就<strong>尽量少去监测内部信号</strong>，因为这种方式也有悖于假定设计有缺陷的验证思想。我们观测到的内部信号在被环境采纳之前也有必要确认它们的逻辑正确性，这一要求可以通过动态检查或者断言触发的方式来实现。</li>
</ul>
<h3 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h3><ul>
<li>checker肩负了<strong>模拟设计行为</strong>（reference model）和<strong>功能检查</strong>的任务将DUT输入接口侧的数据汇聚给<strong>内置的reference model（参考模型）</strong>，reference model在这里扮演了模拟硬件功能的角色通过<strong>数据比较</strong>的方法，检查实际收集到的DUT输出端接口数据是否同reference model产生的期望数据一致<ul>
<li><strong>线上比较</strong>（online check）：在仿真时收集数据和在线比较，并且实时报告</li>
<li><strong>线下比较</strong>（offline check）：将仿真时收集到的数据记录在文件中，在仿真结束后，通过脚本或者其他手段进行数据比较</li>
</ul>
</li>
<li>reference model也会<strong>内置一些缓存</strong>，分别存放从DUT输入端观察到的数据，以及经过功能转换的数据，同时Checker也有其<strong>它缓存来存放从输出端采集到的数据</strong>。</li>
</ul>
<h2 id="任务和函数"><a href="#任务和函数" class="headerlink" title="任务和函数"></a>任务和函数</h2><p><strong>区别</strong></p>
<ul>
<li>fuction<strong>不会消耗</strong>仿真<strong>时间</strong>，而task则<strong>可能会消耗</strong>仿真<strong>时间</strong></li>
<li><strong>function无法调用task</strong>（因为task可能会消耗仿真时间），而task可以调用function</li>
<li>一个可以返回数据的function<strong>只能返回一个单一数值</strong>，而任务或者void function不会返回数值</li>
<li>一个可以返回数据的function可以<strong>作为一个表达式中的操作数（赋值）</strong>，而该操作数的值即function的</li>
</ul>
<h3 id="函数function"><a href="#函数function" class="headerlink" title="函数function"></a>函数function</h3><ul>
<li><strong>必须</strong>提供返回值</li>
<li>void函数不会返回具体数值，但是<strong>返回空</strong></li>
<li>函数的<strong>参数列表方向</strong>也可以声明为<strong>input、output、inout和ref</strong></li>
<li>对于函数返回的方式，也同C一致，有两种方法，既可以<strong>使用return直接返回值</strong>，也可以将值<strong>赋给与函数同名的变量</strong></li>
<li>只是<strong>return会立即返回</strong>，而赋值给函数同名变量后将<strong>继续执行</strong>后续代码</li>
<li>如果调⽤具有返回值的函数，但是⼜不适⽤该返回值时，我们建议为其添加</li>
<li><strong>void’(some_fuction())<strong>进⾏强制转换，</strong>不要返回值</strong><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> [<span class="number">15</span>:<span class="number">0</span>] myfuncl(<span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] x,y); </span><br><span class="line">  myfuncl = x*y-<span class="number">1</span>; </span><br><span class="line"><span class="keyword">endfunction</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> [<span class="number">15</span>:<span class="number">0</span>] myfunc2(<span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>]x,y); </span><br><span class="line">  <span class="keyword">return</span> x*y-<span class="number">1</span>; </span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> [<span class="number">15</span>:<span class="number">0</span>] myfunc3(<span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>]x</span><br><span class="line">                      ,<span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>]y); </span><br><span class="line">  myfunc2 = x*y-<span class="number">1</span>; </span><br><span class="line"><span class="keyword">endfunction</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> myfunc4(<span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] x,</span><br><span class="line">                      <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] y,</span><br><span class="line">                      <span class="keyword">output</span> [<span class="number">15</span>:<span class="number">0</span>] z ); </span><br><span class="line">  z = x*y-<span class="number">1</span>; </span><br><span class="line"><span class="keyword">endfunction</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span> </span><br><span class="line">  <span class="keyword">byte</span> <span class="keyword">unsigned</span> a=<span class="number">3</span>;</span><br><span class="line">  <span class="keyword">byte</span> <span class="keyword">unsigned</span> b=<span class="number">4</span>; </span><br><span class="line">  <span class="keyword">byte</span> <span class="keyword">unsigned</span> c1,c2; </span><br><span class="line">  myfunc4(a,b,c1);</span><br><span class="line">  <span class="built_in">$display</span>(<span class="string">&quot;c1=%0d&quot;</span>,c1); </span><br><span class="line">  c2=myfunc3(a,b);</span><br><span class="line">  <span class="built_in">$display</span>(<span class="string">&quot;c2=%0d&quot;</span>,c2); </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="任务task"><a href="#任务task" class="headerlink" title="任务task"></a>任务task</h3><ul>
<li>任务的定义<strong>可以指定参数</strong>，<strong>input、output、inout及ref</strong> 皆可（使用ref时<strong>实参形参类型必须高度一致</strong>）</li>
<li>任务<strong>可以消耗</strong>仿真时间</li>
<li>任务<strong>可以调用其他任务或者函数</strong></li>
<li>return能<strong>提前结束</strong>任务（类似于break用法，直接退出后面<strong>不执行</strong>）<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">`timecale <span class="number">1</span>ns/<span class="number">1</span>ps</span><br><span class="line"><span class="keyword">task</span> mytask3(<span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] x,</span><br><span class="line">             <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] y,</span><br><span class="line">             <span class="keyword">output</span> [<span class="number">15</span>:<span class="number">0</span>] z); <span class="comment">//输出类型使用ref，可以实时传参，不需要task执行完毕</span></span><br><span class="line">  #<span class="number">5</span>ns; </span><br><span class="line">  z = x*y-<span class="number">1</span>; </span><br><span class="line">  <span class="keyword">return</span>;        <span class="comment">//强制退出，后面的不执行</span></span><br><span class="line">  #<span class="number">5</span>ns; </span><br><span class="line"><span class="keyword">endtask</span> </span><br><span class="line">  <span class="keyword">byte</span> <span class="keyword">unsigned</span> a = <span class="number">3</span>; </span><br><span class="line">  <span class="keyword">byte</span> <span class="keyword">unsigned</span> b = <span class="number">4</span>; </span><br><span class="line">  <span class="keyword">logic</span> [<span class="number">15</span>:<span class="number">0</span>] c1, c2; </span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span> mytask3(a,b,c1);</span><br><span class="line">  <span class="built_in">$display</span>(<span class="string">&quot;c1=%0d&quot;</span>, c1); </span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span> </span><br><span class="line">  <span class="keyword">repeat</span>(<span class="number">12</span>) <span class="keyword">begin</span></span><br><span class="line">  #<span class="number">1</span>ns; </span><br><span class="line">  <span class="built_in">$display</span>(<span class="string">&quot;etime stc1=80d&quot;</span>, <span class="built_in">$time</span>, cl); </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h3><ul>
<li>SV允许方法声明参数的默认值（<strong>默认input</strong>），参数的方向可以时input、inout、output和ref</li>
<li>带有参数默认值的方法被调用时，如果这些参数没有被传递值，那么编译器将会为这些参数<strong>传入对应的默认值</strong></li>
<li>SV允许类似于模块例化一样，可由参数<strong>位置顺序</strong>在调用方法时传递参数，也可以由参数名字调用方式时绑定参数</li>
<li>参数未声明类型默认<strong>1-bit的logic</strong>类型<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">task</span> read(<span class="keyword">int</span> j=<span class="number">0</span>,<span class="keyword">int</span> k,<span class="keyword">int</span> data=<span class="number">1</span>); <span class="comment">// j默认值为0 data默认值为1</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">endtask</span> </span><br><span class="line"></span><br><span class="line">read(n,<span class="number">5</span>);   <span class="comment">// is equivalent to read(0,5,1); </span></span><br><span class="line">read(<span class="number">2</span>,<span class="number">5</span>);   <span class="comment">// is ecquivalent to read(2,5,1); </span></span><br><span class="line">read(,<span class="number">5</span>,);   <span class="comment">// is equivalent to read(0,5,1); </span></span><br><span class="line">read(,<span class="number">5</span>,<span class="number">7</span>);  <span class="comment">// is ecquivalent to read(0,5,7);</span></span><br><span class="line">read(<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>); <span class="comment">// is equivalent to read(1,5,2); </span></span><br><span class="line">read();      <span class="comment">// error;k has no default value </span></span><br><span class="line">read(<span class="number">1</span>,,<span class="number">7</span>);  <span class="comment">// error;k has no default value</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="fuction和task的参数方向"><a href="#fuction和task的参数方向" class="headerlink" title="fuction和task的参数方向"></a>fuction和task的参数方向</h3><ul>
<li>input采样只在函数或者任务的<strong>入口</strong>，其他时候不影响内部或者外部的数值。</li>
<li>output驱动只在函数或者任务的<strong>出口</strong>，其他时候不影响内部或者外部的数值。</li>
<li>ref为引用本质上为一个值，可以<strong>实时传递，既检测也修改。</strong></li>
<li>const ref可以时刻检测外部数据，但是不对其进行修改。</li>
</ul>
<h2 id="静态函数和动态函数"><a href="#静态函数和动态函数" class="headerlink" title="静态函数和动态函数"></a>静态函数和动态函数</h2><ul>
<li>如果变量被声明为automatic，那么进入该方法后，就会自动创建，离开该方法后，就会被销毁；</li>
<li>而static则是在仿真开始时就会被创建，直到仿真结束，可以被多个方法/进程共享。</li>
</ul>
<p>通过几个例子看其区别：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">automatic</span> <span class="keyword">int</span> auto_cnt(<span class="keyword">input</span> a);     <span class="comment">//定义为automatic后，cnt默认为automatic</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    cnt += a;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line"><span class="built_in">$display</span>(<span class="string">&quot;@1 auto_cnt = %0d&quot;</span>, auto_cnt(<span class="number">1</span>));     <span class="comment">//@1 auto_cnt = 1</span></span><br><span class="line"><span class="built_in">$display</span>(<span class="string">&quot;@2 auto_cnt = %0d&quot;</span>, auto_cnt(<span class="number">1</span>));     <span class="comment">//@1 auto_cnt = 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">automatic</span> <span class="keyword">int</span> auto_static_cnt(<span class="keyword">input</span> a); <span class="comment">//虽然方法定义为automatic，但是因为cnt定义为static</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    cnt += a;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line"><span class="built_in">$display</span>(<span class="string">&quot;@1 auto_static_cnt = %0d&quot;</span>, auto_static_cnt(<span class="number">1</span>));<span class="comment">//auto_static_cnt = 1</span></span><br><span class="line"><span class="built_in">$display</span>(<span class="string">&quot;@2 auto_static_cnt = %0d&quot;</span>, auto_static_cnt(<span class="number">1</span>));<span class="comment">//auto_static_cnt = 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">static</span> <span class="keyword">int</span> static_cnt(<span class="keyword">input</span> a);      <span class="comment">//虽然static的function隐含其中的变量就是static，因为我们对cnt进行了初始化，所以必须明确指出其是static还是automatic。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    cnt += a;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line"><span class="built_in">$display</span>(<span class="string">&quot;@1 static_cnt = %0d&quot;</span>, static_cnt(<span class="number">1</span>));  <span class="comment">//@1 static_cnt = 1</span></span><br><span class="line"><span class="built_in">$display</span>(<span class="string">&quot;@2 static_cnt = %0d&quot;</span>, static_cnt(<span class="number">1</span>));  <span class="comment">//@1 static_cnt = 1</span></span><br><span class="line"><span class="comment">//即使方法是static的，但是如果我们把变量定义为automatic，每次结束方法就会销毁该变量</span></span><br><span class="line"><span class="comment">//任何隐含为static的方法，如果我们需要对其中的变量进行初始化，一定要指定其是static还是automatic的，否则会报error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="keyword">automatic</span> <span class="keyword">int</span> auto_cnt(<span class="keyword">input</span> a);     <span class="comment">//如果是外部定义的，在automatic的方法中外部变量默认还是static的，不受此影响</span></span><br><span class="line">    cnt += a;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line">     auto_cnt(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">$display</span>(<span class="string">&quot;@1 auto_cnt = %0d&quot;</span>,cnt );    <span class="comment">//auto_cnt = 1</span></span><br><span class="line">    auto_cnt(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">$display</span>(<span class="string">&quot;@2 auto_cnt = %0d&quot;</span>, cnt);    <span class="comment">//auto_cnt = 2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="思考问题"><a href="#思考问题" class="headerlink" title="思考问题"></a>思考问题</h2><ul>
<li>激励器（stimulator）对于它所生成的激励，有什么办法将其所有激励数据保存下来？</li>
</ul>
<ul>
<li>对于实验中的DUT（router）设计，验证环境组件checker比较器数据正确的逻辑是什么？如何利用从monitor in（监测输入接口）和monitor out（监测输出接口）采取到的数据呢？</li>
</ul>
<ul>
<li>为什么大多数的功能都应该在模块级验证完成呢？</li>
</ul>
<ul>
<li>function和task的比较？</li>
</ul>
<ul>
<li>参数方向有哪些？差别在哪里？</li>
</ul>
]]></content>
      <categories>
        <category>笔记篇</category>
        <category>数字验证</category>
      </categories>
      <tags>
        <tag>SystemVerilog</tag>
      </tags>
  </entry>
  <entry>
    <title>SV系统验证（3）——设计特性和接口</title>
    <url>/2021/03/24/SV%E7%B3%BB%E7%BB%9F%E9%AA%8C%E8%AF%81%EF%BC%883%EF%BC%89%E2%80%94%E2%80%94%E8%AE%BE%E8%AE%A1%E7%89%B9%E6%80%A7%E5%92%8C%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="设计特性"><a href="#设计特性" class="headerlink" title="设计特性"></a>设计特性</h1><p><strong>相对于Verilog面向可综合设计的优化：</strong></p>
<ul>
<li>添加<strong>接口</strong>（interface）从而将通信和协议检查进一步封装。</li>
<li>添加类似C语言的数据类型，例如int，byte添加用户<strong>自定义类型</strong>，<strong>枚举类型</strong>，<strong>结构体类型</strong>。</li>
<li>添加<strong>类型转换</strong>（$cast（T，S）或者  ‘( ) ），添加<strong>包（package）</strong>从而使得多个设计之间可以共享公共类型和方法。</li>
<li>添加方便的<strong>赋值操作符和运算操作符</strong>，例如++、+=、===，添加priority 和unique case 语句。</li>
<li>添加**always_comb、always_latch 和 always_f **等过程语句块。</li>
</ul>
<h2 id="过程语句块的新特性"><a href="#过程语句块的新特性" class="headerlink" title="过程语句块的新特性"></a>过程语句块的新特性</h2><blockquote>
<p>always语句块被细分为了：<strong>always_comb</strong>、<strong>always_latch</strong>、<strong>always_ff</strong></p>
</blockquote>
<h3 id="组合逻辑语句块always-comb"><a href="#组合逻辑语句块always-comb" class="headerlink" title="组合逻辑语句块always_comb"></a>组合逻辑语句块always_comb</h3><ul>
<li><p>always_comb可以**自动嵌入敏感列表，而且对其中调用内部函数会自动展开并添加进去（@*并不会展开内部调用的函数，因此可能敏感列表不全,这样的后果是影响仿真，但不会影响综合）**。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @* <span class="keyword">begin</span>               <span class="comment">// &lt;=  Infers @(data)</span></span><br><span class="line">  al=data&lt;&lt;<span class="number">1</span>;                 <span class="comment">//甚至可以不给敏感列表，只不过不会执行</span></span><br><span class="line">  b1=decode();</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">begin</span>            <span class="comment">// &lt;=  Infers @(data, sel,c,d,e)</span></span><br><span class="line">  a2=data&lt;&lt;<span class="number">1</span>;</span><br><span class="line">  b2=decode();</span><br><span class="line">  ... </span><br><span class="line"><span class="keyword">end</span>                           <span class="comment">//两者在综合电路时功能一样，但仿真时由于上面的不会受sel、b、c等信号的影响</span></span><br><span class="line">                              <span class="comment">//导致仿真结果不相同</span></span><br><span class="line"><span class="keyword">function</span> decode;              <span class="comment">//function with no inputs </span></span><br><span class="line">  <span class="keyword">begin</span> </span><br><span class="line">    <span class="keyword">case</span>(sel)</span><br><span class="line">      <span class="number">2&#x27;b01</span>: decode=d | e;</span><br><span class="line">      <span class="number">2&#x27;b10</span>: decode=d &amp; e; </span><br><span class="line">      <span class="keyword">default</span>: decode=c; </span><br><span class="line">    <span class="keyword">endcase</span> </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure></li>
<li><p>always_comb可以<strong>禁止共享变量</strong>，即赋值左侧的变量无法被另一个过程块所赋值。</p>
</li>
<li><p>软件工具<strong>会检查该过程块</strong>，如果其所表示的不是组合逻辑，那么会发出警告。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(a,en) <span class="keyword">if</span>(en) y=a;     <span class="comment">//Verilog、由于没有else变成锁存逻辑</span></span><br><span class="line">=&gt;</span><br><span class="line"><span class="keyword">always_comb</span> <span class="keyword">if</span>(en) y=a;        <span class="comment">//systemverilog 会发出警报</span></span><br></pre></td></tr></table></figure></li>
<li><p>always_comb在<strong>仿真0时刻会自动触发一次</strong>，无论在0时刻是否有敏感信号列表中的信号发生变化。</p>
</li>
</ul>
<h3 id="锁存逻辑语句块always-latch"><a href="#锁存逻辑语句块always-latch" class="headerlink" title="锁存逻辑语句块always_latch"></a>锁存逻辑语句块always_latch</h3><ul>
<li><p>always_latch表示锁存逻辑，且<strong>自动插入敏感列表</strong>。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> register_reader</span><br><span class="line">	(<span class="keyword">input</span> clk,ready,resetN,</span><br><span class="line">   <span class="keyword">output</span> <span class="keyword">logic</span>[<span class="number">4</span>：<span class="number">0</span>] read_pointer);</span><br><span class="line"><span class="keyword">logic</span> enable;                  <span class="comment">//internal enable signal for the counte </span></span><br><span class="line"><span class="keyword">logic</span> overflow;                <span class="comment">//internal counter overflow flag</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always_latch</span> <span class="keyword">begin</span>             <span class="comment">//latch the ready input </span></span><br><span class="line">	<span class="keyword">if</span>(!resetN)</span><br><span class="line">  	enable &lt;= <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(ready)</span><br><span class="line">		enable &lt;= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(overflow)</span><br><span class="line">		enable&lt;=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk,<span class="keyword">negedge</span> resetN) <span class="keyword">begin</span>       <span class="comment">//5-bit counter </span></span><br><span class="line">	<span class="keyword">if</span>(!resetN)</span><br><span class="line">    &#123;overflow,read_pointer&#125; &lt;= <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(enable)</span><br><span class="line">    &#123;overflow,read_pointer&#125; &lt;= read_pointer + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></li>
<li><p>always_latch  <code>if(enable)  g&lt;=d;</code>EDA工具会<strong>检查</strong>always_latch过程块是否真正实现了锁存逻辑。</p>
</li>
</ul>
<h3 id="时序逻辑语句块always-ff"><a href="#时序逻辑语句块always-ff" class="headerlink" title="时序逻辑语句块always_ff"></a>时序逻辑语句块always_ff</h3><ul>
<li><p>always_ff用来表示<strong>时序</strong>逻辑</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">alwaya_ff @(<span class="keyword">posedge</span> clock, <span class="keyword">negedge</span> resetN）</span><br><span class="line">  <span class="keyword">if</span>(!renetN) </span><br><span class="line">		q &lt;= <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		q &lt;= d;</span><br></pre></td></tr></table></figure></li>
<li><p>敏感列表必须<strong>指明posedge 或者 negedge</strong>（综合要求），从而使得EDA工具实现同步或者异步的复位逻辑。</p>
</li>
<li><p>EDA工具也会<strong>验明</strong>always_ff过程块语句是否实现了时序逻辑。</p>
</li>
</ul>
<h2 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符"></a>赋值操作符</h2><ul>
<li><p>Verilog没有简单的方法可以对向量填充1，SV可以通过** ‘0，’1，’z 和 ‘x**来分别填充0，1，z和x，代码会根据向量的宽度自动填充，提高了代码的便捷性和复用性</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***********要求赋值64个1**********/</span></span><br><span class="line"># Verilog：</span><br><span class="line"><span class="keyword">parameter</span> N=<span class="number">64</span>;</span><br><span class="line"><span class="keyword">reg</span>[N-<span class="number">1</span>:<span class="number">0</span>] data_bus;</span><br><span class="line">data_bus=<span class="number">64&#x27;hFFFFFFFFFFFFFFF</span>;<span class="comment">//set all bits of data bus to 1</span></span><br><span class="line"></span><br><span class="line"># SystemVerilog：</span><br><span class="line">vecs[i]=&#x27;<span class="number">1</span>;              <span class="comment">//&#x27;hffffffffffffffff</span></span><br><span class="line">vecs[i]=<span class="number">64&#x27;b0</span>-<span class="number">1</span>;         <span class="comment">//&#x27;hffffffffffffffff</span></span><br><span class="line">vecs[i]=&#123;<span class="number">64</span>&#123;<span class="number">1&#x27;b1</span>&#125;&#125;;      <span class="comment">//&#x27;hffffffffffffffff</span></span><br><span class="line">vecs[i]=-<span class="number">64&#x27;b0</span>;          <span class="comment">//&#x27;hffffffffffffffff</span></span><br><span class="line">vecs[i]=<span class="number">&#x27;b1</span>;             <span class="comment">//&#x27;h0000000000000001</span></span><br><span class="line">vecs[i]=<span class="number">0</span>-<span class="number">1</span>;             <span class="comment">//&#x27;hffffffffffffffff  #32-bit隐式转换成64-bit</span></span><br><span class="line">vecs[i]=&#123;<span class="number">64</span>&#123;<span class="number">1</span>&#125;&#125;;         <span class="comment">//&#x27;h0000000100000001  #64个32-bit的1，前面被截掉</span></span><br><span class="line">vecs[i]=~<span class="number">0</span>;              <span class="comment">//&#x27;hffffffffffffffff</span></span><br></pre></td></tr></table></figure></li>
<li><p>SV在比较数据时，可以通过**==?**来进行通配比较</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] opcode; </span><br><span class="line"><span class="keyword">if</span> (opcode==?<span class="number">8&#x27;b11011</span>???)       <span class="comment">// 比较时不考虑低三位</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1617098277671-4443936a-ef07-49e3-9b17-cbcc1210863c.png#align=left&display=inline&height=221&id=ys5J1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=221&originWidth=621&size=77596&status=done&style=none&width=621" alt="image.png"></p>
</li>
<li><p>SV添加了<strong>inside操作符</strong>，用来检查数值是否在一系列值的集合中</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>]a; </span><br><span class="line"><span class="keyword">if</span> (a <span class="keyword">inside</span> &#123;<span class="number">3&#x27;b001</span>,<span class="number">3&#x27;b010</span>,<span class="number">3&#x27;b100</span>&#125;)    <span class="comment">//检查a是否在&#123;&#125;中</span></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>] a; <span class="keyword">if</span>((a==<span class="number">3&#x27;b001</span>) || (a==<span class="number">3&#x27;b010</span>) || (a==<span class="number">3&#x27;b100</span>))</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="增强的case语句"><a href="#增强的case语句" class="headerlink" title="增强的case语句"></a>增强的case语句</h2><blockquote>
<p>仿真和综合可以会将case语句做不同的翻译，Verilog定义case语句在执行时<strong>按照优先级</strong>，而综合编译器则会<strong>优化case语句中多余的逻辑</strong>。</p>
<p>SV提供了unique和priority的声明，结合<strong>case，casex</strong>和<strong>casez</strong>来进一步实现case对应的硬件电路，保持仿真与综合的一致性</p>
</blockquote>
<h3 id="unique-case语句"><a href="#unique-case语句" class="headerlink" title="unique case语句"></a>unique case语句</h3><ul>
<li>unique case要求每次case选择必须<strong>只能满足一条</strong>case选项。</li>
<li>unique case<strong>不能有重叠的选项</strong>，即多个满足条件的选项。</li>
<li>unique case可以<strong>并行执行</strong>，并且case选项必须完备。</li>
</ul>
<h3 id="priority-case语句"><a href="#priority-case语句" class="headerlink" title="priority case语句"></a>priority case语句</h3><ul>
<li>priority case则表示必须<strong>至少有一个</strong>case选项满足要求，如果有多个case选项满足时，<strong>第一个</strong>满足的分支将会被执行。</li>
<li>priority case的逻辑同 if..else 的逻辑一致。</li>
<li>unique 和 <strong>priority</strong> 的声明也可以结合 if..else 条件语句使用。</li>
<li>unique 和 priority 使得仿真行为同设计者希望实现的综合电路保持一致。</li>
</ul>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="接口的概述"><a href="#接口的概述" class="headerlink" title="接口的概述"></a>接口的概述</h2><ul>
<li>SV在Verilog语言基础上扩展了接口（interface）。</li>
<li>接口提供了一种新型的对抽象级建模的方式，可以简化建模和验证大型复杂的设计。</li>
<li>Verilog是通过模块之间进行端口连接来完成模块间通信的。对于大型的设计通过端口进行连接将会让硬件集成变得非常乏味和容易出错。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1617106469533-ce2d3d42-85a0-4a46-a99f-c820b8c8eab7.png#align=left&display=inline&height=128&id=w2DVW&margin=%5Bobject%20Object%5D&name=image.png&originHeight=128&originWidth=413&size=12606&status=done&style=none&width=413" alt="image.png"></p>
<h2 id="接口的优势"><a href="#接口的优势" class="headerlink" title="接口的优势"></a>接口的优势</h2><ul>
<li>一个设计发生了变化，不会影响太多的端口声明和连接</li>
<li>interface允许多个信号被整合到一起用来表示一个单一的抽象端口。</li>
<li>多个模块因此可以使用同一个interface，继而避免分散的多个端口信号连接。</li>
<li>避免许多不必要的重复定义，特别是对于常用总线端口</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1617107430996-e7202b7b-a425-4ad1-bb6e-f1c427704f5e.png#align=left&display=inline&height=553&id=lCfMO&margin=%5Bobject%20Object%5D&name=image.png&originHeight=812&originWidth=617&size=113097&status=done&style=none&width=420" alt="image.png"></p>
<h2 id="接口的内容"><a href="#接口的内容" class="headerlink" title="接口的内容"></a>接口的内容</h2><ul>
<li>接口不单单可以包含<strong>变量</strong>或者<strong>线网</strong>，它还可以封装模块之间<strong>通信的协议</strong>。</li>
<li>此外接口中还可以嵌入与协议有关的<strong>断言检查</strong>、功能覆盖率收集等模块。</li>
<li>接口不同于模块（module）的地方在于，<strong>接口不允许包含设计层次</strong>（接口无法例化module）但是接口可以例化接口。接口中可以进步<strong>声明modport来约束不同模块连接时的信号方向</strong>。</li>
</ul>
<h2 id="接口的声明和例化"><a href="#接口的声明和例化" class="headerlink" title="接口的声明和例化"></a>接口的声明和例化</h2><ul>
<li>接口的定义、例化方式同模块定义以及例化方式<strong>类似</strong>。</li>
<li>接口也<strong>可以有端口</strong>，例如外部接入的时钟或者复位信号。</li>
<li>接口内部可以声明所有的<strong>变量</strong>或者<strong>线网</strong>类型。</li>
<li>模块的端口如果声明方向（input、output、inout），则例化的时候可以不连接（悬空），若声明interface，则例化的时候必须连接接口实例，或另一个接口端口。<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> main_bus (<span class="keyword">input</span> <span class="keyword">logic</span> clock,resetN,test_mode); </span><br><span class="line">  <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] data; </span><br><span class="line">  <span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] address;</span><br><span class="line">  <span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] slave_instruction;</span><br><span class="line">	<span class="keyword">logic</span> slave_request; </span><br><span class="line">	<span class="keyword">logic</span> bus_grant; </span><br><span class="line">	<span class="keyword">logic</span> bus_request; </span><br><span class="line">	<span class="keyword">logic</span> slave_ready;</span><br><span class="line">	<span class="keyword">logic</span> data_ready; </span><br><span class="line">	<span class="keyword">logic</span> mem_read;</span><br><span class="line">	<span class="keyword">logic</span> mem_write; </span><br><span class="line"><span class="keyword">endinterface</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> top (<span class="keyword">input</span> <span class="keyword">logic</span> clock, resetN, test_mode); </span><br><span class="line"><span class="keyword">logic</span> [<span class="number">15</span>:<span class="number">0</span>] <span class="keyword">program</span> address, jump address; </span><br><span class="line"><span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] instruction, next_instruction; </span><br><span class="line"></span><br><span class="line">main_bus bus              <span class="comment">//例化一个接口</span></span><br><span class="line">(  <span class="variable">.c1ock</span>(clock), </span><br><span class="line">   ·resetN(resetN),</span><br><span class="line">	 <span class="variable">.test_mode</span>(test_mode)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">assign</span> bus<span class="variable">.address</span>=mem_select? slave_address:&#x27;z; </span><br><span class="line"><span class="keyword">assign</span> bus<span class="variable">.data</span>=bus<span class="variable">.slave_ready</span>? slave_data:&#x27;z;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************索引接口中的单个信号***********/</span></span><br><span class="line">&lt;port name&gt;.&lt;internal <span class="keyword">interface</span> signal name&gt;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> bus<span class="variable">.clock</span>, <span class="keyword">negedge</span> bus<span class="variable">.resetN</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="采样和数据驱动"><a href="#采样和数据驱动" class="headerlink" title="采样和数据驱动"></a>采样和数据驱动</h2><h3 id="竞争问题"><a href="#竞争问题" class="headerlink" title="竞争问题"></a>竞争问题</h3><ul>
<li>在仿真行为中，为了尽量避免<strong>时序电路中时钟和驱动信号的时序竞争</strong>问题，我们需要给出尽量明确的驱动时序和采样时序。</li>
<li>默认情况下，<strong>时钟对于组合电路的驱动会添加一个无限最小时间（delta-cycle）的延迟</strong>，而该延迟无法用绝对时间单位衡量，它要比最小时间单位精度还小。</li>
<li>在一个时间片（time-slot）中可以发生很多事情，例如在仿真器中敲入命令”run 0”，即是让仿真器运行一个delta-cycle的时间。</li>
<li>由于各种可能性，clk与被采样数据之间如果只存在<strong>若干个（0..N）delta-cycle的延迟</strong>，因此采样数据中的竞争问题会成为潜在困扰仿真采样准确性的问题。</li>
</ul>
<h3 id="避免采样的竞争问题"><a href="#避免采样的竞争问题" class="headerlink" title="避免采样的竞争问题"></a>避免采样的竞争问题</h3><ul>
<li>在驱动时，<strong>添加相应的人为延迟</strong>，模拟真实的延迟行为，同时加大clk与变量之间的延迟，以此提高DUT使用信号时的准确度和TB采样信号时的可靠性。</li>
<li>对于一些采样时依然存在delta-cycle延迟的信号，我们还可以依靠在<strong>采样事件前的某段时刻中进行采样</strong>，来模拟建立时间的采样要求，确保采样的可靠性。</li>
</ul>
<h3 id="时钟块的使用"><a href="#时钟块的使用" class="headerlink" title="时钟块的使用"></a>时钟块的使用</h3><ul>
<li>clocking块可以定义在interface、module、program中</li>
<li>clocking中列举的信号应该由interface或者其它声明clocking的模块定义的</li>
<li>clocking在声明完名字之后，应该伴随着定义默认的采样事件，即”default input/output event”</li>
<li>clocking默认采样事件前的<strong>1step</strong>对输入进行采样，在采样事件后的**#0**对输出进行驱动</li>
<li>也可以在定义信号方向时，用<strong>新的采样事件可以对默认事件做覆盖</strong></li>
<li>接口中可以<strong>多个</strong>添加时钟块，且同一信号在不同时钟块中<strong>方向可以不同</strong></li>
<li>时钟块采样和时钟直接采样，<strong>被测值的变化均在上升沿</strong>，仅仅是采样点不同</li>
<li>输入数据要求在<strong>设定的时间之前</strong>就要满足数值的建立<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">clocking</span> bus @(<span class="keyword">posedge</span> clock1);   <span class="comment">//定义时钟块上升沿驱动、采样</span></span><br><span class="line">  <span class="keyword">default</span> <span class="keyword">input</span> #<span class="number">10</span>ns             <span class="comment">//默认上升沿之前10ns采样</span></span><br><span class="line">          <span class="keyword">output</span> #<span class="number">2</span>ns;            <span class="comment">//默认上升沿之后2ns驱动</span></span><br><span class="line">  <span class="keyword">input</span> data,ready,enable;        <span class="comment">//对三个输入信号采样（前10ns）</span></span><br><span class="line">  <span class="keyword">output</span> <span class="keyword">negedge</span> ack;             <span class="comment">//clock1下降沿驱动ack（后2ns）</span></span><br><span class="line">  <span class="keyword">input</span> #l step_addr;             <span class="comment">//clock1上升沿前1时间片采样</span></span><br><span class="line"><span class="keyword">endclocking</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="接口规定方向"><a href="#接口规定方向" class="headerlink" title="接口规定方向"></a>接口规定方向</h2><ul>
<li>接口中的变量或者线网信号，对于连接到该接口的不同模块则可能具备这<strong>不同的连接方向</strong>。</li>
<li>引入了modport来作为module port的缩写，表示<strong>不同的模块看到同一组信号时的视角</strong>（连接方向）。</li>
<li>在接口中声明modport，需要指明modport中各个信号的方向，<strong>不需要声明宽度</strong>。<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> chip_bus (<span class="keyword">input</span> <span class="keyword">logic</span> clock,restN);</span><br><span class="line">	<span class="keyword">modport</span> master(...); </span><br><span class="line">	<span class="keyword">modport</span> slave (...); </span><br><span class="line"><span class="keyword">endinterface</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> primary (<span class="keyword">interface</span> pins);    <span class="comment">//一般接口例化 </span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">endmodule</span> </span><br><span class="line"></span><br><span class="line">  <span class="keyword">module</span> secondary (chip_bus pins); <span class="comment">//指定接口例化 </span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">endmodule</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> chip(<span class="keyword">input</span> <span class="keyword">logic</span> clock, resetN); </span><br><span class="line">  chip bus bus (clock, resetN);  <span class="comment">//例化接口 </span></span><br><span class="line">  primary il (bus. master);      <span class="comment">//例化模块1 具体到哪一根线减少意外驱动</span></span><br><span class="line">  secondary i2 (bus. slave);     <span class="comment">//例化模块2</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="接口总结"><a href="#接口总结" class="headerlink" title="接口总结"></a>接口总结</h2><ul>
<li>接口对于设计<strong>复用</strong>非常有利，如果要添加新的信号，只需要在接口中声明，而不必在模块中声明。</li>
<li>接口<strong>减少</strong>了模块之间错误连接的可能性。</li>
<li>由于接口将有关信号都集合在一起，因此在使用这些信号时需要多添加一个层次（接口实例名）。</li>
<li>接口往往会将有关的信号集合在一起，这意味着对于拥有多组不相关信号的设计而言，它可能需要有多个接口实例才能完成与其它模块的连接。</li>
</ul>
]]></content>
      <categories>
        <category>笔记篇</category>
        <category>数字验证</category>
      </categories>
      <tags>
        <tag>SystemVerilog</tag>
      </tags>
  </entry>
  <entry>
    <title>SV系统验证（2）——数据类型和字符串</title>
    <url>/2021/03/22/SV%E7%B3%BB%E7%BB%9F%E9%AA%8C%E8%AF%81%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="Verilog中的数据类型"><a href="#Verilog中的数据类型" class="headerlink" title="Verilog中的数据类型"></a>Verilog中的数据类型</h2><blockquote>
<p>Verilog中有两种基本数据类型：变量类型（variables）、线网类型（wire）<br><strong>两种类型均为四值逻辑(1、0、X、Z)</strong><br><strong>真实电路中不存在X，高阻态Z表示引脚悬空</strong></p>
</blockquote>
<h3 id="变量类型（variables）"><a href="#变量类型（variables）" class="headerlink" title="变量类型（variables）"></a>变量类型（variables）</h3><blockquote>
<p><strong>用来储存组合逻辑或者时序逻辑的值</strong></p>
</blockquote>
<p><strong>变量类型特点：</strong></p>
<ul>
<li><p>变量保存在initial、always、task、function内赋值</p>
</li>
<li><p><strong>变量只能用过程赋值（initial、always）来赋值</strong></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span>            描述逻辑</span><br><span class="line"><span class="keyword">integer</span>        描述循环变量和计算 </span><br><span class="line"><span class="keyword">real</span>           在系统模型中使用 </span><br><span class="line"><span class="keyword">time</span>和<span class="keyword">realtime</span> 保存测试装置的仿真时间</span><br></pre></td></tr></table></figure></li>
<li><p>intger或time的变量一般有相同位数的reg一样运转</p>
</li>
</ul>
<blockquote>
<p>其中变量类型包括：reg、integer、time、real等<br><strong>reg可以被综合成寄存器、锁存器（寄存器是时序逻辑，锁存器是组合逻辑）</strong></p>
</blockquote>
<h3 id="线网类型（nets）"><a href="#线网类型（nets）" class="headerlink" title="线网类型（nets）"></a>线网类型（nets）</h3><blockquote>
<p><strong>用来连接硬件模块，以提供特殊的线网逻辑解决方案</strong></p>
</blockquote>
<ul>
<li>线网在建模结构化描述中连接线路、且总线线网的值由线网的驱动器决定</li>
<li>驱动器可以是门，模块的实例或者<strong>连续赋值</strong>的输出</li>
<li><strong>只能用连续赋值语句（assign）</strong></li>
</ul>
<blockquote>
<p>其中线网类型包括：wire、wor、wand等</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">##在SystemVerilog中任何一个变量要看三部分：##</span><br><span class="line"></span><br><span class="line">* 类型（变量、线网）</span><br><span class="line">* 数据类型（四值逻辑、二值逻辑）</span><br><span class="line">* 符号（有符号、无符号）</span><br></pre></td></tr></table></figure>
<h2 id="SyestemVerilog的类型"><a href="#SyestemVerilog的类型" class="headerlink" title="SyestemVerilog的类型"></a>SyestemVerilog的类型</h2><h3 id="变量（variables）"><a href="#变量（variables）" class="headerlink" title="变量（variables）"></a>变量（variables）</h3><ul>
<li>可以使用连续赋值（assign）、过程赋值(always)<blockquote>
<p>logic a ：默认变量（var）类型、无符号<br>bit a：默认变量（var）类型、无符号<br>var logic [63:0] a ;  也可以对其类型声明</p>
</blockquote>
</li>
</ul>
<h3 id="线网类型（nets）-1"><a href="#线网类型（nets）-1" class="headerlink" title="线网类型（nets）"></a>线网类型（nets）</h3><ul>
<li>只能用连续赋值语句（assign）<blockquote>
<p>Testbench中一般大量使用<strong>logic</strong>，只有在<strong>多个驱动源</strong>或者<strong>设计模块端口是双向（inout）</strong>的时候才用wire</p>
</blockquote>
</li>
</ul>
<h2 id="SystemVerilog的数据类型"><a href="#SystemVerilog的数据类型" class="headerlink" title="SystemVerilog的数据类型"></a>SystemVerilog的数据类型</h2><h3 id="四值逻辑（Logic）"><a href="#四值逻辑（Logic）" class="headerlink" title="四值逻辑（Logic）"></a>四值逻辑（Logic）</h3><ul>
<li>在Verilog中reg常用来表示储存组合逻辑或者时序逻辑的变量，不过初学者容易混淆其综合后的硬件单元，<strong>实际它只和线网相对，用来表示储存数据的变量</strong></li>
<li>在SV中我们可以直接使用logic来通用储存硬件数据</li>
</ul>
<blockquote>
<p>四值逻辑包括：integer、logic、reg、net-type（wire、tri）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">什么时候用四值逻辑？</span><br><span class="line">  - 在表示硬件时，必须用四值逻辑</span><br><span class="line">  - X值用来捕捉设计错误（如寄存器未初始化）</span><br><span class="line">  - Z值用来表示未连接或者三态的设计逻辑（但很少出现在系统级或者事务级）</span><br></pre></td></tr></table></figure>
<h3 id="二值逻辑（bit）"><a href="#二值逻辑（bit）" class="headerlink" title="二值逻辑（bit）"></a>二值逻辑（bit）</h3><ul>
<li>bit类型可以综合，但综合的电路有失真的可能，无法正确表示电路，因此在RTL中很少用到</li>
</ul>
<blockquote>
<p>二值逻辑包括：bit、byte、shortint、int、longint</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">什么时候用到二值逻辑？</span><br><span class="line">  - 在构建验证环境总线功能模型（BFM）时，无须关注底层逻辑，可使用二值逻辑</span><br><span class="line">  - SV在和C语言交互时，也可使用二值逻辑简化数据传输</span><br></pre></td></tr></table></figure>
<h3 id="仿真初值和转换"><a href="#仿真初值和转换" class="headerlink" title="仿真初值和转换"></a>仿真初值和转换</h3><ul>
<li>四值逻辑变至例如reg、logic或者integer等，在仿真开始时的初值为X</li>
<li>二值逻辑变量例如bit等，在仿真开始时的初值为0</li>
<li>四值逻辑 =&gt; 二值逻辑（默认转换），那么Z、X =&gt; 0</li>
</ul>
<h2 id="SystemVerilog数据的符号"><a href="#SystemVerilog数据的符号" class="headerlink" title="SystemVerilog数据的符号"></a>SystemVerilog数据的符号</h2><h3 id="有符号"><a href="#有符号" class="headerlink" title="有符号"></a>有符号</h3><ul>
<li>integer</li>
<li>byte</li>
<li>shortint</li>
<li>int</li>
<li>longint</li>
</ul>
<h3 id="无符号"><a href="#无符号" class="headerlink" title="无符号"></a>无符号</h3><ul>
<li>logic、bit、reg、net-type（wire、tri）构成的向量</li>
<li>在有符号类型后面加unsigned（如byte unsigned）</li>
</ul>
<h3 id="空类型（void）"><a href="#空类型（void）" class="headerlink" title="空类型（void）"></a>空类型（void）</h3><ul>
<li>SV添加void类型来表示空类型，表示不会返回数值，同C语言的void使用方法</li>
<li>SV添加shortreal表示32位单精度浮点类型，同C语言的loat；而Verilog的real类型表示双精度浮点类型，同C语言的double</li>
</ul>
<h2 id="自定义类型（typedef）"><a href="#自定义类型（typedef）" class="headerlink" title="自定义类型（typedef）"></a>自定义类型（typedef）</h2><blockquote>
<p><strong>为了代码更加易读和维护，通常在加上“_t”后缀表示自定义类型</strong></p>
</blockquote>
<h3 id="枚举类型（enum）"><a href="#枚举类型（enum）" class="headerlink" title="枚举类型（enum）"></a>枚举类型（enum）</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;red,green,blue&#125;  RGB;</span><br><span class="line">RGB枚举类型拥有三个值，其中初始值为red</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Verilog没有枚举类型，因此采用define 和parameter 来定义，提高易读性</p>
</blockquote>
<ul>
<li><p>枚举值<strong>默认为int类型</strong>，32-bit的二值逻辑</p>
</li>
<li><p>SV允许指定枚举的数据类型</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">bit</span> &#123;ture,false&#125; ck_t;</span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">logic</span>[<span class="number">1</span>:<span class="number">0</span>] &#123;waite,load,ready&#125; state_e;</span><br></pre></td></tr></table></figure></li>
<li><p>如果一个枚举类型的数值被赋值，那么赋值应该符合其数值类型</p>
</li>
<li><p>枚举类型可以转换成整型（隐式），但整型不能转化成枚举类型</p>
</li>
</ul>
<h4 id="自定义枚举类型"><a href="#自定义枚举类型" class="headerlink" title="自定义枚举类型"></a>自定义枚举类型</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;waite,load,ready&#125; state_t; </span><br><span class="line">state_t state_now,state_next</span><br></pre></td></tr></table></figure>
<h4 id="枚举类型赋值"><a href="#枚举类型赋值" class="headerlink" title="枚举类型赋值"></a>枚举类型赋值</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;waite,load,ready&#125; state_t;</span><br><span class="line">	state_t state, next_state</span><br><span class="line"><span class="keyword">int</span> foo;</span><br><span class="line">state=next_state;      <span class="comment">//legal operation </span></span><br><span class="line">foo = state + <span class="number">1</span>;       <span class="comment">//legal operation </span></span><br><span class="line">state = foo + <span class="number">1</span>;       <span class="comment">//**ERROR:illegal assignment** </span></span><br><span class="line">state = state + <span class="number">1</span>;     <span class="comment">//**illegal operation **</span></span><br><span class="line">state++;               <span class="comment">//**illegal operation next **</span></span><br><span class="line">next_state += state;   <span class="comment">//**illegal operation**</span></span><br></pre></td></tr></table></figure>
<h3 id="结构体类型（struct）"><a href="#结构体类型（struct）" class="headerlink" title="结构体类型（struct）"></a>结构体类型（struct）</h3><ul>
<li>SV中添加了C一样的结构体struct，其成员可以为自定义类型或其他常量类型<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span>&#123;</span><br><span class="line">  <span class="keyword">int</span> [<span class="number">31</span>:<span class="number">0</span>] a,b;           <span class="comment">//32-bit variables </span></span><br><span class="line">  <span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] opcode;       <span class="comment">//user-defined type </span></span><br><span class="line">  <span class="keyword">logic</span> [<span class="number">23</span>:<span class="number">0</span>] address;	    <span class="comment">//24-bit variable </span></span><br><span class="line">  <span class="keyword">bit</span> error;				        <span class="comment">//1-bit 2-state var.</span></span><br><span class="line">&#125; Instruction_Word;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p><strong>结构体默认是一个 <em>变量</em> ，用户可以将其声明为var或者wire类型</strong></p>
</blockquote>
<h4 id="自定义结构体类型"><a href="#自定义结构体类型" class="headerlink" title="自定义结构体类型"></a>自定义结构体类型</h4><ul>
<li>类似于枚举类型，结构体类型也可以使用typedef来定义<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;<span class="comment">// structure definition </span></span><br><span class="line">  <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] a,b; </span><br><span class="line">  <span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] opcode; </span><br><span class="line">  <span class="keyword">logic</span> [<span class="number">23</span>:<span class="number">0</span>] address;</span><br><span class="line">&#125; instruction_word_t; </span><br><span class="line"></span><br><span class="line">instruction_word_t IW;<span class="comment">// structure allocation</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="结构体类型赋值"><a href="#结构体类型赋值" class="headerlink" title="结构体类型赋值"></a>结构体类型赋值</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">结构体变量可以通过索引其各个成员做依次的成员赋值：</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clock, <span class="keyword">negedge</span> resetN)</span><br><span class="line">  <span class="keyword">if</span>(!resetN)<span class="keyword">begin</span> </span><br><span class="line">		IW<span class="variable">.a</span>=<span class="number">100</span>;       <span class="comment">//reference structure member </span></span><br><span class="line"> 		IW<span class="variable">.b</span>=<span class="number">5</span>;</span><br><span class="line">    IW<span class="variable">.opcode</span>=<span class="number">8&#x27;hFF</span>;</span><br><span class="line">	 	IW<span class="variable">.address</span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line"></span><br><span class="line">也可以通过单分号`和花括号&#123;&#125;来实现整体赋初值：</span><br><span class="line">IW=&#x27;&#123;<span class="number">100</span>, <span class="number">3</span>, <span class="number">8&#x27;hFF</span>, <span class="number">0</span>&#125;;</span><br><span class="line">IW=&#x27;&#123;address:<span class="number">0</span>, opcode:<span class="number">8&#x27;hFF</span>, a:<span class="number">100</span>, b:<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><ul>
<li>Verilog语言对于字符串的处理手段非常有限。</li>
<li>SV引入了string类型用来容纳<strong>可变长度</strong>的字符串。</li>
<li>字符串类型变量的<strong>存储单元为byte类型</strong>。</li>
<li>字符串类型变量长度为N时，其字符成员索引值为从0到N-1.</li>
<li>不同于C函数，字符串结尾**没有“空字符“即null字符“\0”**。</li>
<li>字符串的内存是<strong>动态分配</strong>的，用户无需担心内存空间管理。</li>
</ul>
<h3 id="字符串常见使用方式"><a href="#字符串常见使用方式" class="headerlink" title="字符串常见使用方式"></a>字符串常见使用方式</h3><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">logic</span>[<span class="number">15</span>：<span class="number">0</span>] r_t;</span><br><span class="line">r_tr;</span><br><span class="line"><span class="keyword">integer</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">string</span> b=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">string</span> a=&#123;<span class="string">&quot;Hi&quot;</span>，b&#125;;		<span class="comment">//字符串拼接</span></span><br><span class="line">r=r_t&#x27;(a);		   	<span class="comment">//将字符串a内容*显式*转化成字节赋值给r </span></span><br><span class="line">b=<span class="keyword">string</span>&#x27;(r);			<span class="comment">//ok </span></span><br><span class="line">b=<span class="string">&quot;Hi&quot;</span>;				  	<span class="comment">//oK </span></span><br><span class="line">b=&#123;<span class="number">5</span>&#123;<span class="string">&quot;Hi&quot;</span>&#125;&#125;;			<span class="comment">//oK </span></span><br><span class="line">a=&#123;i&#123;<span class="string">&quot;Hi&quot;</span>&#125;&#125;;			<span class="comment">//oK（non-constant replication）</span></span><br><span class="line">a=&#123;i&#123;b&#125;&#125;;		    	<span class="comment">//oK </span></span><br><span class="line">a=&#123;a,b&#125;;			  	<span class="comment">//ok </span></span><br><span class="line">a=&#123;<span class="string">&quot;Hi&quot;</span>,b&#125;;		  	<span class="comment">//oK </span></span><br><span class="line">b=&#123;<span class="string">&quot;H&quot;</span>,<span class="string">&quot;&quot;</span>&#125;;		   	<span class="comment">//yields&quot;H&quot;.&quot;&quot;is the empty string </span></span><br><span class="line">a[<span class="number">0</span>]=<span class="string">&quot;h&quot;</span>;				  <span class="comment">//oK，将字符串第0位赋值为h</span></span><br><span class="line">a[<span class="number">0</span>]=<span class="string">&quot;cough&quot;</span>;			<span class="comment">//字符串赋值给某一位时，取最后一个即h</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>字符串的索引是从左到右0 =&gt;N-1</strong><br><strong>logic [15:0] 索引最右端是0</strong></p>
</blockquote>
<h3 id="字符串内建方式"><a href="#字符串内建方式" class="headerlink" title="字符串内建方式"></a>字符串内建方式</h3><ul>
<li>str.len()：返回字符串的长度</li>
<li>str.putc(i,c)：将第i个字符替换成字符c，等同于str[i]=c</li>
<li>str.getc(i)：返回第i个字符</li>
<li>str.substr(i,j)：返回从第i个字符到第j个字符</li>
<li>str.{atoi(), atohex(), atooct(), atobin}：将字符串转化成十进制，十六进制，八进制，或者二进制</li>
</ul>
<h2 id="附录：数据类型和字符串思维导图"><a href="#附录：数据类型和字符串思维导图" class="headerlink" title="附录：数据类型和字符串思维导图"></a>附录：数据类型和字符串思维导图</h2><p><img src="01.png#id=jo8oQ&originalType=binary&status=done&style=none"></p>
]]></content>
      <categories>
        <category>笔记篇</category>
        <category>数字验证</category>
      </categories>
      <tags>
        <tag>SystemVerilog</tag>
      </tags>
  </entry>
  <entry>
    <title>SV系统验证（1）——芯片开发及验证概述</title>
    <url>/2021/03/21/SV%E7%B3%BB%E7%BB%9F%E9%AA%8C%E8%AF%81%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94%E8%8A%AF%E7%89%87%E5%BC%80%E5%8F%91%E5%8F%8A%E9%AA%8C%E8%AF%81%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>什么是验证：用来证明设计功能的正确，符合设计功能描述的流程（两者有区别）</p>
<h2 id="测试平台"><a href="#测试平台" class="headerlink" title="测试平台"></a>测试平台</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1620182924960-56079564-778c-412c-996c-413137ed4d32.png#clientId=ud7632509-35bd-4&from=drop&id=u6c3c28d3&margin=%5Bobject%20Object%5D&name=01.png&originHeight=230&originWidth=375&originalType=binary&size=11379&status=done&style=none&taskId=u61adc09a-1b49-4b80-b281-ddbfe5d2b6e" alt="01.png"></p>
<ul>
<li>观察DUT创建测试序列（Stimulator）</li>
<li>观察DUT的输入输出（Moniter）</li>
<li>对DUT的输出数据与预期数据进行比对（Checker）</li>
<li>报告检查结果</li>
</ul>
<blockquote>
<p>软件验证和硬件验证的区别：<strong>时序的问题</strong></p>
</blockquote>
<h2 id="芯片开发流程"><a href="#芯片开发流程" class="headerlink" title="芯片开发流程"></a>芯片开发流程</h2><ul>
<li>用户需求：从市场人员与客户开始，与系统设计人员一同生成设计结构与产品描述文档</li>
<li>系统设计：系统设计人员按照功能划分为各个子系统，推出模块功能详述文档</li>
<li>硬件设计：子系统被进一步划分为功能模块，并由硬件设计团队实现写出硬件描述文件</li>
<li>功能验证：验证人员编写<strong>验证环境文件和测试用例</strong>对设计功能展开验证，发现设计缺陷，交由设计人员修正</li>
<li>后端综合：验证没有出现漏洞后，交由后端人员进行综合、布局、布线</li>
<li>芯片流片：后端人员将核心数据交由FAB进行流片</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1620182944278-2a39dad3-4b1c-416b-bd85-9d01a8030e5a.png#clientId=ud7632509-35bd-4&from=drop&id=ubcbd3907&margin=%5Bobject%20Object%5D&name=02.png&originHeight=475&originWidth=342&originalType=binary&size=40847&status=done&style=none&taskId=u86e73854-c2d3-4e2c-87d0-3b7424b1a40" alt="02.png"></p>
<blockquote>
<p>为什么芯片设计是流水线，做不到软件设计一样频繁迭代：<strong>芯片设计的成本太大。</strong></p>
<p>交给后端综合、布局布线之前的验证为<strong>功能验证</strong>，而后端只需要通过工具对静态时序进行分析，进行小幅的一些修正，其实可以达到一个不需要验证的水平 但是在实际过程中，我们在布局布线后会做门级验证，门级验证主要是查看一些没有预料到的情况，比如<strong>接口时序的问题，跨时钟域的问题。</strong></p>
</blockquote>
<h2 id="验证人员做了哪些工作"><a href="#验证人员做了哪些工作" class="headerlink" title="验证人员做了哪些工作"></a>验证人员做了哪些工作</h2><p>在设计人员根据设计功能描述，实现各个模式RTL代码之后，开始构建验证环境，做几项工作来检查设计：</p>
<ul>
<li>设计文件是否正确地按照功能文档去实施了？</li>
<li>硬件设计人员是否有遗漏的边界情况（corner case）？随机能够帮助我们击打边界情况</li>
<li>硬件设计是否足够稳定来处理一些错误情况（error response）</li>
</ul>
<h2 id="验证和设计的协作"><a href="#验证和设计的协作" class="headerlink" title="验证和设计的协作"></a>验证和设计的协作</h2><ul>
<li>验证和设计都需要认真阅读功能描述文档</li>
<li>设计会将其翻译为RTL模型验证会按照其功能发送激励和比较结果</li>
<li>验证会按照其功能发送激励和比较结果</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1620182981079-3c646729-3289-4eca-aee9-20b5299c552c.png#clientId=ud7632509-35bd-4&from=drop&id=u33f7b64a&margin=%5Bobject%20Object%5D&name=03.png&originHeight=271&originWidth=444&originalType=binary&size=33235&status=done&style=none&taskId=u5f4fc7e6-9d19-42d5-9b02-6877c580e99" alt="03.png"></p>
<blockquote>
<p>SystemVerilog提供了外界语言的接口，验证人员可以利用c/c++等高级语言编写预期模型对模块进行验证</p>
</blockquote>
<h2 id="设计和验证的关系"><a href="#设计和验证的关系" class="headerlink" title="设计和验证的关系"></a>设计和验证的关系</h2><p><strong>独立设计和验证</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1620182993760-29dcddcb-662f-49e7-a921-71a92cd41859.png#clientId=ud7632509-35bd-4&from=drop&id=u4cd1d7d3&margin=%5Bobject%20Object%5D&name=04.png&originHeight=112&originWidth=488&originalType=binary&size=16004&status=done&style=none&taskId=uab7f1a5f-a165-4c9d-9026-433c436e4d3" alt="04.png"><br><strong>合作设计和验证</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1620183000621-fc274951-81bd-47b7-a338-993fd75e9d68.png#clientId=ud7632509-35bd-4&from=drop&id=ua00c60b1&margin=%5Bobject%20Object%5D&name=05.png&originHeight=126&originWidth=475&originalType=binary&size=19105&status=done&style=none&taskId=ueca6b561-ed07-4e61-bfa7-9df7c385d7b" alt="05.png"></p>
<h2 id="验证的重要性"><a href="#验证的重要性" class="headerlink" title="验证的重要性"></a>验证的重要性</h2><ul>
<li>重大缺陷造成额外的成本损失是越靠后越巨大（尽量在硅前）</li>
<li>验证阶段快而全地找到缺陷）</li>
<li>缺陷率增长曲线的曲率是逐渐减小</li>
<li>快而全地提供缺陷率增长是理想目标（量化验证）</li>
</ul>
<blockquote>
<p><strong>重大缺陷：</strong>一旦出现重大缺陷，整个芯片的绝大多数基本功能，甚至是核心功能受到影响甚至是不可修复的（软件也搞不定）</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1620183025589-a33c64e6-6022-466c-86d7-3eec26127b13.png#clientId=ud7632509-35bd-4&from=drop&id=ucd166127&margin=%5Bobject%20Object%5D&name=06.png&originHeight=230&originWidth=575&originalType=binary&size=30199&status=done&style=none&taskId=u8bd23246-42fd-4e40-830e-edbdba9dbba" alt="06.png"></p>
<h2 id="验证的目标"><a href="#验证的目标" class="headerlink" title="验证的目标"></a>验证的目标</h2><ul>
<li>对于一名验证师而言，他的工作就是完成分配给他的任务这个任务可能是模块级（module level）、子系统级（module level）或者系统级（module level）</li>
<li>验证的目标，就是“按时保质低耗”完成目标硬件设计的验证工作 <ul>
<li>按时：考虑节点（milestone）</li>
<li>低耗：更短的时间和人力，可以预期控制的成本</li>
<li>保质：尽可能地将缺陷暴露在流片以后，减小额外成本</li>
</ul>
</li>
</ul>
<p><strong>缺陷增长曲线</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1620183039352-12187a4c-c56b-47d7-9ef7-fda70c12e860.png#clientId=ud7632509-35bd-4&from=drop&id=ue7775eb8&margin=%5Bobject%20Object%5D&name=07.png&originHeight=291&originWidth=371&originalType=binary&size=29818&status=done&style=none&taskId=u5992e166-8b90-4ff5-997c-7f32c960b17" alt="07.png"></p>
<ul>
<li>通过缺陷数量在时间上的记录，我们可以绘制出缺陷数量的增长曲线</li>
<li>采取先简单再复杂的测试序列</li>
<li>保证缺陷增长曲线逐步收敛</li>
<li>在验证后期阶段不应该再出现基本设计缺陷</li>
</ul>
<h2 id="验证周期"><a href="#验证周期" class="headerlink" title="验证周期"></a>验证周期</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1620183049499-feeed7e6-a761-4060-9372-4001cdab1eda.png#clientId=ud7632509-35bd-4&from=drop&id=u4ce74a73&margin=%5Bobject%20Object%5D&name=08.png&originHeight=362&originWidth=405&originalType=binary&size=55271&status=done&style=none&taskId=u931af7cf-aa8f-4e7d-99b4-59272572ab5" alt="08.png"></p>
<ol>
<li>创建验证计划 ➡ 在验证过程要经常回顾验证计划</li>
<li>开发验证环境</li>
<li>调试环境和HDL文件 ➡ 检查验证代码</li>
<li>递归测试（回归测试） ➡ 流片前验证完备性检查</li>
<li>硅后系统测试</li>
<li>展开逃逸分析（escape analysis） ➡ 吸取教训</li>
</ol>
<h2 id="思考问题"><a href="#思考问题" class="headerlink" title="思考问题"></a>思考问题</h2><blockquote>
<p><strong>设计人员和验证人员他们的协作关系体现在哪些地方？</strong></p>
<ul>
<li>验证和设计都需要认真阅读功能描述文档</li>
<li>设计会将其翻译为RTL模型</li>
<li>验证会按照其功能发送激励和比较结果</li>
</ul>
</blockquote>
<blockquote>
<p><strong>为什么芯片验证的重要性目前越来越高？</strong></p>
<ul>
<li>硬件设计没有验证是没有信心去流片的</li>
<li>即使流片成功，设计缺陷暴露的问题会使芯片设计的额外成本呈指数上升</li>
<li>对于航天芯片、汽车芯片等重要芯片需要极高的安全性，需要芯片验证团队保驾护航</li>
</ul>
</blockquote>
<blockquote>
<p><strong>在一个完成的验证周期中，有哪些工作需要完成呢？</strong></p>
<ol>
<li>创建验证计划</li>
<li>开发验证环境</li>
<li>调试环境和HDL文件</li>
</ol>
</blockquote>
<h2 id="附录：芯片开发概述及验证概述思维导图"><a href="#附录：芯片开发概述及验证概述思维导图" class="headerlink" title="附录：芯片开发概述及验证概述思维导图"></a>附录：芯片开发概述及验证概述思维导图</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1620183059050-66d5bc36-d92a-4907-90ef-8bd816b5c6c9.png#clientId=ud7632509-35bd-4&from=drop&id=u19cb88d2&margin=%5Bobject%20Object%5D&name=09.png&originHeight=2048&originWidth=1567&originalType=binary&size=642234&status=done&style=none&taskId=ubc9b2df0-54e9-420d-933e-7201732cea7" alt="09.png"></p>
]]></content>
      <categories>
        <category>笔记篇</category>
        <category>数字验证</category>
      </categories>
      <tags>
        <tag>SystemVerilog</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈卷积神经网络</title>
    <url>/2020/12/06/%E6%B5%85%E8%B0%88%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在YouTube上刷视频的时候偶然看见李永乐老师讲解<a href="https://www.youtube.com/watch?v=AFlIM0jSI9I&t=940s">卷积神经网络</a>，主要是面向图像处理的，觉得还挺有意思的，就想着整理一下，万一以后用的上也能看看。</p>
<h2 id="视觉原理"><a href="#视觉原理" class="headerlink" title="视觉原理"></a>视觉原理</h2><ul>
<li><p>首先介绍计算机在识别图像的时候，是将图像中的每个像素点转化成数字处理识别，但是这样的话，如果图片发生了旋转、放缩等变化，像素信息和原来不相同，那么计算机便无法识别。但是人眼就可以轻易的分辨，即使图片发生了变化。</p>
</li>
<li><p>经神经学家研究，人眼中有两种细胞一种<strong>简单</strong>细胞只对线条敏感，一种<strong>复杂</strong>细胞对运动敏感。</p>
</li>
<li><p>福岛邦彦提出神经认知模型，即</p>
<blockquote>
<p>光-&gt;第一皮层-&gt;第二皮层-&gt;第三皮层-&gt;……<br>图像经由像素点-&gt;边缘、方向-&gt;轮廓、细节-&gt;……-&gt;判断</p>
</blockquote>
</li>
<li><p>杨立昆提出卷积神经网络（CNN）</p>
</li>
</ul>
<h2 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h2><h3 id="卷积概念"><a href="#卷积概念" class="headerlink" title="卷积概念"></a>卷积概念</h3><ul>
<li>卷积作用：数学图像方法提取图片特征</li>
</ul>
<h3 id="卷积核"><a href="#卷积核" class="headerlink" title="卷积核"></a>卷积核</h3><ul>
<li>卷积核：一个用来提取图像特征的矩阵（一般3<em>3或者5</em>5），卷积核表征的<strong>想要提取的特征</strong>。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619693022167-8d66485f-2943-4dbe-bc9e-fc21db7527b0.png#align=left&display=inline&height=82&margin=%5Bobject%20Object%5D&name=image.png&originHeight=82&originWidth=80&size=967&status=done&style=none&width=80" alt="image.png"></p>
<ul>
<li>卷积核的<strong>选取</strong>：最开始的卷积核是由人为选取的，例如上面的斜向下的卷积核，在后来的是机器学习根据自己的数据来<strong>反向调节</strong>卷积核，一幅图片往往不是一个卷积核。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619748999926-112218f7-de09-4d82-93e1-e03c2ba41f5a.png#align=left&display=inline&height=313&margin=%5Bobject%20Object%5D&name=image.png&originHeight=313&originWidth=496&size=219643&status=done&style=none&width=496" alt="image.png"></p>
<h3 id="卷积运算"><a href="#卷积运算" class="headerlink" title="卷积运算"></a>卷积运算</h3><p><strong>将卷积核放到被测图像上面对应元素相乘然后相加，所得的和放到中间（内积运算）</strong></p>
<ul>
<li>计算第一个元素</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619703523006-af118a2e-dba3-478b-9281-f811a186abae.png#align=left&display=inline&height=247&margin=%5Bobject%20Object%5D&name=image.png&originHeight=247&originWidth=516&size=92160&status=done&style=none&width=516" alt="image.png"></p>
<ul>
<li>计算第二个元素</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619703539634-d00f2e8f-160d-4cdc-b6ec-236e4aca9d65.png#align=left&display=inline&height=260&margin=%5Bobject%20Object%5D&name=image.png&originHeight=260&originWidth=516&size=94180&status=done&style=none&width=516" alt="image.png"></p>
<ul>
<li>……重复操作</li>
</ul>
<h3 id="卷积的意义"><a href="#卷积的意义" class="headerlink" title="卷积的意义"></a>卷积的意义</h3><p>由于卷积核为斜向下的直线，因此提取的特征也是斜向的直线，做完卷积运算的特征图，对应位置<strong>数值大的说明符合该特征</strong>。</p>
<h2 id="池化和激活"><a href="#池化和激活" class="headerlink" title="池化和激活"></a>池化和激活</h2><ul>
<li>池化的作用：将卷积提取的特征图有特征的部分放大，没特征的舍弃，减小计算量。</li>
<li>池化方法：最大池化法（将方块中最大的数提取出来重组特征图）</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619748489300-59398bab-fdf8-46b4-8898-92df1aac20be.png#align=left&display=inline&height=166&margin=%5Bobject%20Object%5D&name=image.png&originHeight=166&originWidth=379&size=31574&status=done&style=none&width=379" alt="image.png"></p>
<blockquote>
<p><strong>池化完成后要进行——激活</strong></p>
</blockquote>
<ul>
<li>激活函数：以Sigmoid函数为例</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619748663613-41159a94-9d8f-42a9-8838-0b5aeb7c5c14.png#align=left&display=inline&height=169&margin=%5Bobject%20Object%5D&name=image.png&originHeight=169&originWidth=391&size=30899&status=done&style=none&width=391" alt="image.png"></p>
<h3 id="激活的意义"><a href="#激活的意义" class="headerlink" title="激活的意义"></a>激活的意义</h3><p>将提取的特征图进行归一化运算，数字越接近1就越满足卷积核的特性。一方面减少数据量，另一方面方便识别。</p>
<h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><h3 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h3><p>在实际的图像处理中，往往数据量大，而且一张图片（彩色的）往往被分为RGB三个维度（也有其他分类方式），这样的图像往往需要相应维度的卷积核来精确的提取特征，而且如果图像复杂，往往利用多个卷积核来提取，而对于比较大的图像，一次池化之后可能数据量依然很大，因此就有了<strong>多次卷积+多次池化</strong>的方法来处理图像。</p>
<blockquote>
<p>简单的总结一下：<br>N维图像-&gt;N维卷积核提取（每个维度分别对应做内积）<br>M个卷积核-&gt;M个特征图<br>二次卷积时：M个特征图-&gt;M维卷积核提取</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619749319140-a84aef96-ab64-4f61-bf87-5475dd3c2af9.png#align=left&display=inline&height=539&margin=%5Bobject%20Object%5D&name=image.png&originHeight=539&originWidth=728&size=146671&status=done&style=none&width=728" alt="image.png"></p>
<h3 id="卷积神经网络全貌"><a href="#卷积神经网络全貌" class="headerlink" title="卷积神经网络全貌"></a>卷积神经网络全貌</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619749979676-ff6c7496-e4be-462a-9764-0e053d0bc8e0.png#align=left&display=inline&height=924&margin=%5Bobject%20Object%5D&name=image.png&originHeight=924&originWidth=1777&size=1410928&status=done&style=none&width=1777" alt="image.png"></p>
<h2 id="数据和算力"><a href="#数据和算力" class="headerlink" title="数据和算力"></a>数据和算力</h2><p>卷积核在运算时只有加法和乘法，一个800<em>600的彩色图像要有800</em>600*3=1440000个数据，他要进行一个卷积运算要有1300万次乘法和1200万次加法。这样庞大的数据量一般很难用cpu实时处理，主流使用gpu（显卡）来进行运算。</p>
<blockquote>
<p>CPU：中央处理器，通用性强，并行能力弱，主要用于控制。<br>GPU：图形处理器，专用性强，并行能力强，主要用于运算。<br>NPU：神经网络处理器，专用性更强，并行能力更强，每个Cube可以同时进行数据的加法和乘法（华为的升腾910可以计算16<em>16</em>16个数据的内积）。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>强大的芯片为越来越复杂的人工智能算法提供了惊人的算力，我们生活中的相机也可以做到实时美颜，人工智能这种通用技术极大的改变了我们的生活，AI芯片作为人工智能领域的根技术，芯片发展算力的提升可以推动更多领域的发展例如无人驾驶等等。</p>
]]></content>
      <categories>
        <category>笔记篇</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>CNN</tag>
      </tags>
  </entry>
  <entry>
    <title>一文详解BJT、MOSFET、IGBT器件的区别</title>
    <url>/2020/11/26/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3BJT%E3%80%81MOSFET%E3%80%81IGBT%E5%99%A8%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近经常看一些mosfet的器件结构，分析信号模型，突然要用到三极管，由于思维有点惯性了，突然不会分析了，就想着花一点时间整理一下他们的区别，顺便加入IGBT，正好也加深一下对他们的理解。</p>
<h2 id="三者关系"><a href="#三者关系" class="headerlink" title="三者关系"></a>三者关系</h2><p>要搞清楚IGBT、BJT、MOSFET之间的关系，就必须对这三者的内部结构和工作原理有大致的了解。概括的的来说，BJT是流控型器件、MOSFET是压控型器件、而IGBT≈BJT+MOSFET</p>
<h2 id="BJT"><a href="#BJT" class="headerlink" title="BJT"></a>BJT</h2><p>双极性即意味着器件内部有<strong>空穴和电子</strong>两种载流子参与导电，BJT既然叫双极性晶体管，那其内部也必然有空穴和载流子，理解这两种载流子的运动是理解BJT工作原理的关键。</p>
<h3 id="结构特点"><a href="#结构特点" class="headerlink" title="结构特点"></a>结构特点</h3><p>图中e区（发射极）、b区（基极）、c区（集电极）</p>
<ul>
<li>发射极掺杂 &gt; 集电极掺杂&gt;基区掺杂</li>
<li>基区厚度很薄一般在几微米，掺杂浓度最低</li>
<li>集电区面积最大，掺杂浓度略低于发射区</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619416984830-b0d54be4-5978-4c23-92a8-52f687455afb.png#height=207&id=hjXbj&margin=%5Bobject%20Object%5D&name=image.png&originHeight=368&originWidth=779&originalType=binary&size=50409&status=done&style=none&width=438" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619402691618-2846b41b-0622-4c98-ae1b-5e491e0aabc7.png#height=189&id=i8c0Y&margin=%5Bobject%20Object%5D&name=image.png&originHeight=342&originWidth=736&originalType=binary&size=16187&status=done&style=none&width=406" alt="image.png"></p>
<h3 id="工作原理（NPN）"><a href="#工作原理（NPN）" class="headerlink" title="工作原理（NPN）"></a>工作原理（NPN）</h3><ul>
<li>发射区：发射载流子</li>
<li>集电区：收集载流子</li>
<li>基区：传输和控制载流子</li>
</ul>
<p>三极管的放大作用：依靠发射极电流能够通过基区传输，然后到达集电极而实现的。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619403294792-d8fb60c7-d15d-4da7-8094-128f03d4e3b4.png#height=343&id=tLjOI&margin=%5Bobject%20Object%5D&name=image.png&originHeight=630&originWidth=649&originalType=binary&size=129591&status=done&style=none&width=353" alt="image.png"></p>
<h3 id="工作状态"><a href="#工作状态" class="headerlink" title="工作状态"></a>工作状态</h3><p>双极性晶体管有四种工作状态：<strong>饱和区</strong>、<strong>放大区</strong>、<strong>截止区</strong>、<strong>反向放大区</strong>（不常用）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619403456538-f5e374af-1ce1-4977-9e51-e7bd51246ec6.png#height=264&id=iaUxy&originHeight=264&originWidth=331&originalType=binary&size=0&status=done&style=none&width=331"></p>
<ul>
<li>放大区：发射结正偏，集电结反偏。VCE&gt;1V（硅管），iC基本平行于vCE轴的区域</li>
<li>饱和区：发射结正偏，集电结正偏或反偏电压很小。VCE≈0.3V（硅管)，UCE&lt;UBE，βIB&gt;IC。</li>
<li>截止区：发射结反偏，集电结反偏。IB≈0，IC=ICEO≈0</li>
</ul>
<h3 id="三种组态"><a href="#三种组态" class="headerlink" title="三种组态"></a>三种组态</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619403847601-956178cd-3085-4f90-8ebe-9e6cf648a31b.png#height=227&id=KHC8w&margin=%5Bobject%20Object%5D&name=image.png&originHeight=312&originWidth=635&originalType=binary&size=158017&status=done&style=none&width=462" alt="image.png"></p>
<h3 id="放大系数"><a href="#放大系数" class="headerlink" title="放大系数"></a>放大系数</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619404866041-f7d2b5dc-8a4f-4a2d-ad27-a56dc416ddb3.png#height=254&id=xZeCl&margin=%5Bobject%20Object%5D&name=image.png&originHeight=313&originWidth=596&originalType=binary&size=127700&status=done&style=none&width=484" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619404875960-a56db505-167e-4440-91d1-2ebc678a0f01.png#height=241&id=irOo8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=325&originWidth=640&originalType=binary&size=106262&status=done&style=none&width=475" alt="image.png"></p>
<h3 id="极限参数"><a href="#极限参数" class="headerlink" title="极限参数"></a>极限参数</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619404655641-e42810a8-bcb1-498a-a4d4-277677f83a0f.png#height=393&id=fBOKl&margin=%5Bobject%20Object%5D&name=image.png&originHeight=642&originWidth=683&originalType=binary&size=240781&status=done&style=none&width=418" alt="image.png"></p>
<h2 id="MOSFET"><a href="#MOSFET" class="headerlink" title="MOSFET"></a>MOSFET</h2><p>金属-氧化物半导体场效应晶体管，简称金属半场效应晶体管（Metal-Oxide-Semiconductor Field-Effect Transistor, MOSFET），是一种可以广泛使用在模拟电路与数字电路的场效应管。金属栅极与沟道之间有一层二氧化硅绝缘层，因此具有很高的输入电阻（最高可达1015Ω）。MOS场效应管分为N沟道和P沟道，通常将衬底（基板）与源极接在一起。</p>
<h3 id="结构特点-1"><a href="#结构特点-1" class="headerlink" title="结构特点"></a>结构特点</h3><p>MOSFET 的种类：<br>按导电沟道可分为： <strong>P 沟道和 N 沟道</strong>。<br>按栅极电压幅值可分为：</p>
<ul>
<li><strong>耗尽型</strong>：当栅极电压为零时漏源极之间就存在导电沟道，</li>
<li><strong>增强型</strong>：对于 N（P）沟道器件，栅极电压大于（小于）零时才存在导电沟道。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619417028243-4fe145f4-6920-49d6-ac17-345281469643.png#height=247&id=RQX96&margin=%5Bobject%20Object%5D&name=image.png&originHeight=322&originWidth=819&originalType=binary&size=230075&status=done&style=none&width=629" alt="image.png"></p>
<h3 id="工作原理（nMOS）"><a href="#工作原理（nMOS）" class="headerlink" title="工作原理（nMOS）"></a>工作原理（nMOS）</h3><ul>
<li>电极D（Drain）：称为漏极，相当于双极性三极管的集电极。</li>
<li>电极G（Gate）：称为栅极，相当于三极管中的基极。</li>
<li>电极S（Source）：称为源极，相当于三极管中的发射极。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619417053537-c533d60a-deb6-480d-a565-aa57ca8e7a29.png#height=267&id=cOQEL&margin=%5Bobject%20Object%5D&name=image.png&originHeight=405&originWidth=1153&originalType=binary&size=348141&status=done&style=none&width=760" alt="image.png"></p>
<ul>
<li>VGS=0时，图a没有形成沟道，即使有VDS，ID≈0</li>
<li>VGS&gt;0时，图b栅极和衬底被SiO2绝缘形成电场排斥空穴、留下受主，形成耗尽层。但是VGS数值较小没有沟道，在VGS&lt;Vth的时候管子一直处于截止状态。</li>
<li>VGS&gt;Vth时，图c形成导电沟道，加上VDS，产生漏极电流。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619417075038-64dd2709-d45c-46b5-9ff3-65782306447a.png#height=286&id=yfO80&margin=%5Bobject%20Object%5D&name=image.png&originHeight=413&originWidth=1097&originalType=binary&size=391800&status=done&style=none&width=759" alt="image.png"></p>
<ul>
<li>图a当VGS&gt;Vth且为确定值，VDS变化会影响ID，类似于结型场效应管。此时VGD=VGS-VDS。（可变电阻区）</li>
<li>图b随着VDS增大，漏端出现预夹断，此时VGD=VGS-VDS=Vth。</li>
<li>图c再继续增大VDS，夹断点往源极移动，此时ID几乎VDS不受影响，管子进入饱和区，ID由VGS决定。（饱和区）</li>
</ul>
<h3 id="工作状态-1"><a href="#工作状态-1" class="headerlink" title="工作状态"></a>工作状态</h3><p>MOSFET有三个工作区：<strong>可变电阻区</strong>、<strong>饱和区（放大区</strong>）、<strong>截止区、击穿区（不常用）</strong>。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619417103617-c8acbc0a-1246-4388-bbcd-84c0beb57a1f.png#height=289&id=rYJwH&margin=%5Bobject%20Object%5D&name=image.png&originHeight=429&originWidth=900&originalType=binary&size=392716&status=done&style=none&width=606" alt="image.png"></p>
<ul>
<li>可变电阻区（也称非饱和区）：VGS&gt;Vth，且VDS&lt;VGS-Vth，当栅极电压VGS一定时，Id与Vds成线性关系，表现为电阻特性，因此称<strong>为欧姆区</strong>。该区域Vds值较小，沟道电阻基本上仅受VGS控制。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619412577554-210425e4-ae1d-4664-82c7-01c7427078b7.png#height=56&id=IANJS&margin=%5Bobject%20Object%5D&name=image.png&originHeight=56&originWidth=358&originalType=binary&size=5377&status=done&style=none&width=358" alt="image.png"></p>
<ul>
<li>饱和区（也称恒流区、放大区、有源区）：VGS&gt;Vth，且VDS&gt;(VGS-Vth)，此时处于夹断之后，当VGS一定时，漏极电流ID几乎不随漏源电压VDS变化（<strong>漏极电流Id饱和</strong>），电流主要由VGS控制。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619412590919-9c67123f-153c-48dd-a15a-cf1b2557a70f.png#height=54&id=BHFgX&margin=%5Bobject%20Object%5D&name=image.png&originHeight=54&originWidth=427&originalType=binary&size=6288&status=done&style=none&width=427" alt="image.png"></p>
<ul>
<li>截止区（也称夹断区）：VGS&lt;Vth，管子沟道被夹断，漏极电流ID≈0，管子不工作。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619412560496-2b31e3cf-afc6-468c-ac78-8ea6e349494e.png#height=51&id=r9FIU&margin=%5Bobject%20Object%5D&name=image.png&originHeight=51&originWidth=187&originalType=binary&size=2515&status=done&style=none&width=187" alt="image.png"></p>
<h4 id="MOSFET和三极管导通区别"><a href="#MOSFET和三极管导通区别" class="headerlink" title="MOSFET和三极管导通区别"></a>MOSFET和三极管导通区别</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619417123279-38fd2f52-a014-4c05-91b8-31ac5f9886ea.png#height=362&id=Ner7m&margin=%5Bobject%20Object%5D&name=image.png&originHeight=534&originWidth=858&originalType=binary&size=318872&status=done&style=none&width=581" alt="image.png"></p>
<h4 id="MOSFET特性比较"><a href="#MOSFET特性比较" class="headerlink" title="MOSFET特性比较"></a>MOSFET特性比较</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619417150544-f76e5b3e-c3df-4494-8615-789a414689d6.png#height=366&id=fYdUy&margin=%5Bobject%20Object%5D&name=image.png&originHeight=629&originWidth=1240&originalType=binary&size=451127&status=done&style=none&width=721" alt="image.png"></p>
<h3 id="三种组态-1"><a href="#三种组态-1" class="headerlink" title="三种组态"></a>三种组态</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619417179303-35470c7a-8584-4395-982a-cdcbf97b63b9.png#height=582&id=CeFS1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=836&originWidth=948&originalType=binary&size=238687&status=done&style=none&width=660" alt="image.png"></p>
<h2 id="IGBT"><a href="#IGBT" class="headerlink" title="IGBT"></a>IGBT</h2><p>IGBT(Insulated Gate Bipolar Transistor)，绝缘栅双极型晶体管是由BJT(双极型三极管)和MOS(绝缘栅型场效应管)组成的复合全控型电压驱动式功率半导体器件， 兼有MOSFET的高输入阻抗和GTR的低导通压降两方面的优点。GTR饱和压降低，载流密度大，但驱动电流较大；MOSFET驱动功率很小，开关速度快，但导通压降大，载流密度小，IGBT没有放大电压的功能，导通时可以看做导线，断开时当做开路。<br>IGBT综合了以上两种器件的优点，驱动功率小而饱和压降低。非常适合应用于直流电压为600V及以上的变流系统如交流电机、变频器、开关电源、照明电路、牵引传动等领域。</p>
<h3 id="结构特点（n-IGBT）"><a href="#结构特点（n-IGBT）" class="headerlink" title="结构特点（n-IGBT）"></a>结构特点（n-IGBT）</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619414678233-0f27ef54-0b35-4f68-bb67-08e5cf059ce8.png#height=337&id=qv0NI&margin=%5Bobject%20Object%5D&name=image.png&originHeight=439&originWidth=876&originalType=binary&size=93873&status=done&style=none&width=672" alt="image.png"></p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>IGBT 的开关作用是通过加正向栅极电压形成沟道，给厚基区PNP 晶体管提供基极电流，使IGBT 导通。反之，加反向门极电压消除沟道，流过反向基极电流，使IGBT 关断。IGBT 的驱动方法和 MOSFET 基本相同，只需控制输入极N 沟道MOSFET，所以具有高输入阻抗特性。<br>当MOSFET 的沟道形成后，从P+基极注入到N 一层的空穴（少子），对N 一层进行电导调制，减小N一层的电阻，使IGBT 在高电压时，也具有低的通态电流。</p>
<h3 id="工作状态-2"><a href="#工作状态-2" class="headerlink" title="工作状态"></a>工作状态</h3><p>IGBT常用的有两种状态：<strong>导通、截止</strong><br>按照等效电路图分析</p>
<ul>
<li>导通：IGBT的栅极及发射极加上正电压导通，晶体管两极(集电极、基极)会形成低阻状态，</li>
<li>截止：当IGBT的两极无电压，则MOSFET就会停止导通，晶体管得不到电流供给则晶体管随之停止导通</li>
</ul>
<h3 id="极限参数-1"><a href="#极限参数-1" class="headerlink" title="极限参数"></a>极限参数</h3><p>IGBT 的安全可靠与否主要由以下因素决定：</p>
<ul>
<li>IGBT 栅极与发射极之间的电压;</li>
<li>IGBT 集电极与发射极之间的电压;</li>
<li>流过IGBT 集电极－发射极的电流;</li>
<li>IGBT 的结温。</li>
</ul>
<p>如果IGBT 栅极与发射极之间的电压,即驱动电压过低,则IGBT<strong>不能稳定正常地工作。</strong><br>如果过高超过栅极－发射极之间的耐压则IGBT 可能永久性损坏;<br>如果加在IGBT 集电极与发射极允许的电压超过集电极—发射极之间的耐压,<br>流过IGBT 集电极—发射极的电流超过集电极—发射极允许的最大电流,<br>IGBT 的结温超其结温的允许值,IGBT 都可能会<strong>永久性损坏</strong>。</p>
<h2 id="三者区别"><a href="#三者区别" class="headerlink" title="三者区别"></a>三者区别</h2><table>
<thead>
<tr>
<th>特性</th>
<th>BJT</th>
<th>MOSFET</th>
<th>IGBT</th>
</tr>
</thead>
<tbody><tr>
<td>驱动方法</td>
<td>电流</td>
<td>电压</td>
<td>电压</td>
</tr>
<tr>
<td>驱动电路</td>
<td>复杂</td>
<td>简单</td>
<td>简单</td>
</tr>
<tr>
<td>输入阻抗</td>
<td>低</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>驱动功率</td>
<td>高</td>
<td>低</td>
<td>低</td>
</tr>
<tr>
<td>开关速度</td>
<td>慢（us）</td>
<td>快（ns）</td>
<td>中</td>
</tr>
<tr>
<td>开关频率</td>
<td>低</td>
<td>快（小于1MHz）</td>
<td>中</td>
</tr>
<tr>
<td>安全工作区</td>
<td>窄</td>
<td>宽</td>
<td>宽</td>
</tr>
<tr>
<td>饱和电压</td>
<td>低</td>
<td>高</td>
<td>低</td>
</tr>
</tbody></table>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.zhihu.com/question/50486540">三极管，MOSFET, IGBT的区别？</a><br><a href="https://zhuanlan.zhihu.com/p/46469449">深入理解三极管（BJT）的工作原理</a><br><a href="https://zhuanlan.zhihu.com/p/248368565">《学习笔记》–MOSFET工作原理</a></p>
]]></content>
      <categories>
        <category>笔记篇</category>
        <category>器件</category>
      </categories>
      <tags>
        <tag>器件</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Cadence设计反相器</title>
    <url>/2020/10/11/%E4%BD%BF%E7%94%A8Cadence%E8%AE%BE%E8%AE%A1%E5%8F%8D%E7%9B%B8%E5%99%A8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>刚入坑模拟，先拿个小项目练练手，环境直接使用的chris的，将虚拟机镜像直接导入自己的电脑就能直接使用，资料下载查看参考目录，另外后来发现了一位大神的笔记也在参考目录中分享他的博客。</p>
<h2 id="预备工作"><a href="#预备工作" class="headerlink" title="预备工作"></a>预备工作</h2><ul>
<li>启动软件<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source RFIC.cshrc  //进入工作路径</span><br><span class="line">pwd            //查看当前工作路径</span><br><span class="line">icfb           //启动软件</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li> 绑定工艺库</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1618038666143-06703c63-dbbb-4360-be1f-42467c2718b9.png#align=left&display=inline&height=375&id=YcSkS&margin=%5Bobject%20Object%5D&name=image.png&originHeight=820&originWidth=591&size=228023&status=done&style=none&width=270" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1618038729692-898123b9-fbcd-46da-a74b-cb6b49dc21f1.png#align=left&display=inline&height=379&id=nH8Pd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=675&originWidth=672&size=135286&status=done&style=none&width=377" alt="image.png"></p>
<h2 id="电路设计"><a href="#电路设计" class="headerlink" title="电路设计"></a>电路设计</h2><h3 id="原理图设计"><a href="#原理图设计" class="headerlink" title="原理图设计"></a>原理图设计</h3><ul>
<li>在RFIC_sim元件库中新建一个电路原理图，输入名称INV</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1618038941148-b3e2611f-19c3-40a8-aca1-c9acbfcf5a31.png#align=left&display=inline&height=235&id=vDoRT&margin=%5Bobject%20Object%5D&name=image.png&originHeight=446&originWidth=546&size=56494&status=done&style=none&width=288" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1618039055825-4d8c7d25-1203-4022-9273-66c5260910d9.png#align=left&display=inline&height=221&id=nOWLb&margin=%5Bobject%20Object%5D&name=image.png&originHeight=347&originWidth=423&size=46863&status=done&style=none&width=270" alt="image.png"></p>
<ul>
<li>调入工艺库中的其他元器件</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1618039228867-0f994119-6f4a-4265-b039-a6ccc582d236.png#align=left&display=inline&height=537&id=yQrt5&margin=%5Bobject%20Object%5D&name=image.png&originHeight=537&originWidth=1219&size=131147&status=done&style=none&width=1219" alt="image.png"></p>
<ul>
<li>连接好电路后根据设计值更改各个元器件的参数</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1618041658888-84239d80-ead7-4021-ba97-c91df456db9c.png#align=left&display=inline&height=339&id=xZaiM&margin=%5Bobject%20Object%5D&name=image.png&originHeight=524&originWidth=499&size=40329&status=done&style=none&width=323" alt="image.png"></p>
<ul>
<li>设计完之后保存原理图，打开create菜单，之后依次选择cellview，from cellview，不需要修改。生成可调用元件</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1618041805782-bd888b1b-1504-4f37-b702-36f31e79a0ed.png#align=left&display=inline&height=214&id=pxmsY&margin=%5Bobject%20Object%5D&name=image.png&originHeight=432&originWidth=1006&size=37180&status=done&style=none&width=498" alt="image.png"></p>
<h3 id="仿真电路设计"><a href="#仿真电路设计" class="headerlink" title="仿真电路设计"></a>仿真电路设计</h3><ul>
<li>建立仿真使用的testbench（步骤同新建原理图几乎一样，名字为INV_testbench），导入元件，并仿真参数。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1618042897890-debec77f-6a47-4d3e-8c29-72135db0c9f4.png#align=left&display=inline&height=578&id=AWwVE&margin=%5Bobject%20Object%5D&name=image.png&originHeight=578&originWidth=984&size=71147&status=done&style=none&width=984" alt="image.png"></p>
<ul>
<li>输入相应的仿真环境、变量、仿真模型等参数，开始进行直流仿真</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1618043176203-eb071dc6-414c-4b08-a0db-b55356fc1262.png#align=left&display=inline&height=374&id=aZ6Sj&margin=%5Bobject%20Object%5D&name=image.png&originHeight=604&originWidth=926&size=123731&status=done&style=none&width=573" alt="image.png"></p>
<ul>
<li>分析仿真结果，利用波形查看器，查看节点信号</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1618045091335-931d6c49-2349-4633-90e9-84e87de44fbb.png#align=left&display=inline&height=362&id=HdOsI&margin=%5Bobject%20Object%5D&name=image.png&originHeight=701&originWidth=1146&size=101368&status=done&style=none&width=592" alt="image.png"></p>
<h3 id="版图设计"><a href="#版图设计" class="headerlink" title="版图设计"></a>版图设计</h3><ul>
<li>打开电路原理图，工具生成layout XL版图，并根据器件的结构绘制相应的版图</li>
<li>在原理图中选中要绘制的器件后，在版图界面生成（从原理图中），再用快捷键shift+F显示全部内容（ctrl+F隐藏）</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1618058529303-bdd53511-82a5-4410-adb3-d367c7ffcf75.png#align=left&display=inline&height=680&id=GovVV&margin=%5Bobject%20Object%5D&name=image.png&originHeight=680&originWidth=481&size=266303&status=done&style=none&width=481" alt="image.png"></p>
<h2 id="calibr验证"><a href="#calibr验证" class="headerlink" title="calibr验证"></a>calibr验证</h2><ul>
<li>打开版图文件，运行DRC</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1618057582478-9ea088f7-9e78-4e43-9636-412174464d58.png#align=left&display=inline&height=468&id=dinV8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=677&originWidth=961&size=124413&status=done&style=none&width=664" alt="image.png"></p>
<ul>
<li>改正DRC错误</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1618057898908-0737b935-6e8a-4560-b898-6065de09b9cc.png#align=left&display=inline&height=579&id=Yz7L2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=820&originWidth=972&size=173499&status=done&style=none&width=686" alt="image.png"></p>
<ul>
<li>运行LVS</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1618059060311-f394bd14-7ff7-4268-8625-a0146640c3d5.png#align=left&display=inline&height=524&id=SJc6h&margin=%5Bobject%20Object%5D&name=image.png&originHeight=825&originWidth=956&size=101940&status=done&style=none&width=607" alt="image.png"></p>
<ul>
<li>提取寄生参数，实现后仿真，Run PEX，注意避免多次提取寄生参数</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1618059167238-0a5ddbd5-4c66-4dd9-82d3-831210f563f0.png#align=left&display=inline&height=548&id=T2E5k&margin=%5Bobject%20Object%5D&name=image.png&originHeight=822&originWidth=981&size=105767&status=done&style=none&width=654" alt="image.png"></p>
<h2 id="电路的后仿真"><a href="#电路的后仿真" class="headerlink" title="电路的后仿真"></a>电路的后仿真</h2><ul>
<li>在提取完寄生参数之后，打开原理图，再环境中添加调用calibre，使用后来的模型进行仿真(方法一)</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1618059775777-7745e4ba-b04c-4fbd-8398-c2ebf08346fc.png#align=left&display=inline&height=889&id=hpbKO&margin=%5Bobject%20Object%5D&name=image.png&originHeight=889&originWidth=1224&size=260360&status=done&style=none&width=1224" alt="image.png"></p>
<ul>
<li>再testbench中新建config，配置其调用calibre模型，并进行仿真，步骤和前仿真相同(方法二)</li>
</ul>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ul>
<li>由于某种不知名的原因，导致软件闪退，但好像他自己有保护机制，再次打开的时候，只能以可读模式打开<ul>
<li>解决方法：找到对应库的路径，将文件夹中的.cdslck后缀文件删除即可，版图、电路图分别对应不同的文件夹，其中打不开那个图就去删除哪个锁定文件</li>
</ul>
</li>
<li>栅格捕捉问题<ul>
<li>解决方法：将display中的size全部改小</li>
</ul>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV1s4411g7QV?p=2">模拟IC设计实践入门</a><br><a href="https://ke.qq.com/course/407641?taid=3490210684221529">资料下载</a><br><a href="https://blog.csdn.net/qq_32174665/article/details/108429022">cadence IC617中工艺库的安装</a><br><a href="http://blog.leanote.com/post/lilin5819/virtuoso%E5%B7%A5%E8%89%BA%E5%BA%93CDB%E8%BD%ACOA%E6%A0%BC%E5%BC%8F">virtuoso工艺库CDB转OA格式</a><br><a href="https://www.yuque.com/attachments/yuque/0/2021/pdf/12924220/1619351378047-f826fcbc-15dd-429b-9a4a-5278e503d1d4.pdf?_lake_card=%7B%22uid%22:%221619351371880-0%22,%22src%22:%22https://www.yuque.com/attachments/yuque/0/2021/pdf/12924220/1619351378047-f826fcbc-15dd-429b-9a4a-5278e503d1d4.pdf%22,%22name%22:%22Cadence%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B.pdf%22,%22size%22:7198061,%22type%22:%22application/pdf%22,%22ext%22:%22pdf%22,%22progress%22:%7B%22percent%22:99%7D,%22status%22:%22done%22,%22percent%22:0,%22id%22:%22rCE3p%22,%22card%22:%22file%22%7D">Cadence入门教程.pdf</a></p>
<p><a href="https://ccbirds.github.io/ICnotes1/">集成电路学习笔记（一）IC617工艺库安装</a><br><a href="https://ccbirds.github.io/ICnotes21/">集成电路学习笔记（二）基于IC617反相器设计之原理图绘制</a><br><a href="https://ccbirds.github.io/ICnotes22/">集成电路学习笔记（二）基于IC617反相器设计之ADE仿真</a><br><a href="https://ccbirds.github.io/ICnotes23/">集成电路设计学习笔记（二）基于IC617反相器设计之layout</a><br><a href="https://ccbirds.github.io/ICnotes3/">集成电路学习笔记（三）基于IC617的直流分析</a><br><a href="https://ccbirds.github.io/ICnotes4/">集成电路设计学习笔记（四）基于IC617的交流小信号分析</a><br><a href="https://ccbirds.github.io/ICnotes51/">集成电路设计学习笔记（五）基于IC617的以二极管连接的mos作负载的共源极放大器</a><br><a href="https://ccbirds.github.io/ICnotes52/">集成电路设计学习笔记（五）基于IC617的电流源负载的共源极放大器</a><br><a href="https://ccbirds.github.io/ICnotes54/">集成电路设计笔记（五）基于IC617带源极负反馈的共源级的放大器</a><br><a href="https://ccbirds.github.io/ICnotes55/">集成电路设计笔记（五）基于IC617共漏极放大器</a><br><a href="https://ccbirds.github.io/ICnotes6/">集成电路设计笔记（六）基于IC617设计运算放大器</a><br><a href="https://ccbirds.github.io/ICnotes7/">集成电路设计笔记（七）基于IC617UVLO设计</a></p>
]]></content>
      <categories>
        <category>项目篇</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Cadence</tag>
        <tag>虚拟机</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>小六壬预测快速上手</title>
    <url>/2020/09/22/%E5%B0%8F%E5%85%AD%E5%A3%AC%E9%A2%84%E6%B5%8B%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们以前看的电视上那些聪明人掐指一算，惊叹不已，其实，起卦是一件非常容易地事，入门的有小六壬、梅花易数，其实操作起来都是简单的加加减减。天下掐指算法很多，不过基本上都是用时间来计算。今天介绍的小六壬时课又叫诸葛马前课，其算法是月份加日子加时辰。哦对了，不保证一定可以能算的准，但是对于选择困难症来说，也许是一种福音。</p>
<h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><p><strong>不急不占</strong>，<strong>无事不占</strong>，<strong>不动不占</strong>。<br>入卦：按<strong>阴历</strong>算，<strong>顺时针</strong>向，从<strong>大安</strong>起，<strong>月上起日</strong>，<strong>日上起时</strong>。<br>占时应按地方时辰。即“北京时间”以东经120度为准，西移1度，减去4分钟，经度相差15度时，地方时相差1个小时。如武汉相差23分钟，成都相差64分钟。若不换算，推算结果就不准确。</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="简单算法"><a href="#简单算法" class="headerlink" title="简单算法"></a>简单算法</h3><p>小六壬预测方法十分简单，预测时只须提取当时的月、日、时信息，用左拇指在六个掌诀位上按顺时针方向依次掐算即知结果。其法以大安起正月，<strong>月上起日，日上起时</strong>。注意：这句话意思就是从月上开始计算日子，从日上开始计算时辰。如：占三月初五辰时吉凶。大安起数，三（月）是速喜，速喜起日（开始计算日子），五是大安。大安起时（开始计算时辰），辰时是小吉。</p>
<ul>
<li>第一步，先确定月份在掌诀上的起点(定位)，以起点推算月份落点。不管是第几个月，均以“大安”为正月起点，然后按顺时针在六个掌诀定位上按六神次序依次往下数。</li>
<li>第二步，以月份落(终)点为日辰起点，然后推算日辰落点。从月份落点上起初一，同样按顺时针在六个掌诀定位上按六神顺序依次柱下数，一直数到天数为止，此掌诀定位即为日辰之落点。</li>
<li>第三步，以日辰落点为时辰起点，推算时辰落点。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619002405248-e8ba84a7-a0a7-4f27-9539-416a802be50f.png#align=left&display=inline&height=515&id=ueccded20&margin=%5Bobject%20Object%5D&name=image.png&originHeight=836&originWidth=446&size=431142&status=done&style=none&width=274.9895935058594" alt="image.png"></p>
<blockquote>
<p>举例：<br>如你农历2010年六月初五上午九点半。要和男朋友（女友）初次相会，可以算一下吉凶如何。<br>前面说了凡事都从大安起卦，大安为一月，留连为二月，速喜为三月，赤口为四月，小吉为五月，空亡为六月；下面再算日子，月份算到空亡了，接着日子从空亡开始，空亡是初一，大安是初二，留连初三，速喜初四，赤口初五；同理接着时辰算，赤口是子时，小吉是丑时，空亡是寅时，大安是卯时，留连是辰时，速喜是巳时（9：00-11：00）。所以最终得了个速喜卦。是好事，可能一见钟情。</p>
</blockquote>
<h3 id="算法补充"><a href="#算法补充" class="headerlink" title="算法补充"></a>算法补充</h3><blockquote>
<p>以今天农历八月十七日辰时为例。</p>
</blockquote>
<p>(一)首先照上图<strong>顺时针</strong>方向由大安开始计为正月，则留连便是二月，如此类推，八月就是<strong>留连</strong>了。<br>(二)再由八月这个留连开始计为初一，速喜为初二，如此类推，十七日就是<strong>空亡</strong>了。<br>(三)由十七日这个空亡开始计为子时，大安就是丑时，如此类推，顺时针数下去，辰时就落在<strong>赤口</strong>上了。<br>(四)如果使用月日时法起课，那<strong>月上起日之宫位</strong>为空亡，<strong>日上起时之宫位</strong>为赤口，根据两个宫位断结果。<br><strong>时辰次序与换算</strong><br>子 11:00am-01:00am (1)     午 11:00am-01:00pm (7)<br>丑 01:00am-03:00am (2)     未 01:00pm-03:00pm (8)<br>寅 03:00am-05:00am (3)     申 03:00pm-05:00pm (9)<br>卯 05:00am-07:00am (4)     酉 05:00pm-07:00pm (10)<br>辰 07:00am-09:00am (5)     戌 07:00pm-09:00pm (11)<br>巳 09:00am-11:00am (6)     亥 09:00pm-11:00pm (12)</p>
<h2 id="解说"><a href="#解说" class="headerlink" title="解说"></a>解说</h2><h3 id="大安"><a href="#大安" class="headerlink" title="大安"></a>大安</h3><blockquote>
<p>身未动时，属木青龙．谋事一五七，贵人西南，冲犯东方，大人青面阴神，小孩婆祖六畜惊。</p>
</blockquote>
<p>解曰：<strong>大安事事昌，求财在坤方，失物去不远，宅舍保安康，行人身未动，病者主无妨，将军回田野，仔细更推详</strong>。</p>
<h4 id="日加时断语"><a href="#日加时断语" class="headerlink" title="日加时断语"></a>日加时断语</h4><p>大安加留连，办事不周全，失物西北去，婚姻晚几天。<br>大安加速喜，事事自己起，失物当日见，婚姻自己提。<br>大安加赤口，办事不顺手，失物不用找，婚姻两分手。<br>大安加小吉，事事从己及，失物不出门，婚姻成就地。<br>大安加空亡，病人要上床，失物无踪影，事事不顺情。</p>
<h4 id="玥沣解"><a href="#玥沣解" class="headerlink" title="玥沣解"></a>玥沣解</h4><p>卜到大安，属吉卦，凡事都可以得到安康，但是此为静卦，宜静不宜动。<br>问运势：目前运势还不错，有稳定成长的情况，但不宜躁进。<br>问财富：求财可，但是目前不宜扩张，只能够守住旧业。<br>问感情：若为女子问则好，感情顺遂。若为男子问则较差，感情虽稳，但是以无新鲜感，会出现点小问题。<br>问事业：目前工作稳定，可得上司赏识，但切勿锋芒太露。<br>问身体：身体没有大病，但须注意病由口入，或因过度操劳而得病。<br>问神鬼：大安为解灾之神，鬼神之事问题不大，若是小孩为自身惊吓所致，若是大人则为冲犯东方之煞神或犯土煞。<br>问行人：人平安，但目前不愿与自身连络。</p>
<h3 id="留连"><a href="#留连" class="headerlink" title="留连"></a>留连</h3><blockquote>
<p>卒未归时，属水元武，谋事二八十，贵人南方，冲犯北方，大人乌面夫人，小孩游路亡魂。</p>
</blockquote>
<p>解曰：<strong>留连事难成，求谋日未明，官事凡宜缓，去者未回程，失物南方见，急讨方心称，更须防口舌，人口且平平。</strong></p>
<h4 id="日加时断语-1"><a href="#日加时断语-1" class="headerlink" title="日加时断语"></a>日加时断语</h4><p>留连加大安，办事两分张，婚姻有喜事，先苦后来甜。<br>留连加速喜，事事由自己，婚姻有成意，失物三天里。<br>留连加赤口，病者死人口，失物准丢失，婚姻两分手。<br>留连加小吉，事事不用提，失物东南去，病者出人齐。<br>留连加空亡，病人准死亡，失物不见面，婚姻两分张。</p>
<h4 id="玥沣解-1"><a href="#玥沣解-1" class="headerlink" title="玥沣解"></a>玥沣解</h4><p>卜到留连，属凶卦，代表凡事阻碍、迟滞，此卦更不宜有过大动作，凡事宜守。<br>问运势：目前运势低迷，心情不开朗，凡事受阻。<br>问财富：求财不可得，此为破财之卦，且有被人影响破财之现象。<br>问感情：双方沟通不良、冷战、或者一方过于强势，感情不得平衡。<br>问事业：被上司盯或者被人扯后腿，小人之卦。<br>问身体：肠胃不舒服或者精神压力太大所得之病。<br>问神鬼：小孩子主要被过路游魂所煞到，大人为冲犯女性鬼神。<br>问行人：人平安，但目前仍流连忘返。</p>
<h3 id="速喜"><a href="#速喜" class="headerlink" title="速喜"></a>速喜</h3><blockquote>
<p>人便至时，属火未雀，谋事三六九，贵人西南，冲犯南方，大心火箭将军，小孩婆祖动物惊。</p>
</blockquote>
<p>解曰：<strong>速喜喜来临，求财向南行，失物申未午，逢人路上寻，官事有福德，病者无祸侵，田宅六畜吉，行人有信音。</strong></p>
<h4 id="日加时断语-2"><a href="#日加时断语-2" class="headerlink" title="日加时断语"></a>日加时断语</h4><p>速喜加赤口，自己往外走，失物往正北，婚姻得勤走。<br>速喜加小吉，婚姻有人提，病人当天好，时物在家里。<br>速喜加空亡，婚姻有分张，病者积极治，失物不久见。<br>速喜加大安，事事都平安，姻姻成全了，占病都相安。<br>速喜加留连，婚姻不可言，失物无信息，病人有仙缘。</p>
<h4 id="玥沣解-2"><a href="#玥沣解-2" class="headerlink" title="玥沣解"></a>玥沣解</h4><p>卜到速喜为吉卦，代表凡事皆有喜讯，而且很快就会到来。<br>问运势：目前运势渐开，要积极的行动就可以如愿。<br>问财富：求财可得，但有先破财而后得财或者先得财后破财之兆，若得到钱财就必须赶快脱身。<br>问感情：若是刚开始的感情，则为热恋。若是已经持续一段时间，则为口舌。<br>问事业：工作得利，但须注意文件上的疏失。<br>问身体：心脏、血液循环有问题或者头部、脑压的问题，但是问题不大。<br>问神鬼：小孩子被动物吓到或者被女性阴神冲犯，大人为冲犯男性鬼神。<br>问行人：人已经快到了。</p>
<h3 id="赤口"><a href="#赤口" class="headerlink" title="赤口"></a>赤口</h3><blockquote>
<p>官事凶时，属金白虎，谋事四七十，贵人东方，冲犯西方，大人金神七煞，小孩迷魂童子。</p>
</blockquote>
<p>解曰：<strong>赤口主口舌，官非切宜防，失物速速讨，行人有惊慌，六畜多作怪，病者出西方，更须防咀咒，诚恐染瘟</strong></p>
<h4 id="日加时断语-3"><a href="#日加时断语-3" class="headerlink" title="日加时断语"></a>日加时断语</h4><p>赤口加小吉，办事自己提，婚姻不能成，失物无信息。<br>赤口加空亡，无病也上床，失物不用找，婚姻不能成。<br>赤口加大安，办事险和难，失物东北找，婚姻指定难。<br>赤口加留连，办事有困难，行人在外走，失物不回还。<br>赤口加速喜，婚姻在自己，失物有着落，办事官事起。</p>
<h4 id="玥沣解-3"><a href="#玥沣解-3" class="headerlink" title="玥沣解"></a>玥沣解</h4><p>卜到赤口为凶卦，代表运势多舛，而且诸多纷争亦有口舌之祸。<br>问运势：目前运势不明，若有大计划就要赶快实施、不要拖延，则可成功。若卜小事则不成。<br>问财富：大起大落之财，求财不易。<br>问感情：感情纷争多，或女方身体有疾病。<br>问事业：若为武职或者粗重行业则顺，若为文职则不顺。<br>问身体：胸口、支气管，或者有血光之灾，且赤口也有流行疾病的意义。<br>问神鬼：犯到择日凶神，或者被人诅咒索害。<br>问行人：所问之人目前有困难或者有事情纠缠。</p>
<h3 id="小吉"><a href="#小吉" class="headerlink" title="小吉"></a>小吉</h3><blockquote>
<p>人来喜时，属水六合，谋事一五七，贵人西南，冲犯东方，大人无主家神，小孩婆祖六畜惊。</p>
</blockquote>
<p>解曰：<strong>小吉最吉昌，路上好商量，阴人来报喜，失物在坤方，行人即便至，交关甚是强，凡事皆和合，病者叩穹苍。</strong></p>
<h4 id="日加时断语-4"><a href="#日加时断语-4" class="headerlink" title="日加时断语"></a>日加时断语</h4><p>小吉加空亡，病人不妥当，失物正东找，婚姻再想想。<br>小吉加大安，事事两周全，婚姻当日定，失物自己损。<br>小吉加留连，事事有反还，婚姻有人破，失物上西南。<br>小吉加速喜，事事从头起，婚姻能成就，失物在院里。<br>小吉加赤口，办事往外走，婚姻有难处，失物丢了手。</p>
<h4 id="玥沣解-4"><a href="#玥沣解-4" class="headerlink" title="玥沣解"></a>玥沣解</h4><p>卜到小吉为吉卦，代表凡事皆吉，但是不如大安的安稳也不如速喜快速，而是介于两者中间。<br>问运势：目前运势不错，保持目前状况就会越来越好。<br>问财富：求财可得，而且有因人得财之兆。<br>问感情：若没有感情，则可因他人介绍而得。若有感情，则恋情顺利。<br>问事业：工作不错，但须注意处理公司财务之事，以及与下属沟通之事。<br>问身体：肝胆之疾病和消化系统，但是问题不大。<br>问神鬼：小孩子被动物吓到或者被女性阴神冲犯，大人为冲犯家中祖先。<br>问行人：人已经快到了。</p>
<h3 id="空亡"><a href="#空亡" class="headerlink" title="空亡"></a>空亡</h3><blockquote>
<p>音信稀时，属土勾陈，主事三六九，贵人北方，冲犯厝地，大人土压夫人，小孩土瘟神煞。</p>
</blockquote>
<p>解曰：<strong>空亡事不详，阴人多乖张，求财无利益，行人有灾殃，失物寻不见，官事有刑伤，病人逢暗鬼，解禳保安康。</strong></p>
<h4 id="日加时断语-5"><a href="#日加时断语-5" class="headerlink" title="日加时断语"></a>日加时断语</h4><p>空亡加大安，事事不周全，婚姻从和好，失物反复间。<br>空亡加留连，办事处处难，婚姻重新定，失物永不还。<br>空亡加速喜，事事怨自己，婚姻有一定，失物在家里。<br>空亡加赤口，办事官非有，婚姻难定准，失物往远走。<br>空亡加小吉，事事有猜疑，婚姻有喜事，失物回家里。</p>
<h4 id="玥沣解-5"><a href="#玥沣解-5" class="headerlink" title="玥沣解"></a>玥沣解</h4><p>卜到空亡为凶卦，代表凡事秽暗不明，内心不安，运途起伏。<br>问运势：目前运势不佳，自身拿不定主意，无所适从，可多听取他人之意见，切莫随意就做判断。<br>问财富：求财难得，保守为要。<br>问感情：双方争执多，且有因他人问题或者介入而争执之事。<br>问事业：工作失利，容易被人陷害或者暗中耳语，或者因他人问题而让自己工作失利。<br>问身体：脾胃出毛病，或者神经系统出问题，也有因灵界而生病之兆。<br>问神鬼：家中阳宅或者阴宅出问题，导致冲犯。<br>问行人：人在途中遇到困难或灾厄而难到。</p>
<h2 id="上宫掌诀"><a href="#上宫掌诀" class="headerlink" title="上宫掌诀"></a>上宫掌诀</h2><p>除上述所示口诀外，另有上宫掌诀合用：<br>子午日在大安，曰：子午皇恩并大赦。<br>丑未日在留连，曰：丑未双熊入青室。<br>寅申日在速喜，曰：寅申登程催之马。<br>卯酉日在赤口，曰：卯酉麻绳自缠身。<br>辰戌日在小吉，曰：辰戌披枷自带锁。<br>巳亥日在空亡，曰：巳亥宫中半折明。</p>
<h2 id="八卦方位图"><a href="#八卦方位图" class="headerlink" title="八卦方位图"></a>八卦方位图</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619699870624-77ddc0f0-65b9-406b-8916-5c0cfd2a8d07.png#align=left&display=inline&height=913&margin=%5Bobject%20Object%5D&name=image.png&originHeight=913&originWidth=935&size=138967&status=done&style=none&width=935" alt="image.png"></p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li><strong>遇事即刻起卦，无事勿占，凡事只占一次，再占不验</strong>。</li>
<li>同样一件事，也可以以临时起卦，如上个事件，也可以按在接到朋友之约时的具体时间起卦。但同一个事件，只能算一次，比如按接约时算了，就不能再按约会的时间算了。</li>
<li>任何占卜都不是绝对准的，大的方向对就算准了。一般来说，平时生活中能算对个总事件的8成。如被盗了，算出了能否找到罪犯、人数、方向、破案时间，但没算对追回来的数额，这也算是成功了。</li>
<li>冥冥中藏有玄机，所以对于六壬等掐指一算不能心中大不敬，否则不妙。</li>
</ol>
]]></content>
      <categories>
        <category>杂学篇</category>
      </categories>
      <tags>
        <tag>占卜</tag>
      </tags>
  </entry>
  <entry>
    <title>Spice语法基础入门</title>
    <url>/2020/09/21/Spice%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>由于现在需要找实习，还啥也不会呢，不知道咋地就对模拟有点感兴趣，就去图书馆借了本模拟集成电路的书，看了一两章，感觉东西不少于是想整理下来，虽然现在常用的SPICE仿真软件都有很好的GUI界面例如Cadence，在用仿真库中的元器件连成原理图后就可以进行仿真（当然要设置必要的仿真参数），但实际上只是用原理图自动产生了SPICE的格式语句，还是要通过读取语句来进行仿真，这是历史的遗留问题。<br>在spice早期研究的技术条件下，无法用图形方式输入电路结构，只能通过文本文件来描述，也就是所谓网表。SPICE软件的设计者规范了要进行仿真的电路对应的SPICE网表文件格式，还定义了许多仿真描述语句和分析控制语句等，使仿真软件能通过读取这些特殊信息来进行相关计算和运行，最后获得要求的结果。<br>因为技术的进步，虽然现在已经不需要手工书写并输入网表了，但了解一些基本语句还是很有用的，不仅可以理解仿真时要设置的那些参数的含义，而且在出错时还易于通过网表来排错。</p>
<h1 id="SPICE仿真软件基础"><a href="#SPICE仿真软件基础" class="headerlink" title="SPICE仿真软件基础"></a>SPICE仿真软件基础</h1><blockquote>
<p>SPICE网表文件是文本文件，默认的输入文件名为：*_.cir_</p>
</blockquote>
<p>因为目前各个版本的SPICE软件都已图形化，并增加了很多功能，所以产生的语句顺序和格式有了一些变化，但主要是以*开头的注释语句的不同变化，便于阅读和模块化，而基本的语句变化不大，包括以下几种：</p>
<ul>
<li><p><strong>标题语句：</strong>网表文件第一行为标题语句，由任意字符串和字母组成，软件并不处理，而是直接在输出文件中作为第一行打印出来</p>
</li>
<li><p><strong>注释语句：</strong>由*开头的字符串，为文件的说明部分，为方便阅读而在自动产生的SPICE网表文件中大量存在</p>
</li>
<li><p><strong>电路描述语句：</strong>定义电路拓扑结构和元器件参数的语句，由元器件描述语句、模型描述语句、电源语句等组成</p>
</li>
<li><p><strong>电路特性分析和控制语句：</strong>以.开头的语句，描述要分析的电路特性及控制命令</p>
</li>
<li><p><strong>结束语句：</strong>即.END ，标志电路描述语句的结束，在文件最后一行（最后将会给出SPICE网表文件的例子）</p>
<h2 id="电路描述语句："><a href="#电路描述语句：" class="headerlink" title="电路描述语句："></a>电路描述语句：</h2><p>是SPICE网表文件中最多也最复杂的，有以下一些规定：</p>
</li>
<li><p><strong>名称：为字符串，只有前8个字符有效，其中第一个字符必须为A–Z的字符，且有固定含义，对应不同类型的元件。</strong></p>
<table>
<thead>
<tr>
<th>符号</th>
<th>元件名</th>
<th>符号</th>
<th>Table</th>
<th>符号</th>
<th>Cool</th>
<th>符号</th>
<th>Cool</th>
</tr>
</thead>
<tbody><tr>
<td>B</td>
<td>GaAs场效应晶体管</td>
<td>C</td>
<td>电容</td>
<td>D</td>
<td>二极管</td>
<td>X</td>
<td>子电路</td>
</tr>
<tr>
<td>E</td>
<td>电压控制电压源</td>
<td>F</td>
<td>电流控制电压源</td>
<td>G</td>
<td>电压控制电流源</td>
<td>H</td>
<td>电流控制电压源</td>
</tr>
<tr>
<td>I</td>
<td>独立电流源</td>
<td>J</td>
<td>结型场效应晶体管</td>
<td>K</td>
<td>互感和磁芯</td>
<td>L</td>
<td>电感</td>
</tr>
<tr>
<td>M</td>
<td>MOS场效应晶体管</td>
<td>Q</td>
<td>双极性晶体管</td>
<td>R</td>
<td>电阻</td>
<td>S</td>
<td>电压控制开关</td>
</tr>
<tr>
<td>T</td>
<td>传输线</td>
<td>U</td>
<td>数字电路器件</td>
<td>V</td>
<td>独立电压源</td>
<td>W</td>
<td>电流控制开关</td>
</tr>
</tbody></table>
</li>
<li><p><strong>数字：有几种形式，整数、浮点数、整数或浮点数加上整数指数、浮点数或整数后面加上比例因子,常用的比例因子：有T、G、MEG、K、M、U、N、P、F、MIL等，不分大小写</strong></p>
<table>
<thead>
<tr>
<th>T=10E12</th>
<th>G=10E9</th>
<th>MEG=10E6</th>
<th>K=10E3</th>
<th>MIL=25.4E-6</th>
</tr>
</thead>
<tbody><tr>
<td>M=10E-3</td>
<td>U=10E-6</td>
<td>N=10E-9</td>
<td>P=10E-12</td>
<td>F=10E-15</td>
</tr>
</tbody></table>
</li>
<li><p><strong>分隔符：有空格、逗号、等号、左括号、右括号等</strong></p>
</li>
<li><p><strong>续行号：“+”，一行最多只能有80字符，如一行无法表达完全，可在第二行起始加+号，表示是前一行的继续</strong></p>
</li>
<li><p><strong>单位：使用国际标准单位制，语句中缺省</strong></p>
</li>
<li><p><strong>规定支路电流的正方向和支路电压的正方向一致</strong></p>
</li>
<li><p><strong>节点编号：可以是任意的数字或字符串，节点0规定为地，不允许有悬浮的节点，即每个节点对0节点都必须有直流的通路。当实际电路不满足这个要求时，可在悬浮节点与地之间接一个大电阻（如1G）</strong></p>
</li>
<li><p><strong>不能分析的问题：电压源回路、电感回路、电压源和电感组成的回路、隔断的电流源和（或）电容</strong></p>
<h3 id="无源元件描述语句"><a href="#无源元件描述语句" class="headerlink" title="无源元件描述语句"></a>无源元件描述语句</h3><h4 id="电阻描述语句"><a href="#电阻描述语句" class="headerlink" title="电阻描述语句"></a>电阻描述语句</h4></li>
</ul>
<p><strong>RXXXXXXX N+ N- &lt;(MODEL)NAME&gt; VALUE &lt;TC=TC1&gt;</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  RXXXXXXX        //元件名称</span><br><span class="line">  N+ N-           //电阻两端的节点号，当电阻上加正电压时，电流从N+流向N-</span><br><span class="line">  (MODEL)NAME     //可选项，指出电阻将用上后面由.MODEL语句定义的模型</span><br><span class="line">  VALUE           //电阻值，单位Ohm</span><br><span class="line">  TC=&quot;TC1&quot; &lt;TC2&gt;  //可选的温度系数，TC1 TC2分别是一阶、二阶温度系数</span><br><span class="line">       </span><br><span class="line">电阻的温度公式：VALUE(T)=RR0[1+TC1(T-T0)+TC2*(T-T0)*(T-T0)]</span><br><span class="line">  //R0为电阻描述语句中的阻值，T0为常温300K</span><br><span class="line">			</span><br><span class="line">电阻模型语句：      </span><br><span class="line">	.MODEL MNAME RES R=”PVAL1” &lt;TC1=PVAL2&gt; &lt;TC2=PVAL3&gt; &lt;TCE=PVAL4&gt;</span><br><span class="line">     //RES为电阻模型关键字，R定义电阻倍乘系数，TCE定义指数温度系数</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>例句：</strong>R4 0 3 RMOD 100<br>.MODEL RMOD RES(R=2 TC1=0.1 TC2=0.01)</p>
</blockquote>
<h4 id="电容电感描述语句"><a href="#电容电感描述语句" class="headerlink" title="电容电感描述语句"></a>电容电感描述语句</h4><p><strong>CXXXXXXX N+ N- &lt;(MODEL)NAME&gt; VALUE &lt;IC=INCOND&gt;</strong><br><strong>LXXXXXXX N+ N- &lt;(MODEL)NAME&gt; VALUE &lt;IC=INCOND&gt;</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   VALUE          //电容电感的值，不能为零</span><br><span class="line">                 //IC规定初始条件，仅在瞬态分析语句中设关键字UIC时赋值才有意义</span><br><span class="line">                      </span><br><span class="line">电容电感模型语句：</span><br><span class="line">  .MODEL MNAME CAP(C=PVAL1 VC1=PVAL2 VC2=PVAL3 TC1=PVAL4 TC2=PVAL5)</span><br><span class="line">  .MODEL MNAME IND(L=PVAL1 IL1=PVAL2 IL2=PVAL3 TC1=PVAL4 TC2=PVAL5)</span><br><span class="line">    C、L            //定义电容电感的倍乘系数</span><br><span class="line">    VC1、VC2        //分别是电容的一阶、二阶电压系数</span><br><span class="line">    IL1、IL2        //分别是电感的一阶、二阶电流系数</span><br><span class="line">    TC1、TC2        //分别是电容、电感的温度系数</span><br><span class="line">         </span><br><span class="line">电容电感的求值公式：</span><br><span class="line">    C(V)=C0*C(1+VC1*V+VC2*V*V)</span><br><span class="line">    L(I)=L0*L(1+IL1*I+IL2*I*I)</span><br><span class="line">      //C0、L0分别是元件描述语句中的值</span><br><span class="line">         </span><br><span class="line">电容电感的温度公式与电阻的温度公式类似</span><br></pre></td></tr></table></figure>
<h4 id="互感描述语句"><a href="#互感描述语句" class="headerlink" title="互感描述语句"></a>互感描述语句</h4><p><strong>KXXXXXXX LYYYYYYY LZZZZZZZ … VALUE &lt;(MODEL)NAME&gt; &lt;(SIZE)VALUE&gt;</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">		KXXXXXXX、LYYYYYYY      //是两个耦合电感的名称，也可以多个耦合电感按顺序写</span><br><span class="line">    VALUE                   //为耦合系数的值，0&lt;VALUE&lt;1，耦合规则通常在每个电感的第一个节点上加&#x27;.&#x27;,作为同名端</span><br><span class="line">    (MODEL)NAME             //为模型名，指出将用上后面由.MODEL语句定义的模型</span><br><span class="line">    (SIZE)VALUE             //用来定义磁芯的截面积的大小，缺省值为1</span><br><span class="line">    </span><br><span class="line">磁芯的模型语句：</span><br><span class="line">   .MODEL MNAME CORE AREA=”PVAL1” PATH=”PVAL2” GAP=”PVAL3” PACK=”PVAL4” MS=…</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>磁芯模型关键字</th>
<th>磁芯模型关键字</th>
<th>单位</th>
<th>缺省值</th>
</tr>
</thead>
<tbody><tr>
<td>AREA</td>
<td>平均磁通横截面积</td>
<td>cm2</td>
<td>0.1</td>
</tr>
<tr>
<td>PATH</td>
<td>平均磁路长度</td>
<td>cm</td>
<td>1</td>
</tr>
<tr>
<td>GAP</td>
<td>有效气隙长度</td>
<td>cm</td>
<td>0</td>
</tr>
<tr>
<td>PACK</td>
<td>叠层系数</td>
<td>-</td>
<td>1</td>
</tr>
<tr>
<td>MS</td>
<td>磁饱和电流</td>
<td>A/m</td>
<td>1.00E+06</td>
</tr>
<tr>
<td>ALPHA</td>
<td>平均磁场系数</td>
<td>-</td>
<td>1.00E-03</td>
</tr>
<tr>
<td>A</td>
<td>形状参数</td>
<td>A/m</td>
<td>1.00E+03</td>
</tr>
<tr>
<td>C</td>
<td>磁畴壁的挠曲常数</td>
<td>-</td>
<td>0.2</td>
</tr>
<tr>
<td>K</td>
<td>磁畴壁的销连常数</td>
<td>-</td>
<td>500</td>
</tr>
</tbody></table>
<h4 id="无损传输线描述语句"><a href="#无损传输线描述语句" class="headerlink" title="无损传输线描述语句"></a>无损传输线描述语句</h4><p><strong>TXXXXXXX N1 N2 N3 N4 Z0-VALUE &lt;TD=VALUE&gt; &lt;F=FREQ &lt;NL=NRMLEN&gt;&gt;+&lt;IC=V1,I1,V2,I2&gt;</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">N1、N2         //端口1的正负节点</span><br><span class="line">N3、N4         //端口2的正负节点</span><br><span class="line">Z0             //特性阻抗</span><br><span class="line">TD             //传输延迟，频率F及在频率F时相对于传输波长的归一化电学长度NL可用来确定延迟，两种表示方式要选一种</span><br><span class="line">IC             //确定每个端口的电压和电流，只在瞬态分析中用到（加UIC时）</span><br></pre></td></tr></table></figure>
<h4 id="电压控制开关描述语句"><a href="#电压控制开关描述语句" class="headerlink" title="电压控制开关描述语句"></a>电压控制开关描述语句</h4><p><strong>SXXXXXXX N+ N- NC+ NC- &lt;(MODEL)NAME&gt;</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  N+ N-         //分别是开关的正负节点</span><br><span class="line">  NC+ NC-       //分别是控制端的正负节点</span><br><span class="line">  (MODEL)NAME   //模型名，指出将用后面由.MODEL语句定义的模型</span><br><span class="line">    </span><br><span class="line">电压控制开关模型语句：</span><br><span class="line">  .MODEL NAME VSWITCH RON=”PVAL1” ROFF=”PVAL2” VON=”PVAL3” VOFF=”PVAL4”</span><br><span class="line">    VSWITCH     //压控开关模型的关键字</span><br><span class="line">    RON         //定义开关的导通电阻，缺省为1欧姆</span><br><span class="line">    ROFF        //定义开关的关断电阻，缺省为1兆欧姆</span><br><span class="line">    VON         //定义开关导通的阈值电压</span><br><span class="line">    VOFF        //定义开关关断的阈值电压</span><br></pre></td></tr></table></figure>
<h4 id="电流控制开关的描述语句"><a href="#电流控制开关的描述语句" class="headerlink" title="电流控制开关的描述语句"></a>电流控制开关的描述语句</h4><p><strong>WXXXXXXX N+ N- VNAME &lt;(MODEL)NAME&gt;</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  N+ N-         //分别是开关的正负节点</span><br><span class="line">  VNAME         //是控制电流流过的电压源的名称</span><br><span class="line">  (MODEL)NAME   //模型名，指出将用上后面由.MODEL语句定义的模型</span><br><span class="line">    </span><br><span class="line">电流控制开关模型语句：</span><br><span class="line">  .MODEL ISMOD ISWITCH RON=”PVAL1” ROFF=”PVAL2” ION=”PVAL3” IOFF=”PVAL4”</span><br><span class="line">    //ISWITCH为流控开关模型的关键字</span><br><span class="line">    //ION为导通的阈值电流</span><br><span class="line">    //IOFF为关断的阈值电流</span><br></pre></td></tr></table></figure>
<h3 id="有源元件描述语句"><a href="#有源元件描述语句" class="headerlink" title="有源元件描述语句"></a>有源元件描述语句</h3><h4 id="二极管描述语句"><a href="#二极管描述语句" class="headerlink" title="二极管描述语句"></a>二极管描述语句</h4><p><strong>DXXXXXXX N+ N- MNAME   &lt;IC=VD&gt;</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  N+ N-         //为二极管的正负节点</span><br><span class="line">  MNAME         //为二极管的模型名，为必选项</span><br><span class="line">  AREA          //为面积因子</span><br><span class="line">  OFF           //为直流分析时的初始条件</span><br><span class="line">  IC=           //&quot;VD为瞬态分析时的初始条件&quot;</span><br><span class="line">    </span><br><span class="line">二极管的模型语句：</span><br><span class="line">  .MODEL MNAME D(PNAME1=PVAL1 PNAME2=PVAL2 ...)</span><br><span class="line">    //D为二极管模型的关键字，后面为二极管参数序列，一般二极管模型参数有15--25个</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>半导体二极管参数表（其中带*的受面积参数影响）</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>符号</td>
<td>名称</td>
<td>默认值</td>
<td>典型值</td>
<td>单位</td>
</tr>
<tr>
<td>IS</td>
<td>饱和电流*</td>
<td>1.00E-14</td>
<td>1.00E-14</td>
<td>A</td>
</tr>
<tr>
<td>RS</td>
<td>寄生串联电阻*</td>
<td>0</td>
<td>10</td>
<td>ohm</td>
</tr>
<tr>
<td>N</td>
<td>发射系数</td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>TT</td>
<td>渡越时间</td>
<td>0</td>
<td>0.1</td>
<td>ns</td>
</tr>
<tr>
<td>CJO</td>
<td>零偏PN结电容</td>
<td>0</td>
<td>2</td>
<td>pF</td>
</tr>
<tr>
<td>VJ</td>
<td>PN结电势</td>
<td>1</td>
<td>0.6</td>
<td>V</td>
</tr>
<tr>
<td>M</td>
<td>PN结梯度因子</td>
<td>0.5</td>
<td>0.5</td>
<td></td>
</tr>
<tr>
<td>EG</td>
<td>禁带宽度</td>
<td>1.11</td>
<td>1.11</td>
<td>eV</td>
</tr>
<tr>
<td>XT1</td>
<td>IS的温度系数</td>
<td>3</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>KF</td>
<td>闪烁噪声系数</td>
<td>0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>AF</td>
<td>闪烁噪声指数</td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>FC</td>
<td>正偏耗尽层电容系数</td>
<td>0.5</td>
<td></td>
<td></td>
</tr>
<tr>
<td>BV</td>
<td>反向击穿电压</td>
<td>无穷大</td>
<td>50</td>
<td>V</td>
</tr>
<tr>
<td>IBV</td>
<td>反向击穿电流*</td>
<td>1.00E-10</td>
<td></td>
<td>A</td>
</tr>
</tbody></table>
<h4 id="双极型晶体管描述语句"><a href="#双极型晶体管描述语句" class="headerlink" title="双极型晶体管描述语句"></a>双极型晶体管描述语句</h4><p><strong>QXXXXXXX NC NB NE  MNAME   &lt;IC=VBE,VCE&gt;</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">		NC NB NE NS			//分别是双极型晶体管的集电极、基极、发射极以及衬底所在节点，NS缺省表示衬底接地</span><br><span class="line">    MNAME						//为双极型晶体管的模型名，为必选项</span><br><span class="line">    AREA						//为面积因子</span><br><span class="line">    OFF							//为直流分析时初始条件</span><br><span class="line">    IC=&quot;VBE&quot; 				//VBE、 VCE为瞬态分析时初始条件</span><br><span class="line">    </span><br><span class="line">双极型晶体管模型语句：</span><br><span class="line">		.MODEL MNAME NPN(OR PNP) (PNAME=PVAL1 PNAME=&quot;PVAL2&quot; ...)</span><br><span class="line">      //双极型晶体管模型有两种类型，NPN PNP分别为其模型关键字，后面为参数序列，一般双极型晶体管模型参数有40多个</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>双极型晶体管模型的参数表(带*的受面积参数影响)</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>符号</td>
<td>名称</td>
<td>默认值</td>
<td>典型值</td>
<td>单位</td>
</tr>
<tr>
<td>IS</td>
<td>饱和电流*</td>
<td>1.00E-16</td>
<td></td>
<td></td>
</tr>
<tr>
<td>BF</td>
<td>理想最大正向电流放大系数</td>
<td>100</td>
<td>100</td>
<td></td>
</tr>
<tr>
<td>NF</td>
<td>发射系数</td>
<td>1</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>VAF（VA）</td>
<td>正向BTEA电压</td>
<td>无穷大</td>
<td>100</td>
<td>V</td>
</tr>
<tr>
<td>IKF（IK）</td>
<td>正向BTEA大电流下降点，正向膝点电流</td>
<td>无穷大</td>
<td>1.00E-02</td>
<td>A</td>
</tr>
<tr>
<td>ISE（C2）</td>
<td>基极-发射极漏饱和电流</td>
<td>0</td>
<td>1000</td>
<td>A</td>
</tr>
<tr>
<td>NE</td>
<td>基极-发射极漏发射系数</td>
<td>1.5</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>BR</td>
<td>理想最大反向电流放大系数</td>
<td>1</td>
<td>0.1</td>
<td></td>
</tr>
<tr>
<td>NR</td>
<td>反向电流发射系数</td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>VAR（VB）</td>
<td>反向ERALY电压</td>
<td>无穷大</td>
<td>100</td>
<td>V</td>
</tr>
<tr>
<td>IKR</td>
<td>反向BETA大电流下降点，正向膝点电流*</td>
<td>无穷大</td>
<td>0.1</td>
<td>A</td>
</tr>
<tr>
<td>ISC（C4）</td>
<td>基极-集电极漏饱和电流</td>
<td>0</td>
<td>1</td>
<td>A</td>
</tr>
<tr>
<td>NC</td>
<td>基极-集电极漏发射系数</td>
<td>2</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>RB</td>
<td>零偏基极电阻*</td>
<td>0</td>
<td>100</td>
<td>ohm</td>
</tr>
<tr>
<td>RBM</td>
<td>大电流时最小基极电阻</td>
<td>RB</td>
<td>100</td>
<td>ohm</td>
</tr>
<tr>
<td>IRB</td>
<td>基极电阻下降为Rb-Rbmin/2时的电流</td>
<td>无穷大</td>
<td></td>
<td>A</td>
</tr>
<tr>
<td>RE</td>
<td>发射极电阻*</td>
<td>0</td>
<td>1</td>
<td>ohm</td>
</tr>
<tr>
<td>RC</td>
<td>集电极电阻*</td>
<td>0</td>
<td>10</td>
<td>ohm</td>
</tr>
<tr>
<td>CJE</td>
<td>零偏集电极PV结电容*</td>
<td>0</td>
<td>2</td>
<td>pF</td>
</tr>
<tr>
<td>VJE</td>
<td>发射结内建电势</td>
<td>0.75</td>
<td>0.7</td>
<td>V</td>
</tr>
<tr>
<td>MJE（ME）</td>
<td>发射结梯度因子</td>
<td>0.33</td>
<td>0.33</td>
<td></td>
</tr>
<tr>
<td>CJC</td>
<td>零偏集电极PN结电容*</td>
<td>0</td>
<td>1</td>
<td>pF</td>
</tr>
<tr>
<td>VJC（PC)</td>
<td>集电结内建电势</td>
<td>0.75</td>
<td>0.5</td>
<td>V</td>
</tr>
<tr>
<td>MJC（MC）</td>
<td>集电结梯度因子</td>
<td>0.33</td>
<td>0.33</td>
<td></td>
</tr>
<tr>
<td>XCJC</td>
<td>Cbc与Rb内连接部分</td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>CJS（CCS）</td>
<td>零偏集电极-衬底PN结电容</td>
<td>0</td>
<td>2</td>
<td>pF</td>
</tr>
<tr>
<td>VJS（PS）</td>
<td>衬底结内建电势</td>
<td>0.75</td>
<td></td>
<td>V</td>
</tr>
<tr>
<td>MJS（MS）</td>
<td>衬底结梯度因子</td>
<td>0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>FC</td>
<td>正偏势垒电容参数</td>
<td>0.5</td>
<td></td>
<td></td>
</tr>
<tr>
<td>TF</td>
<td>理想正向渡越时间（tf）</td>
<td>0</td>
<td>0.1</td>
<td>s</td>
</tr>
<tr>
<td>XTF</td>
<td>tf随偏置变化系数</td>
<td>0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>VTF</td>
<td>tf随偏置Vbe变化的电压参数</td>
<td>无穷大</td>
<td></td>
<td>V</td>
</tr>
<tr>
<td>ITF</td>
<td>影响tf的大电流参数</td>
<td>0</td>
<td></td>
<td>A</td>
</tr>
<tr>
<td>PTF</td>
<td>在1/（2PIt）Hz时的超前相移</td>
<td>0</td>
<td>PI/6</td>
<td>RAD</td>
</tr>
<tr>
<td>TR</td>
<td>反向渡越时间</td>
<td>0</td>
<td>10</td>
<td>ns</td>
</tr>
<tr>
<td>EG</td>
<td>禁带宽度</td>
<td>1.11</td>
<td>1.11</td>
<td>eV</td>
</tr>
<tr>
<td>XTB</td>
<td>BR、BF的温度系数</td>
<td>0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>XT1（PT）</td>
<td>IS的温度效应指数</td>
<td>3</td>
<td></td>
<td></td>
</tr>
<tr>
<td>KF</td>
<td>闪烁噪声系数</td>
<td>0</td>
<td>6.60E-16</td>
<td></td>
</tr>
<tr>
<td>AF</td>
<td>闪烁噪声指数</td>
<td>1</td>
<td>1</td>
<td></td>
</tr>
</tbody></table>
<h4 id="MOS场效应晶体管描述语句"><a href="#MOS场效应晶体管描述语句" class="headerlink" title="MOS场效应晶体管描述语句"></a>MOS场效应晶体管描述语句</h4><p><strong>MXXXXXXX ND NG NS NB MNAME &lt;L=VAL&gt; &lt;W=VAL&gt; &lt;AD=VAL&gt; &lt;AS=VAL&gt; &lt;PD=VAL&gt; &lt;PS=VAL&gt;+&lt;NRD=VAL&gt; &lt;NRS=VAL&gt; <OFF> &lt;IC=VDS,VGS,VBS&gt;</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  ND NG NS NB     //分别是MOS场效应晶体管的漏极、栅极、源极和衬底所在的节点</span><br><span class="line">  MNAME           //MOS场效应晶体管的模型名，为必选项</span><br><span class="line">  L W             //分别是MOS场效应晶体管沟道的长、宽</span><br><span class="line">  AD AS           //为漏极和源极的扩散区的面积</span><br><span class="line">  PD PS           //为漏极和源极的周长</span><br><span class="line">  NRD NRS         //为漏极和源极扩散区等效电阻的方块数</span><br><span class="line">  OFF             //为直流分析时初始条件</span><br><span class="line">  IC              //为瞬态分析时初始条件</span><br><span class="line"></span><br><span class="line">MOS场效应晶体管模型语句：</span><br><span class="line">  .MODEL MNAME NMOS(OR PMOS) (PNAME=PVAL1 PNAME=&quot;PVAL2&quot; ...)</span><br><span class="line">    //MOS场效应晶体管模型有两种类型，NMOS PMOS分别为其模型关键字</span><br><span class="line">    //后面为参数序列，一般模型参数有40--60个，大多为工艺参数</span><br><span class="line">    //MOS场效应晶体管模型有四个级别，用语句LEVEL来指定，缺省时LEVEL=1</span><br><span class="line">         LEVEL=&quot;1&quot;     Shichman-Hadges模型</span><br><span class="line">         LEVEL=&quot;2&quot;     基于几何图形的一种二维分析模型</span><br><span class="line">         LEVEL=&quot;3&quot;     半经验短沟道模型</span><br><span class="line">         LEVEL=&quot;4&quot;     亚微米BSIM模型</span><br><span class="line">    //因MOS场效应晶体管模型的参数较多（40--60个）而且较复杂，很多与制造工艺有关</span><br><span class="line">    涉及太多微电子的知识，就不再列出了</span><br><span class="line">    *系统级使用时一般使用相关制造厂商或第三方提供的模型参数*</span><br></pre></td></tr></table></figure>
<h4 id="结型场效应晶体管描述语句"><a href="#结型场效应晶体管描述语句" class="headerlink" title="结型场效应晶体管描述语句"></a>结型场效应晶体管描述语句</h4><p><strong>JXXXXXXX ND NG NS MNAME <AREA> <OFF> &lt;IC=VDS,VGS&gt;</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  ND NG NS       //分别是结型场效应晶体管的漏极、栅极、源极所在的节点</span><br><span class="line">  MNAME          //为结型场效应晶体管的模型名，为必选项</span><br><span class="line">  AREA           //为面积因子</span><br><span class="line">  OFF            //为直流分析时初始条件</span><br><span class="line">  IC=&quot;VDS&quot;,VGS   //为瞬态分析时初始条件</span><br><span class="line"></span><br><span class="line">结型场效应晶体管模型语句：</span><br><span class="line">  .MODEL MNAME NJF(OR PJF) (PNAME=PVAL1 PNAME=&quot;PVAL2&quot; ...)</span><br><span class="line">    //结型场效应晶体管模型有两种类型，NJF PJF分别为其模型关键字，后面为参数序列，一般模型参数有20多个</span><br><span class="line">    //结型场效应晶体管模型的参数也不再列出了，一般使用相关制造厂商或第三方提供的模型参数</span><br></pre></td></tr></table></figure>
<h4 id="GaAs场效应晶体管描述语句"><a href="#GaAs场效应晶体管描述语句" class="headerlink" title="GaAs场效应晶体管描述语句"></a>GaAs场效应晶体管描述语句</h4><p><strong>BXXXXXXX ND NG NS MNAME <AREA> <OFF> &lt;IC=VDS,VGS,VBS&gt;</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  ND NG NS          //分别是GaAs场效应晶体管漏极、栅极、源极所在的节点</span><br><span class="line">  MNAME             //为结型场效应晶体管的模型名，为必选项</span><br><span class="line">  AREA              //为面积因子</span><br><span class="line">  OFF               //为直流分析时初始条件</span><br><span class="line">  IC=&quot;VDS&quot;,VGS,VBS  //为瞬态分析时初始条件</span><br><span class="line">  </span><br><span class="line">GaAs场效应晶体管模型语句：</span><br><span class="line">  .MODEL MNAME GASFET (PNAME=PVAL1 PNAME=&quot;PVAL2&quot; ...)</span><br><span class="line">    //GASFET为GaAs场效应晶体管模型的关键字，后面为参数序列，一般模型参数约30个</span><br><span class="line">    //GaAs场效应晶体管模型有三个级别，用语句LEVEL来指定，缺省时LEVEL=1</span><br><span class="line">         LEVEL=&quot;1&quot;        Curtice模型</span><br><span class="line">         LEVEL=&quot;2&quot;        Statz或Raytheon模型</span><br><span class="line">         LEVEL=&quot;3&quot;        Triquint模型</span><br><span class="line">    //GaAs场效应晶体管模型的参数也不再列出了，一般使用相关制造厂商或第三方提供的模型参数</span><br></pre></td></tr></table></figure>
<h4 id="数字电路器件描述语句"><a href="#数字电路器件描述语句" class="headerlink" title="数字电路器件描述语句"></a>数字电路器件描述语句</h4><p><strong>UXXXXXXX <NAME> <PRIMITIVE TYPE> [(<PARAMETER VALUE><em>)]+<DIGITAL POWER NODE> <DIGITAL GROUND NODE> <NODE></em><TIMING MODELNAME>+&lt;I/OMODEL NAME&gt; [MNTYMXDLY=<DELAY SELECT VALUE>]+[I/O-LEVEL=<INTERFACE SUBKET SELECT VALUE>]</strong></p>
<p><strong>UXXXXXXX &lt;STIM (WIDTH)VALUE,(FORMAT)VALUE&gt; <NODE>*&lt;(I/O)MODEL NAME&gt;+&lt;TIMESTEP=(STEPSIZE)VALUE&gt; <WAVEFORM DESCRIPTION></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">前一种表示数字电路，名称后是类型、参数值、节点、定时模型名、输入输出模型名</span><br><span class="line">      后一种表示激励波形发生器，将规定的激励加到指定的节点上</span><br><span class="line">2.6.1 子电路描述语句：以.SUBCKT作为开始，以.END作为结束的一组语句，作为以X开始的元件</span><br><span class="line">2.6.1.1 子电路定义开始语句：.SUBCKT &lt;SUBNAME&gt; N1 &lt;N2 N3 ...&gt;</span><br><span class="line">         其中：SUBNAME是子电路名称</span><br><span class="line">              N1 N2 N3等是子电路外部节点号</span><br><span class="line">2.6.1.2 子电路结束语句：.ENDS &lt;SUBNAME</span><br><span class="line">         表示结束SUBNAME子电路或结束所有子电路定义</span><br></pre></td></tr></table></figure>
<h3 id="元器件库调用语句"><a href="#元器件库调用语句" class="headerlink" title="元器件库调用语句"></a>元器件库调用语句</h3><p><strong>.LIB <filename></strong><br>    //filename为库文件名，必须带扩展名.lib，缺省名为nom.lib，列出所有库文件</p>
<h3 id="电源描述语句"><a href="#电源描述语句" class="headerlink" title="电源描述语句"></a>电源描述语句</h3><h4 id="独立电源描述语句"><a href="#独立电源描述语句" class="headerlink" title="独立电源描述语句"></a>独立电源描述语句</h4><p>独立<strong>电压源</strong>描述语句：<br><strong>VXXXXXXX N+ N- &lt;(DC)DC/TRAN VALUE&gt; &lt;AC (ACMAG (ACPHASE))&gt;</strong><br>独立<strong>电流源</strong>描述语句：<br><strong>IXXXXXXX N+ N- &lt;(DC)DC/TRAN VALUE&gt; &lt;AC (ACMAG (ACPHASE))&gt;</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//N+ N-为电源的正负节点，电流源的电流正方向为使电流从N+节点流出并流入N-节点</span><br><span class="line">//DC/TRAN VALUE指电源的直流或随时间变化的瞬时值，缺省为0</span><br></pre></td></tr></table></figure>
<p><strong>独立电源按直流、交流、瞬态源等可细分为如下几种：</strong></p>
<h5 id="直流电源"><a href="#直流电源" class="headerlink" title="直流电源"></a>直流电源</h5><p>  直流<strong>电压</strong>源：<strong>VXXXXXXX N+ N- [DC] VALUE</strong><br>  直流<strong>电流</strong>源：<strong>IXXXXXXX N+ N- [DC] VALUE</strong></p>
<h5 id="交流电源"><a href="#交流电源" class="headerlink" title="交流电源"></a>交流电源</h5><p>  交流<strong>电压</strong>源：<strong>VXXXXXXX N+ N- AC &lt;ACMEG <ACPHASE>&gt;</strong><br>  交流<strong>电流</strong>源：<strong>IXXXXXXX N+ N- AC &lt;ACMEG <ACPHASE>&gt;</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//ACMEG为正弦波幅值，缺省值为1</span><br><span class="line">//ACPHASE为正弦波的初始相位，缺省为0</span><br></pre></td></tr></table></figure>
<p><strong>瞬态电源</strong><br>  脉冲<strong>电压</strong>源：<strong>VXXXXXXX N+ N- PULSE (V1 V2 TR TF PW PER)</strong><br>  脉冲<strong>电流</strong>源：<strong>IXXXXXXX N+ N- PULSE (I1 I2 TR TF PW PER)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">V1 I1    //为起始值</span><br><span class="line">V2 I2    //为脉动值</span><br><span class="line">TD       //为延迟时间，缺省值为0</span><br><span class="line">TR       //为上升时间，缺省值为TSTEP</span><br><span class="line">TF       //为下降时间，缺省值为TSTEP</span><br><span class="line">PW       //为脉冲宽度，缺省值为TSTOP</span><br><span class="line">PER      //为周期，缺省值为TSTOP</span><br><span class="line">TSTEP TSTOP   //为瞬态分析时的步长和中止时间</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1617278101656-70d7a21a-54c3-482a-9bff-00bb2db6f98b.png#height=200&id=LGUnU&margin=%5Bobject%20Object%5D&name=image.png&originHeight=200&originWidth=321&originalType=binary&size=45844&status=done&style=none&width=321" alt="image.png"></p>
<h5 id="瞬态正弦电源"><a href="#瞬态正弦电源" class="headerlink" title="瞬态正弦电源"></a>瞬态正弦电源</h5><p>  瞬态正弦<strong>电压</strong>源：<strong>VXXXXXXX N+ N- SIN (V0 VA F TD THETA)</strong><br>  瞬态正弦<strong>电流</strong>源：<strong>IXXXXXXX N+ N- SIN (I0 IA F TD THETA)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    //V0 I0为偏置值</span><br><span class="line">    //VA IA为振幅</span><br><span class="line">    //F为频率，缺省值为1/TSTOP</span><br><span class="line">    //TD为延迟时间，缺省为0</span><br><span class="line">    //THETA为阻尼时间，缺省为0</span><br><span class="line"></span><br><span class="line">正弦曲线表达式：</span><br><span class="line">  V(T)=V0+VA*SIN(2*PI*(F*(T-TD)+PHASE/360))*EXP(-(T-TD)*THETA)</span><br><span class="line">  I(T)=I0+IA*SIN(2*PI*(F*(T-TD)+PHASE/360))*EXP(-(T-TD)*THETA)</span><br></pre></td></tr></table></figure>
<h5 id="瞬态指数电源"><a href="#瞬态指数电源" class="headerlink" title="瞬态指数电源"></a>瞬态指数电源</h5><p>  瞬态指数<strong>电压</strong>源：<strong>VXXXXXXX N+ N- EXP(V1 V2 TD1 TAU1 TD2 TAU2)</strong><br>  瞬态指数<strong>电流</strong>源：<strong>IXXXXXXX N+ N- EXP(I1 I2 TD1 TAU1 TD2 TAU2)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//V1 I1为初始值</span><br><span class="line">//V2 I2为终止值</span><br><span class="line">//TD1为上升延迟时间，缺省为0</span><br><span class="line">//TAU1为上升时间常数，缺省为TSTEP</span><br><span class="line">//TD2为下降延迟时间，缺省为TD1+TSTEP</span><br><span class="line">//TAU2为下降时间常数，缺省为TSTEP</span><br></pre></td></tr></table></figure>
<h5 id="分段线性电源"><a href="#分段线性电源" class="headerlink" title="分段线性电源"></a>分段线性电源</h5><p>  分段线性<strong>电压</strong>源：<strong>VXXXXXXX N+ N- PWL (T1 V1 &lt;T2 V2 T3 V3 T4 V4 …&gt;)</strong><br>  分段线性<strong>电流</strong>源：<strong>IXXXXXXX N+ N- PWL (T1 I1 &lt;T2 I2 T3 I3 T4 I4 …&gt;)</strong></p>
<h5 id="瞬态单调调频电源"><a href="#瞬态单调调频电源" class="headerlink" title="瞬态单调调频电源"></a>瞬态单调调频电源</h5><p>  瞬态单调调频<strong>电压</strong>源：<strong>VXXXXXXX N+ N- SEFM (V0 VA FC MDI FS)</strong><br>  瞬态单调调频<strong>电流</strong>源：<strong>IXXXXXXX N+ N- SEFM (I0 IA FC MDI FS)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    //V0 I0为偏置</span><br><span class="line">    //VA IA为幅度</span><br><span class="line">    //FC为载波频率，缺省值为1/TSTOP</span><br><span class="line">    //MDI为调制系数</span><br><span class="line">    //FS为信号频率，缺省值为1/TSTOP</span><br><span class="line"></span><br><span class="line">调频曲线表达式：</span><br><span class="line">    V(T)=V0+VA*SIN[(2*PI*FC*T)+MDI*SIN(2*PI*FS*T)]</span><br></pre></td></tr></table></figure>
<h4 id="线性受控源描述语句"><a href="#线性受控源描述语句" class="headerlink" title="线性受控源描述语句"></a>线性受控源描述语句</h4><p>压控<strong>电压</strong>源：<strong>EXXXXXXX N+ N- NC+ NC- VALUE</strong><br>压控<strong>电流</strong>源：<strong>GXXXXXXX N+ N- NC+ NC- VALUE</strong><br>流控<strong>电流</strong>源：<strong>HXXXXXXX N+ N- VNAME VALUE</strong><br>流控<strong>电流</strong>源：<strong>FXXXXXXX N+ N- VNAME VALUE</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//NC+ NC-为控制电压支路的正负节点</span><br><span class="line">//VNAME为控制电流流过的电压源的名称</span><br></pre></td></tr></table></figure>
<h2 id="分析语句"><a href="#分析语句" class="headerlink" title="分析语句"></a>分析语句</h2><h3 id="直流分析"><a href="#直流分析" class="headerlink" title="直流分析"></a>直流分析</h3><ul>
<li><p>直流<strong>工作点</strong>分析：  <strong>.OP</strong></p>
</li>
<li><p>直流<strong>扫描</strong>分析：**.DC <TYPE> VAR START STOP INC <VAR2 START2 STOP2>**</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//TYPE为扫描类型，线性为LIN、数量级为DEC、倍频程为OCT、列表为LIST</span><br><span class="line">//VAR为扫描变量</span><br><span class="line">//START STOP为扫描变化范围</span><br><span class="line">//INC是扫描步长或者点数，必须为正数</span><br><span class="line">//VAR2是第二个扫描变量（外循环），可选项</span><br></pre></td></tr></table></figure></li>
<li><p>直流小信号传输函数分析：**.TF OUTVAR INSRC**</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//OUTVAR为输出变量</span><br><span class="line">//INSRC为小信号输入源名称</span><br></pre></td></tr></table></figure></li>
<li><p>直流小信号灵敏度分析：**.SENS**</p>
</li>
<li><p>节点电压设置：**.NODESET**</p>
<h3 id="交流分析"><a href="#交流分析" class="headerlink" title="交流分析"></a>交流分析</h3></li>
<li><p>交流小信号分析：**.AC TYPE Nx FSTART FSTOP**</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线性   .AC LIN NP FSTART FSTOP</span><br><span class="line">数量级 .AC DEC ND FSTART FSTOP</span><br><span class="line">倍频程 .AC OCT NO FSTART FSTOP</span><br><span class="line">    //NP为步长</span><br><span class="line">    //ND为变化点数</span><br><span class="line">    //NO为变化点数</span><br></pre></td></tr></table></figure></li>
<li><p>噪声分析：**.NOISE OUTV INSRC NUMS**</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OUTV为某节点上总的噪声输出电压</span><br><span class="line">INSRC为作噪声输入基准的独立电压源或独立电流源名</span><br><span class="line">NUMS为频率间隔点数，在每个频率处打印出电路中每个噪声源的贡献</span><br></pre></td></tr></table></figure>
<h3 id="瞬态分析"><a href="#瞬态分析" class="headerlink" title="瞬态分析"></a>瞬态分析</h3></li>
<li><p>时域波形分析：**.TRAN TSTART TSTOP DISPSTART STEPMAX**</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//TSTART为起点时间</span><br><span class="line">//TSTOP为终点时间</span><br><span class="line">//DISPSTART为显示起点</span><br><span class="line">//STEPMAX为瞬态分析最大步长，可缺省而由系统选</span><br></pre></td></tr></table></figure></li>
<li><p>傅立叶分析：**.FOUR FREQ OV1 &lt;OV2 OV3 …&gt;**</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//FREQ为基频</span><br><span class="line">//OV1 OV2 OV3为要求的输出变量</span><br></pre></td></tr></table></figure></li>
<li><p>瞬态初始条件设置：**.IC**</p>
<h3 id="综合分析"><a href="#综合分析" class="headerlink" title="综合分析"></a>综合分析</h3></li>
<li><p>最坏情况分析：**.WCASE (ANALYSIS) (OUTVAR) <FUNCTION> <OPTION>**</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//ANALYSIS为DC/AC/TRAN中的一种</span><br><span class="line">//OUTVAR为输出变量，电压、电流等</span><br><span class="line">//FUNCTION为求值函数，有多种选择</span><br><span class="line">//OPTION为输出形式，LIST列每次运行模型参考值，OUTPUT输出文件或图形</span><br></pre></td></tr></table></figure></li>
<li><p>蒙特卡罗分析：**.MC (RUNSVAL) (ANALYSIS) <OUTPUTVAR> <FUNCTION> <OPTION>**</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//RUNSVAL为运行次数</span><br><span class="line">//OUTPUTVAR为输出变量，电压、电流等</span><br></pre></td></tr></table></figure></li>
<li><p>参数扫描分析：**.STEP**</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线性扫描          .STEP (LIN) VAR START STOP INC</span><br><span class="line">数量级倍频程扫描   .STEP &lt;DEC&gt; &lt;OCT&gt; VAR START STOP ND</span><br><span class="line">列表扫描          .STEP VAR LIST VAL1 &lt;VAL2 ...&gt;</span><br><span class="line">                        //INC为步长</span><br><span class="line">                        //ND为变化点数</span><br></pre></td></tr></table></figure></li>
<li><p>温度分析：**.TEMP**</p>
<h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2></li>
<li><p>别名设置语句：**.ALIASES<strong>和</strong>.ENDALIAS**，中间为设置内容</p>
</li>
<li><p>文本输出文件中打印：**.PRINT**</p>
</li>
<li><p>文本输出文件中绘图：**.PLOT**</p>
</li>
<li><p>绘图软件包调用：**.PROBE**</p>
</li>
<li><p>参数及表达式设置：**.PARAM (NAME1=VALUE1) &lt;NAME2=VALUE2&gt; …**</p>
<p>                                               //其中的VALUE也可用表达式EXPR</p>
</li>
<li><p>选择项设置：**.OPTION**</p>
</li>
<li><p>函数定义：**.FUNC**</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PSPICE中的PROBE控制语句：</span><br><span class="line">当输入文件中加入了.PROBE控制语句后，扫描计算结果存入*.dat文件中，可直观观察扫描结果</span><br><span class="line">PROBE自动将横坐标设为扫描变量，纵坐标需手动添加</span><br><span class="line">PROBE提供Cursor工具，方便使用鼠标的左右键控制两个光标，</span><br><span class="line">沿选定曲线进行测量，还有小窗口显示光标对应的值还有两光标间的差值</span><br></pre></td></tr></table></figure>
<h2 id="变量扫描"><a href="#变量扫描" class="headerlink" title="变量扫描"></a>变量扫描</h2></li>
</ul>
<p><strong>对一些仿真参数，PSPICE可设置为变量，通过设置其变化范围，仿真出不同的结果，以便进行对照以选择最佳值</strong></p>
<blockquote>
<p>如：可把双极型晶体管的偏置电阻设为变量，仿真出不同偏置电阻值时的放大系数及集电极电流等参数，最终可选择最佳的偏置电阻值<br>可进行变量扫描的参数如下：</p>
</blockquote>
<ul>
<li>独立源类：任何独立电压源和独立电流源都可以作为扫描变量</li>
<li>模型参数类：任何一个.MODEL中描述的模型参数都可作为扫描变量，如温度系数、场效应管的沟道长度和宽度等</li>
<li>温度变量：以TEMP作为扫描变量，可以观察在<strong>不同温度下的电路特性</strong></li>
<li>总体参数：对<strong>元器件值</strong>扫描，必须通过模型的设置来实现</li>
</ul>
<p>熟练使用参数的变量扫描，可大大提高仿真效率</p>
<h2 id="SPICE软件的适用范围及缺点"><a href="#SPICE软件的适用范围及缺点" class="headerlink" title="SPICE软件的适用范围及缺点"></a>SPICE软件的适用范围及缺点</h2><ul>
<li>SPICE是进行元器件级的仿真，对含元器件少的功能较单一的电路进行仿真较合适和准确，比如放大器、调制器等，但对结构复杂且器件较多的电路进行分析则比较费时，结果也可能偏离较大。</li>
<li>Spice采用变步长算法，对于周期性开关状态变化的电力电子电路而言，将造成把大量的时间耗费在寻求合适的步长上面，从而导致计算时间的延长。</li>
<li>SPICE的器件模型都是针对小功率电子器件的，而对于电力电子电路中所用的大功率器件存在的高电压、大注入现象不尽适用，有时甚至可能导致错误的结果。</li>
<li>SPICE的另一问题是仿真的收敛性问题，在对复杂电路进行仿真时，有时数据的准确性较低，甚至常出现不能收敛而导致仿真失败。SPICE软件更适合模拟电路仿真，可以做一些简单的数字电路仿真，但用于数模混合电路时很容易出问题。</li>
<li>SPICE模型的分析精度主要取决于模型参数的来源(即数据的精确性)，以及模型方程式的适用范围，而模型方程式与各种不同的数字仿真器相结合时也可能会影响分析的精度。</li>
<li>SPICE对元器件模型的依赖性很大，但这些参数通常都属于设计者和制造商的知识产权和机密，常因缺乏模型导致仿真无法实现。目前美国、欧洲的半导体厂商的分立元件的SPICE模型较多，特别是著名厂商网站上都可下载，但日本生产的元件就很少有模型，而IC的模型更是少得多，通常还要购买。</li>
<li>SPICE最早主要是为集成电路设计开发的，半导体模型参数设计太多工艺参数和材料特性，而不是用户手册上的使用参数，使用非常不便，在遇到模型库中未有的元件时，就难以仿真。虽然一些公司的SPICE软件也有新建元器件模型的界面，如PSPICE，但因参数涉及很多微电子专业的术语，使用者不容易理解和转换。</li>
<li>因各方面原因，仿真结果与实际调试出的电路的测试结果都有一些误差，而且常常在50%以上。</li>
<li>SPICE在应用于一些脉冲电路时，如方波发生器、多谐振荡器、单稳触发器、迟滞比较器等，也常常无法得到正确结果。</li>
<li>许多谐振器和振荡器电路都难以仿真。</li>
<li>RF电路仿真能力较差，阻抗匹配和阻抗园图等都难以使用，各种端口参数也难以实现。</li>
<li>在磁性元件的模型方面Spice也有待加强。<h2 id="SPICE网表文件的实例"><a href="#SPICE网表文件的实例" class="headerlink" title="SPICE网表文件的实例"></a>SPICE网表文件的实例</h2>是软件AIM-Spice附带的实例，而直观的原理图却没有提供，可自己试着画出来<br>（AIM-Spice是一个文本输入的Spice软件，功能单一且原始，但可免费下载，便于学习Spice。）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">difpair ckt - simple differential pair</span><br><span class="line">vin 1 0 sin(0 0.1 5meg) ac 1</span><br><span class="line">vcc 8 0 12</span><br><span class="line">vee 9 0 -12</span><br><span class="line">q1 4 2 6 qnl</span><br><span class="line">q2 5 3 6 qnl</span><br><span class="line">rs1 1 2 1k</span><br><span class="line">rs2 3 0 1k</span><br><span class="line">rc1 4 8 10k</span><br><span class="line">rc2 5 8 10k</span><br><span class="line">q3 6 7 9 qnl</span><br><span class="line">q4 7 7 9 qnl</span><br><span class="line">rbias 7 8 20k</span><br><span class="line">.model qnl npn(bf=80 rb=&quot;100&quot; ccs=&quot;2pf&quot; tf=&quot;0&quot;.3ns tr=&quot;6ns&quot; cje=&quot;3pf&quot; cjc=&quot;2pf&quot;</span><br><span class="line">+ va=&quot;50&quot;)</span><br><span class="line">2. 用ORCAD10中附带的PSPICE模块自动产生的网表文件的实例（删去了空行）：</span><br><span class="line">**** 11/15/08 16:12:15 ******* PSpice 10.0.0 (Jan 2003) ******* ID# 1111111111</span><br><span class="line">  ** Profile: &quot;SCHEMATIC1-bias&quot; [ D:\My Documents\orcad\transistor-pspicefiles\schematic1\bias.sim ]</span><br><span class="line">  **** CIRCUIT DESCRIPTION</span><br><span class="line">******************************************************************************</span><br><span class="line">** Creating circuit file &quot;bias.cir&quot;</span><br><span class="line">** WARNING: THIS AUTOMATICALLY GENERATED FILE MAY BE OVERWRITTEN BY SUBSEQUENT SIMULATIONS</span><br><span class="line">*Libraries:</span><br><span class="line">* Profile Libraries :</span><br><span class="line">* Local Libraries :</span><br><span class="line">* From [PSPICE NETLIST] section of e:\OrCAD\OrCAD_10.0\tools\PSpice\PSpice.ini file:</span><br><span class="line">.lib &quot;nom.lib&quot;</span><br><span class="line">*Analysis directives:</span><br><span class="line">.TRAN 0 20ms 10ms</span><br><span class="line">.PROBE V(alias(*)) I(alias(*)) W(alias(*)) D(alias(*)) NOISE(alias(*))</span><br><span class="line">.INC &quot;..\SCHEMATIC1.net&quot;</span><br><span class="line">**** INCLUDING SCHEMATIC1.net ****</span><br><span class="line">* source TRANSISTOR</span><br><span class="line">Q_Q1         N00286 N00312 N00298 Q2N3904</span><br><span class="line">R_R1         N00312 N00256 470k</span><br><span class="line">R_R2         N00286 N00256 2.2k</span><br><span class="line">R_R3         0 N00298 47</span><br><span class="line">R_R5         0 N00374 10k</span><br><span class="line">C_C1         N00423 N00312 100n</span><br><span class="line">C_C2         N00286 N00374 100n</span><br><span class="line">V_V1         N00256 0 6Vdc</span><br><span class="line">V_V2         N00423 0 DC 0 AC 1</span><br><span class="line">+SIN 0 1m 1k 0 0 0</span><br><span class="line">**** RESUMING bias.cir ****</span><br><span class="line">.END</span><br></pre></td></tr></table></figure>
其电路原理图及交流小信号分析和瞬态分析波形如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1617281007201-38abd98c-c847-49e9-b6da-e2906616e6e5.png#height=699&id=wjnxq&margin=%5Bobject%20Object%5D&name=image.png&originHeight=699&originWidth=445&originalType=binary&size=285866&status=done&style=none&width=445" alt="image.png"></li>
</ul>
]]></content>
      <categories>
        <category>笔记篇</category>
        <category>模拟</category>
      </categories>
      <tags>
        <tag>Spice</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟曲射电磁炮设计</title>
    <url>/2020/08/20/%E6%A8%A1%E6%8B%9F%E6%9B%B2%E5%B0%84%E7%94%B5%E7%A3%81%E7%82%AE%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个设计是我参加2019年电赛的H题，把这写下来，留着以后看，虽然设计在现在看来也是极为青涩的，但是还我觉得这也是一种成长，总归是要慢慢进步的。</p>
<h2 id="比赛要求"><a href="#比赛要求" class="headerlink" title="比赛要求"></a>比赛要求</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619009320013-341bcdeb-6b79-441e-93aa-b0e8bccf1206.png#clientId=uca370bc3-e29e-4&from=paste&height=792&id=u32259fb9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=792&originWidth=683&originalType=binary&size=118281&status=done&style=none&taskId=u805ee355-7759-47cf-b6e6-ffc0b36297c&width=683" alt="image.png"></p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本参赛小组设计并制作了模拟电磁曲射炮，实现在不同方向自动或手动搜索目标并且发射弹丸的功能。该系统主要由机械部分和控制部分组成，其中机械部分包括底座、云台以及炮筒等；控制部分主要由单片机、舵机、摄像头以及电磁炮控制电路组成。系统选用 STM32F103ZET6 为控制核心，通过晶闸管和继电器控制电磁炮发射，通过舵机控制<br>电磁炮发射方向，通过摄像头 OpenMV 图像信息分析目标位置并反馈，采用 PID 算法实现自动控制。该系统具有结构稳定、控制方便、抗干扰能力强等优点。<br><strong>关键词</strong>：电磁炮、STM32F103ZET6、继电器、舵机、OpenMV、PID 算法</p>
<h2 id="系统方案"><a href="#系统方案" class="headerlink" title="系统方案"></a>系统方案</h2><p>本系统主要由 OpenMV 图像采集模块、单片机控制模块、舵机控制模块、电磁炮控制模块、电源模块组成。</p>
<h3 id="单片机的论证与选择"><a href="#单片机的论证与选择" class="headerlink" title="单片机的论证与选择"></a>单片机的论证与选择</h3><ul>
<li>方案一：MSP430。</li>
</ul>
<p>采用 TI 的 MSP430 系列单片机做主控制器，该系列单片机资源 较丰富，易控制， 低功耗。但由是于单片机本身主频较低，因而处理速度一般。</p>
<ul>
<li>方案二：STM32F103。</li>
</ul>
<p>采用 STM32F103  系列单片机做主控芯片，该单片机控制较为复杂，且内部定时器，<br>IIC，SPI 等资源丰富，运算处理速度快，十分适合控制系统的实时控制。<br>综合以上两种方案，选择方案二。</p>
<h3 id="距离测量模块的选择"><a href="#距离测量模块的选择" class="headerlink" title="距离测量模块的选择"></a>距离测量模块的选择</h3><ul>
<li>方案一：超声波测距模块</li>
</ul>
<p>超声波指向性强，在介质中传播的距离较远，因而超声波经常用于距离的测量，如测距仪和物位测量仪等都可以通过超声波来实现。利用超声波检测往往比较迅速、方便、计算简单、易于做到实时控制。</p>
<ul>
<li>方案二：摄像头 OpenMV</li>
</ul>
<p>OpenMV 测距有两种方法，第一种是利用 apriltag，Apriltag 可以进行 3D 定位。第二种是选参照物，利用参照物的大小比例来计算距离。<br>综合以上两种方案，选择方案二。</p>
<h3 id="控制系统的论证与选择"><a href="#控制系统的论证与选择" class="headerlink" title="控制系统的论证与选择"></a>控制系统的论证与选择</h3><ul>
<li>方案一：采用模糊控制算法</li>
</ul>
<p>模糊控制算法有许多优良的特性，它不需要事先知道对象的数学模型。具有系统响应快、超调小、过渡过程时间短等优点。但是它的编程复杂，数据处理量大。</p>
<ul>
<li>方案二：采用 PID 算法</li>
</ul>
<p>按比例、积分、微分的函数关系进行运算，然后将其运算结果用以输出控制。优点是控制精度高且算法简单明了。对于本系统的控制已足够精确，节约了单片机的资源与运算时间。<br>综合以上两种方案，选择方案二。</p>
<h2 id="系统理论分析与计算"><a href="#系统理论分析与计算" class="headerlink" title="系统理论分析与计算"></a>系统理论分析与计算</h2><h2 id="系统结构的分析"><a href="#系统结构的分析" class="headerlink" title="系统结构的分析"></a>系统结构的分析</h2><p>通过对题目要求的分析，需要制作电磁炮并控制电磁炮旋转角度，而电磁炮的旋转角度则是通过控制舵机的旋转角度控制的。旋转云台下方舵机改变偏航角使得电磁炮正对环形靶，旋转云台上方舵机改变俯仰角使得电磁炮射出一定距离。摄像头 OpenMV 识别引导标识的方向与距离并反馈，采用 PID 算法自动控制舵机的旋转角度，从而实现电磁炮瞄准环形靶。</p>
<h3 id="电磁炮控制分析"><a href="#电磁炮控制分析" class="headerlink" title="电磁炮控制分析"></a>电磁炮控制分析</h3><p>电磁炮电路由逆变电路、升压电路、整流电路、保护电路、泄放电路四部分组成， 采用单管自激振荡电路作为逆变电路，将直流电逆变为交流电，以便于后面用互感线圈进行升压，升压后可达到一百余伏，然后通过整流二极管将交流电整形成直流脉冲，然后给电容充电，其中稳压管起保护作用，将电压稳定在 200v 左右，防止过高的电压击穿电容器，最后的泄放电路将电容内部的高压直流电瞬间释放，已到达瞬间电压电流都很高的目的，同时获得强大的电磁力，将铁质子弹发射出去。</p>
<h3 id="舵机旋转角度的计算"><a href="#舵机旋转角度的计算" class="headerlink" title="舵机旋转角度的计算"></a>舵机旋转角度的计算</h3><h4 id="俯仰角的计算"><a href="#俯仰角的计算" class="headerlink" title="俯仰角的计算"></a>俯仰角的计算</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619009513151-8c8c93b7-00db-4111-a651-d836bb3a3287.png#clientId=uca370bc3-e29e-4&from=paste&height=215&id=u5c7fcda0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=215&originWidth=613&originalType=binary&size=88087&status=done&style=none&taskId=uf5de6604-1b70-4018-9921-bdbc1a2069e&width=613" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619009529701-9b493bed-ecd6-4131-9a26-53726d01ad0b.png#clientId=uca370bc3-e29e-4&from=paste&height=286&id=ucec27315&margin=%5Bobject%20Object%5D&name=image.png&originHeight=286&originWidth=627&originalType=binary&size=108163&status=done&style=none&taskId=u076aa8cf-9e71-4e3e-8ebe-e730a66e0aa&width=627" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619009558030-5b287ff7-2e3a-4cd1-963b-b744adb32065.png#clientId=uca370bc3-e29e-4&from=paste&height=236&id=ub95c22af&margin=%5Bobject%20Object%5D&name=image.png&originHeight=236&originWidth=496&originalType=binary&size=30574&status=done&style=none&taskId=u37d23b84-06c9-43d5-b6e3-a2c56b370f9&width=496" alt="image.png"></p>
<h4 id="偏航角的计算"><a href="#偏航角的计算" class="headerlink" title="偏航角的计算"></a>偏航角的计算</h4><p>偏航角即在水平方向上的偏离角度，在基础要求中，偏航角要求输入，因此就可以将偏航角转换成控制舵机的 PWM 波的值，然后进行控制，输出不同脉冲宽度的方波， 其中    脉宽波= 50 + 偏航角* 100/90.0。通过对脉宽的逐渐增加来达到舵机不同的运转方向以及速度。</p>
<h2 id="电路与程序设计"><a href="#电路与程序设计" class="headerlink" title="电路与程序设计"></a>电路与程序设计</h2><h3 id="电路的设计"><a href="#电路的设计" class="headerlink" title="电路的设计"></a>电路的设计</h3><h4 id="系统总体框图"><a href="#系统总体框图" class="headerlink" title="系统总体框图"></a>系统总体框图</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619009738513-ba1c1aef-4aac-4e91-bb9b-40705dad24e8.png#clientId=uca370bc3-e29e-4&from=paste&height=430&id=u7af37e03&margin=%5Bobject%20Object%5D&name=image.png&originHeight=430&originWidth=568&originalType=binary&size=67496&status=done&style=none&taskId=u606650f0-34fc-4e34-a7a9-79e219e902a&width=568" alt="image.png"></p>
<h4 id="电磁炮子系统框图"><a href="#电磁炮子系统框图" class="headerlink" title="电磁炮子系统框图"></a>电磁炮子系统框图</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619009770980-8ac39ac4-992d-43d6-be9e-40befdd2afe6.png#clientId=uca370bc3-e29e-4&from=paste&height=292&id=u89ea5cfc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=292&originWidth=342&originalType=binary&size=51185&status=done&style=none&taskId=u2e9125b7-305b-45ab-8fcd-9d2c21c24c3&width=342" alt="image.png"></p>
<h4 id="电磁炮子系统电路原理图"><a href="#电磁炮子系统电路原理图" class="headerlink" title="电磁炮子系统电路原理图"></a>电磁炮子系统电路原理图</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619009782694-490da864-e650-4778-b832-da19a185349c.png#clientId=uca370bc3-e29e-4&from=paste&height=324&id=u33ef80c6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=324&originWidth=449&originalType=binary&size=55097&status=done&style=none&taskId=u3796916b-e1fd-4abb-be19-ed5001b2f6b&width=449" alt="image.png"></p>
<h4 id="舵机子系统框图"><a href="#舵机子系统框图" class="headerlink" title="舵机子系统框图"></a>舵机子系统框图</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619009874033-053eb2bd-e32c-4729-8b01-10408d8390fa.png#clientId=uca370bc3-e29e-4&from=paste&height=130&id=uebbd7c15&margin=%5Bobject%20Object%5D&name=image.png&originHeight=130&originWidth=630&originalType=binary&size=51478&status=done&style=none&taskId=ufa24f3dc-b62b-4220-b19d-92c763fb030&width=630" alt="image.png"></p>
<h3 id="程序的设计"><a href="#程序的设计" class="headerlink" title="程序的设计"></a>程序的设计</h3><h4 id="程序功能描述与设计思路"><a href="#程序功能描述与设计思路" class="headerlink" title="程序功能描述与设计思路"></a>程序功能描述与设计思路</h4><p>根据题目要求，软件部分实现摄像头模块的采集、电磁炮自动发射、舵机的自动旋转、无线遥控的功能设置和显示功能。</p>
<ol>
<li>摄像头图像的采集：使用摄像头 OpenMV 对图像进行处理，将引导标识中心点坐标及位置反馈至 STM32。</li>
<li>电磁炮自动发射：当舵机旋转至正确位置后，STM32 控制电容蓄能时间，一定时间后发射电磁炮。</li>
<li>舵机自动旋转：STM32 对 OpenMV 返回值进行处理，控制舵机旋转。旋转云台下方舵机改变偏航角使得电磁炮正对环形靶，旋转云台上方舵机改变俯仰角使得电磁炮射出一定距离。</li>
<li>无线遥控的功能设置：使用红外遥控通过按键控制模式选择，实现基本部分和发挥部分的要求；</li>
<li>显示：显示距离、角度、模式等必要参数，方便记录观察。<h4 id="程序流程图"><a href="#程序流程图" class="headerlink" title="程序流程图"></a>程序流程图</h4><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619009989566-e3da51e4-d168-41b2-bcd0-daf999d5bcf4.png#clientId=uca370bc3-e29e-4&from=paste&height=467&id=u94bb5329&margin=%5Bobject%20Object%5D&name=image.png&originHeight=467&originWidth=232&originalType=binary&size=39482&status=done&style=none&taskId=ufbd439ab-a646-44e2-af94-6e0589d1b3b&width=232" alt="image.png"></li>
</ol>
<p>本次设计程序较为简单，只需要按键输入数值然后在进行，模式的选择，控制舵机旋转瞄准，然后控制电压的大小，以到达不同的电源充能然后通过晶闸管对电容的能量进行瞬间泄放。从而将电能转换成子弹的动能，并发射出去。</p>
<h2 id="测试方案与测试结果"><a href="#测试方案与测试结果" class="headerlink" title="测试方案与测试结果"></a>测试方案与测试结果</h2><h3 id="测试方案"><a href="#测试方案" class="headerlink" title="测试方案"></a>测试方案</h3><h4 id="硬件测试"><a href="#硬件测试" class="headerlink" title="硬件测试"></a>硬件测试</h4><p>电路焊接完成后，用万用表检测是否有断路、断路等各种故障。检测无误后，进行整体安装，将电路安装在支架适当位置。同时检测各个元器件的好坏，例如，红外探头、舵机、电磁炮控制电路等等。</p>
<h4 id="软件仿真测试"><a href="#软件仿真测试" class="headerlink" title="软件仿真测试"></a>软件仿真测试</h4><p>根据要求，由于电磁炮的瞬间电压较大，因此在控制之前要进行软件仿真模拟，通过对单片机程序的烧录，然后通过示波器检测引脚的波形图，验证信号输出的正确性， 因此在不断的输出后 不断的验证，达到软件的仿真验证。</p>
<h4 id="硬件软件联调"><a href="#硬件软件联调" class="headerlink" title="硬件软件联调"></a>硬件软件联调</h4><p>根据比赛的要求，自己制作类似的靶子以及标志物，然后进行比赛仿真模拟练习。硬件部分安装完成以后，将程序完全下载到单片机中，在场地上试运行，观察电磁<br>炮的发射状况，以及显示屏的显示情况。然后根据实际落炮点偏差情况，对程序进行改正优化。使其运行显示逐步精确。</p>
<h3 id="测试条件与仪器"><a href="#测试条件与仪器" class="headerlink" title="测试条件与仪器"></a>测试条件与仪器</h3><p>测试条件：检查多次，仿真电路和硬件电路必须与系统原理图完全相同，并且检查无误，硬件电路保证无虚焊。<br>测试仪器：高精度的数字毫伏表，模拟示波器，数字示波器，数字万用表。</p>
<h3 id="测试结果及分析"><a href="#测试结果及分析" class="headerlink" title="测试结果及分析"></a>测试结果及分析</h3><h4 id="测试结果-数据"><a href="#测试结果-数据" class="headerlink" title="测试结果(数据)"></a>测试结果(数据)</h4><table>
<thead>
<tr>
<th>实验次数</th>
<th>蓄能时间（ms）</th>
<th>电压值</th>
<th>射程</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>5000</td>
<td>71.8</td>
<td>85</td>
</tr>
<tr>
<td>2</td>
<td>5500</td>
<td>75</td>
<td>160</td>
</tr>
<tr>
<td>3</td>
<td>5750</td>
<td>78</td>
<td>200</td>
</tr>
<tr>
<td>4</td>
<td>6000</td>
<td>80.6</td>
<td>220</td>
</tr>
<tr>
<td>5</td>
<td>7500</td>
<td>89</td>
<td>260</td>
</tr>
</tbody></table>
<h4 id="测试分析与结论"><a href="#测试分析与结论" class="headerlink" title="测试分析与结论"></a>测试分析与结论</h4><p>根据反复调整测试，由此可以得出以下结论：</p>
<ul>
<li>电磁炮一键发射，通过定时器控制定时时间的长度，来达到蓄能的目的，然后，单片机关闭蓄电的继电器，然后，控制晶闸管来释放电能，达到发炮的效果。</li>
<li>当炮台检测到红色的标志物之后，可以调整舵机的转向，瞄准目标，通过摄像头测量距离，计算蓄能时间，然后自动的完成开炮的行动。</li>
<li>自动寻找目标，自动识别距离角度等参数，自行计算发炮的角度和蓄能电压。</li>
<li>通过添加外加电路，在测距和颜色识别基础上实现，通过液晶屏对结果进行显示，使炮台运动情况一目了然。</li>
</ul>
<p>综上所述，本设计达到设计要求。</p>
]]></content>
      <categories>
        <category>项目篇</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>STM32</tag>
        <tag>C语言</tag>
        <tag>PID</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2020/07/15/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为”元字符”）。</p>
<p>正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。</p>
<h3 id="常用规则"><a href="#常用规则" class="headerlink" title="常用规则"></a>常用规则</h3><table>
<thead>
<tr>
<th align="center">字符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\d</td>
<td align="left">匹配一个数字字符。等价于 [0-9]</td>
</tr>
<tr>
<td align="center">\D</td>
<td align="left">匹配一个非数字字符。等价于 [^0-9]</td>
</tr>
<tr>
<td align="center">\w</td>
<td align="left">匹配包括下划线的任何单词字符。等价于[A-Za-z0-9_]</td>
</tr>
<tr>
<td align="center">\W</td>
<td align="left">匹配任何非单词字符。等价于 ‘[^A-Za-z0-9_]’</td>
</tr>
<tr>
<td align="center">[xyz]</td>
<td align="left">字符集合，匹配所包含的任意一个字符</td>
</tr>
<tr>
<td align="center">`x</td>
<td align="left">y`</td>
</tr>
<tr>
<td align="center">[^xyz]</td>
<td align="left">字符取反集合,匹配未包含的任意字符</td>
</tr>
<tr>
<td align="center">[a-z]</td>
<td align="left">字符范围。匹配指定范围内的任意字符</td>
</tr>
<tr>
<td align="center">.</td>
<td align="left">匹配除 “\n” 之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符可以用”(.</td>
</tr>
</tbody></table>
<h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3><p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配</p>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>*</code></td>
<td align="left">匹配前面的子表达式零次或多次，等价于{0,}</td>
</tr>
<tr>
<td align="center"><code>+</code></td>
<td align="left">匹配前面的子表达式一次或多次，等价于 {1,}</td>
</tr>
<tr>
<td align="center">?</td>
<td align="left">匹配前面的子表达式零次或一次，等价于 {0,1}</td>
</tr>
<tr>
<td align="center">{n}</td>
<td align="left">n是一个非负整数。匹配确定的n次</td>
</tr>
<tr>
<td align="center">{n,}</td>
<td align="left">n是一个非负整数。至少匹配n次</td>
</tr>
<tr>
<td align="center">{n,m}</td>
<td align="left">m,n为非负整数n &lt;= m,最n-m次,在逗号和两个数之间不能有空格</td>
</tr>
<tr>
<td align="center">()</td>
<td align="left">把括号内的作为一个整体，比如(ab){2},匹配abab</td>
</tr>
</tbody></table>
<h3 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h3><p>定位符用来描述字符串或单词的边界</p>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">^</td>
<td align="left">匹配输入字符串开始的位置。如果设置了RegExp对象的 Multiline 属性，还会与 \n 或 \r 之后的位置匹配</td>
</tr>
<tr>
<td align="center">$</td>
<td align="left">匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配</td>
</tr>
<tr>
<td align="center">\b</td>
<td align="left">匹配一个字边界，即字与空格间的位置</td>
</tr>
<tr>
<td align="center">\B</td>
<td align="left">非字边界匹配</td>
</tr>
</tbody></table>
<h3 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h3><p>非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列</p>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\cx</td>
<td align="left">匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符</td>
</tr>
<tr>
<td align="center">\f</td>
<td align="left">匹配一个换页符。等价于 \x0c 和 \cL</td>
</tr>
<tr>
<td align="center">\n</td>
<td align="left">匹配一个换行符。等价于 \x0a 和 \cJ</td>
</tr>
<tr>
<td align="center">\r</td>
<td align="left">匹配一个回车符。等价于 \x0d 和 \cM</td>
</tr>
<tr>
<td align="center">\s</td>
<td align="left">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]</td>
</tr>
<tr>
<td align="center">\S</td>
<td align="left">匹配任何非空白字符。等价于 [^ \f\n\r\t\v]</td>
</tr>
<tr>
<td align="center">\t</td>
<td align="left">匹配一个制表符。等价于 \x09 和 \cI</td>
</tr>
<tr>
<td align="center">\v</td>
<td align="left">匹配一个垂直制表符。等价于 \x0b 和 \cK</td>
</tr>
</tbody></table>
<h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p>盗的一张图</p>
<p><img src="regexp.png" alt="regexp"></p>
<h2 id="贪婪非贪婪"><a href="#贪婪非贪婪" class="headerlink" title="贪婪非贪婪"></a>贪婪非贪婪</h2><p>*、+和?限定符都是贪婪的，因为它们会尽可能多的匹配文字</p>
<p>默认是贪婪模式匹配,在量词后面直接加上一个问号？就是非贪婪模式。</p>
<p>比如有一段文字<code>&lt;p&gt;6666&lt;/p&gt;</code></p>
<p>如果使用<code>&lt;.+&gt;</code>是默认的贪婪匹配，会匹配到<code>&lt;p&gt;6666&lt;/p&gt;</code></p>
<p>而使用<code>&lt;.+?&gt;</code>就变成了非贪婪匹配，会匹配到<code>&lt;p&gt;</code>和<code>&lt;/p&gt;</code></p>
<h2 id="在Java中使用正则"><a href="#在Java中使用正则" class="headerlink" title="在Java中使用正则"></a>在Java中使用正则</h2><p>在Java 正则表达式很方便</p>
<p>主要使用java.util.regex包下的几个类</p>
<h3 id="Pattern"><a href="#Pattern" class="headerlink" title="Pattern"></a>Pattern</h3><p>Pattern对象是一个正则表达式的编译表示。Pattern类没有构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态的compile编译方法要么传入一个正则表达式或者传入一个表达式和规则，比如不区分大小写….</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pattern pattern = Pattern.compile(&quot;&lt;.+?&gt;&quot;);</span><br><span class="line">Pattern pattern = Pattern.compile(&quot;&lt;.+?&gt;&quot;,Pattern.CASE_INSENSITIVE);</span><br></pre></td></tr></table></figure>

<h3 id="Matcher"><a href="#Matcher" class="headerlink" title="Matcher"></a>Matcher</h3><p>Matcher对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。</p>
<p>matches：整个匹配，只有整个字符序列完全匹配成功，才返回True，否则返回False。但如果前部分匹配成功，将移动下次匹配的位置</p>
<p>lookingAt：部分匹配，总是从第一个字符进行匹配,匹配成功了不再继续匹配，匹配失败了,也不继续匹配</p>
<p>find：部分匹配，从当前位置开始匹配，找到一个匹配的子串，将移动下次匹配的位置</p>
<p>groupCount：返回正则表达式中组的个数，和要匹配的字符串无关</p>
<p>group:以正则表达是中的某个组来匹配，find之后才可以使用</p>
<p>start,end:find之后返回为真后才可以用，返回的是匹配到的开始和结束，可用group来取出结果</p>
<p>reset:清除find后保存的开始结束位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pattern pattern = Pattern.compile(&quot;&lt;.+?&gt;&quot;);</span><br><span class="line"></span><br><span class="line">Matcher matcher = pattern.matcher(&quot;&lt;p&gt;6666&lt;/p&gt;123&quot;);</span><br><span class="line"></span><br><span class="line">// 多个匹配位置</span><br><span class="line">while(matcher.find())&#123;</span><br><span class="line">    //当前匹配位置的组matcher.group()</span><br><span class="line">    System.out.println(matcher.start()+&quot;,&quot;+matcher.end()+matcher.group());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pattern pattern = Pattern.compile(&quot;(iPhone; CPU|Android.*;)\\s(.*?)\\s(Build/|OS)&quot;);</span><br><span class="line"></span><br><span class="line">Matcher matcher = pattern.matcher(&quot;Mozilla/5.0 (Linux; Android 6.0.1; Redmi 4 Build/MMB29M; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/57.0.2987.132 Mobile Safari/537.36&quot;);</span><br><span class="line"></span><br><span class="line">if (matcher.find()) &#123;</span><br><span class="line">    System.out.println(matcher.group(1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>在字符串上可以直接使用正则表达式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String pat = &quot;&lt;.+?&gt;&quot;;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;123&lt;p&gt;6666&lt;/p&gt;123&quot;.matches(pat));//整串匹配，false</span><br><span class="line"></span><br><span class="line">for(String str:&quot;123&lt;p&gt;6666&lt;/p&gt;123&quot;.split(pat))&#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">false</span><br><span class="line">123</span><br><span class="line">6666</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<h2 id="在JavaScript中使用正则"><a href="#在JavaScript中使用正则" class="headerlink" title="在JavaScript中使用正则"></a>在JavaScript中使用正则</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>正则表达式实例的的创建方式有两种，字面量创建方式和实例创建方式</p>
<p>注意的是实例创建方式传出的pattern是个字符串，要对\做转义<code>/\d/ = &gt; &quot;\\d&quot;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 字面量创建方式</span><br><span class="line">var reg = /pattern/flags</span><br><span class="line">// 实例创建方式</span><br><span class="line">var reg = new RegExp(pattern,flags);</span><br><span class="line"></span><br><span class="line">pattern:正则表达式</span><br><span class="line">flags:标识(修饰符)</span><br><span class="line">标识主要包括：</span><br><span class="line">1. i 忽略大小写匹配</span><br><span class="line">2. m 多行匹配，即在到达一行文本末尾时还会继续寻常下一行中是否与正则匹配的项</span><br><span class="line">3. g 全局匹配 模式应用于所有字符串，而非在找到第一个匹配项时停止</span><br></pre></td></tr></table></figure>

<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>正则实例上的方法：test、exec</p>
<p>字符串上的方法：match、replace、search、split</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">patt.test(str)//测试字符串是否符合模式</span><br><span class="line"></span><br><span class="line">str.split(patt)//分割字符串</span><br><span class="line"></span><br><span class="line">分组</span><br><span class="line"></span><br><span class="line">var re = /^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$/;</span><br><span class="line">re.exec(&#x27;010-12345&#x27;); // [&#x27;010-12345&#x27;, &#x27;010&#x27;, &#x27;12345&#x27;]</span><br><span class="line">re.exec(&#x27;010 12345&#x27;); // null</span><br><span class="line"></span><br><span class="line">var s = &#x27;JavaScript, VBScript, JScript and ECMAScript&#x27;;</span><br><span class="line">var re=/[a-zA-Z]+Script/g;</span><br><span class="line"></span><br><span class="line">// 使用全局匹配:</span><br><span class="line">re.exec(s); // [&#x27;JavaScript&#x27;]</span><br><span class="line">re.lastIndex; // 10</span><br><span class="line"></span><br><span class="line">re.exec(s); // [&#x27;VBScript&#x27;]</span><br><span class="line">re.lastIndex; // 20</span><br><span class="line"></span><br><span class="line">re.exec(s); // [&#x27;JScript&#x27;]</span><br><span class="line">re.lastIndex; // 29</span><br><span class="line"></span><br><span class="line">re.exec(s); // [&#x27;ECMAScript&#x27;]</span><br><span class="line">re.lastIndex; // 44</span><br><span class="line"></span><br><span class="line">re.exec(s); // null，直到结束仍没有匹配到</span><br><span class="line"></span><br><span class="line">str.match(pat)//返回数组，数组的内容依赖于 regexp 是否具有全局标志g，否则是第一个匹配的</span><br><span class="line"></span><br><span class="line">&quot;&lt;p&gt;666&lt;/p&gt;&quot;</span><br><span class="line">s.match(/&lt;.+?&gt;/);</span><br><span class="line">[&quot;&lt;p&gt;&quot;]</span><br><span class="line">s.match(/&lt;.+?&gt;/g);</span><br><span class="line">[&quot;&lt;p&gt;&quot;, &quot;&lt;/p&gt;&quot;]</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.runoob.com/regexp/regexp-tutorial.html">正则表达式 - 教程</a></p>
<p><a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434499503920bb7b42ff6627420da2ceae4babf6c4f2000">廖雪峰的官方网站</a></p>
<p><a href="https://github.com/chenermeng/blog">chenermeng/blog</a></p>
]]></content>
      <categories>
        <category>笔记篇</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>HTML+CSS</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>主从JK触发器设计及分析</title>
    <url>/2020/06/29/%E4%B8%BB%E4%BB%8EJK%E8%A7%A6%E5%8F%91%E5%99%A8%E7%9A%84%E7%89%88%E5%9B%BE%E8%AE%BE%E8%AE%A1%E5%8F%8A%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>集成电路中的版图设计衔接了电路原理图和制造工艺，因此一张好的版图设计不仅会对器件的实际效果造成影响，还会影响芯片的寿命，画版图之前首先要对电路软件有一定的了解，通过对电路知识的运用，以及版图设计规则的了解，完成JK触发器的版图设计，并进行合理的布局，并对布局布线进行优化，最后在对电路提出一些改进意见来增加电路的灵敏度以及合理性。<br><strong>关键词</strong>：版图设计、JK触发器、版图优化L-Edit软件、集成电路</p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>随着科技的进步，近几个世纪集成电路技术不断成熟，在数字电路中，触发器已经是一个经常被提出的概念，JK触发器是数字电路触发器中的一种基本电路单元。JK触发器具有置0、置1、保持和翻转功能，在各类集成触发器中，JK触发器的功能最为齐全。在实际应用中，它不仅有很强的通用性，而且能灵活地转换其他类型的触发器。由JK触发器可以构成D触发器和T触发器</p>
<h1 id="主从JK触发器设计"><a href="#主从JK触发器设计" class="headerlink" title="主从JK触发器设计"></a>主从JK触发器设计</h1><p>目前，基于Tanner EDA 技术的电路设计已经在该领域中取得了较为突破的发展，主要是借助了L-Edit 等软件的强大功能以及传统的数学及电路知识，在软件平台上成功实现 JK触发器的电路设计以及版图实现。<br>Tanner EDA对电路进行设计一般遵从以下几个步骤，首先把设计的电路在S-Edit中编辑出来，然后输出Spice文件，然后在进行模拟分析，其中还必须时刻进行DRC检查，保证电路没有任何违反设计规则的错误，确保布局图无误后，利用软件将文件和版图进行对比，若结果吻合，那么就输出设计好的版图。具体流程如下图（图1）所示：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619073946857-39478761-f4ff-4b6d-94c0-7c43721cba08.png#clientId=u6ece1c38-457f-4&from=paste&height=671&id=ube3dac36&margin=%5Bobject%20Object%5D&name=image.png&originHeight=671&originWidth=459&originalType=binary&size=31670&status=done&style=none&taskId=u2209ac82-e167-48d0-8c4f-0a3d50a2ff3&width=459" alt="image.png"></p>
<h2 id="基本MOS管版图设计"><a href="#基本MOS管版图设计" class="headerlink" title="基本MOS管版图设计"></a>基本MOS管版图设计</h2><h3 id="NMOS基本版图设计"><a href="#NMOS基本版图设计" class="headerlink" title="NMOS基本版图设计"></a>NMOS基本版图设计</h3><p>首先根据NMOS器件的特性设计衬底，然后向其中加入源漏栅极，确定源级和漏极之后，进行DRC检查，保证版图的设计没有不符合规则的地方，铺设金属和各级接触孔，最后在进行检查。一个基础的NMOS版图就基本设计完成。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619074039268-cd44e035-e0a1-4932-bcb0-0bef8d712e26.png#clientId=u6ece1c38-457f-4&from=paste&height=165&id=u9e1dcf5f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=165&originWidth=537&originalType=binary&size=39731&status=done&style=none&taskId=u7726ed27-a619-46c0-9bda-0565abace7f&width=537" alt="image.png"></p>
<h3 id="PMOS基本版图设计"><a href="#PMOS基本版图设计" class="headerlink" title="PMOS基本版图设计"></a>PMOS基本版图设计</h3><p>基本的PMOS和NMOS版图步骤基本差不多，但制备NMOS的衬底是P衬底，PMOS的衬底是N型，因此要先设计n阱然后在进行管子的设计。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619074083937-ef53c5a5-3f04-4d09-831b-259ee284f15a.png#clientId=u6ece1c38-457f-4&from=paste&height=193&id=ud525a8cc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=193&originWidth=591&originalType=binary&size=66762&status=done&style=none&taskId=u2a184a30-2606-4347-bb6b-8f701d457a8&width=591" alt="image.png"><br>设计基本元器件的版图，不仅需要知道 L-Edit 软件的使用，还要掌握各个元的基本结构原理与工作原理以及对器件的剖面图、左视图、正面图识别，这样，图设计的时候心里就有一个大致的方向，画起来就比较的容易。在这张节中，画基本元器件的某些版图时，出现了多个金属接触孔，这是因为让金属线条和有源区能够充分的接触，能够进行高速率的导电，同时可以防止在工艺加工时某个接触孔接触不良而发生的断路现象。不是说画的孔越多越好，也需要进行综合考虑，比如器件的版图设计大小对于材料成本是否划算等，这些通常需要厂家的准确预算。对于简单的版图设计，可以画出器件版图后进行 DRC 检查，但是对于复杂的器件，必须画一步进行一步 DRC 检查，不能画完后进行检查，因为大规模电路版图是成千上万个元件和几何图形的有机组合，设计过程中有成千上万次操作，如果某个器件的版图因为 DRC 检查出错，而修改，则许多器件的版图需要做出相应的调整，不然制作出来的器件将达不到厂家预想的目的。</p>
<h2 id="主从JK触发器原理图设计"><a href="#主从JK触发器原理图设计" class="headerlink" title="主从JK触发器原理图设计"></a>主从JK触发器原理图设计</h2><p>主从 JK触发器是在主从RS触发器的基础上组成的，如图6所示。在主从RS 触发器的R端和S端分别增加一个两输入端的与门U1和U2，将Q(out1) 端和输入端经与门输出为原S端，输入端称为J端，将Q(out)端与输入端经与门输出为原R端，输入端称为K端。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619074170341-9ee351a1-aa27-433b-8399-f7f6af2bc8a5.png#clientId=u6ece1c38-457f-4&from=paste&height=368&id=ud9c5394e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=368&originWidth=681&originalType=binary&size=253867&status=done&style=none&taskId=uf084335f-5b09-4922-b849-e12bcbdffe0&width=681" alt="image.png"></p>
<h2 id="主从JK触发器逻辑分析"><a href="#主从JK触发器逻辑分析" class="headerlink" title="主从JK触发器逻辑分析"></a>主从JK触发器逻辑分析</h2><p>从以上电路原理图我们可以知道主从JK触发器没有约束条件。在J=K=1时，每输入一个时钟脉冲，触发器就翻转一次。触发器期的这种状态称为计数状态，由触发器翻转的次数可以计算出输入时钟的脉冲的个数。其状态转移真值表（图7）和仿真波形图（图8）如下所示<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619074223250-76873a9d-a9fa-47d8-899d-bd5fd1cf294a.png#clientId=u6ece1c38-457f-4&from=paste&height=309&id=uc9afedec&margin=%5Bobject%20Object%5D&name=image.png&originHeight=309&originWidth=588&originalType=binary&size=92111&status=done&style=none&taskId=ude67ebc5-d0f3-4232-8e69-737337e8b6c&width=588" alt="image.png"><br>在J=K=1时输入CP时钟信号</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619074272602-fecd8576-9788-4ec0-97ae-5caa9d3a8a6b.png#clientId=u6ece1c38-457f-4&from=paste&height=255&id=ubeb3088d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=255&originWidth=653&originalType=binary&size=16479&status=done&style=none&taskId=u3f95f66f-9658-4a16-9ee6-618114b0e7d&width=653" alt="image.png"></p>
<h2 id="主从JK触发器版图设计"><a href="#主从JK触发器版图设计" class="headerlink" title="主从JK触发器版图设计"></a>主从JK触发器版图设计</h2><h3 id="非门电路"><a href="#非门电路" class="headerlink" title="非门电路"></a>非门电路</h3><p>非门又称反相器，因CMOS反相器功耗低，耐用等优点而使之得到广泛的应用， CMOS 反相器是组成集成电路最基本的单元之一。它是由一个增强型 PMOS 管为负载和一个增强型 NMOS 管为驱动管串接而成，图9为orcad 软件中非门电路符号，图10为其 CMOS反相器电路图。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619074500271-b2aaf220-4042-45d1-8560-26a216a6efe9.png#clientId=u6ece1c38-457f-4&from=paste&height=300&id=u68d411e0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=300&originWidth=537&originalType=binary&size=31962&status=done&style=none&taskId=ud8769c03-5608-437c-893a-9f635d02fc1&width=537" alt="image.png"><br>根据上一节的基础MOS管的版图设计，我们可以很容易设计出反相器的版图（图11）<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619074528642-0e5e2247-183e-4288-b837-8d5361d1f296.png#clientId=u6ece1c38-457f-4&from=paste&height=527&id=u351dfd6f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=527&originWidth=463&originalType=binary&size=131810&status=done&style=none&taskId=u85b5a57d-8480-465d-9242-ba0b5dcae84&width=463" alt="image.png"></p>
<h3 id="与非门电路"><a href="#与非门电路" class="headerlink" title="与非门电路"></a>与非门电路</h3><p>与非门（图12）的设计和非门相似，首先根据与非门的电路图（图13）设计版图（图14），然后在进行简单的DRC检查，在调整布局，使其对称就可以得出电路实现与非的功能。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619074563623-f2ee9cc8-e81b-4fce-ae6d-121073eccd8c.png#clientId=u6ece1c38-457f-4&from=paste&height=352&id=uc0ef4633&margin=%5Bobject%20Object%5D&name=image.png&originHeight=352&originWidth=572&originalType=binary&size=43545&status=done&style=none&taskId=u9ebb1445-9352-41f3-9ac8-ef3996cce95&width=572" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619074574551-03f97380-1d58-4d34-aa7c-5f2dbd9e14c5.png#clientId=u6ece1c38-457f-4&from=paste&height=481&id=u748a8258&margin=%5Bobject%20Object%5D&name=image.png&originHeight=481&originWidth=499&originalType=binary&size=226248&status=done&style=none&taskId=u79511bd1-25c8-4a71-b2cd-76093529519&width=499" alt="image.png"></p>
<h3 id="JK触发器电路"><a href="#JK触发器电路" class="headerlink" title="JK触发器电路"></a>JK触发器电路</h3><p>从图15 主从 JK 触发器的原理图可知， 该触发器由 10 个与非门电路和一个非门电路组成，将10个与非门电路和1个非门电路用orcad软件中的MOS管代替，并绘制出来，并且对其进行仿真，将得到如图16所示的电路原理图。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619074611224-67ab552d-e9a7-4f07-b78b-be24e0c17741.png#clientId=u6ece1c38-457f-4&from=paste&height=487&id=ubcd27926&margin=%5Bobject%20Object%5D&name=image.png&originHeight=487&originWidth=693&originalType=binary&size=134738&status=done&style=none&taskId=u5944cbfb-1a4b-4de6-9300-9f67f210e66&width=693" alt="image.png"><br>通过 图15的原理图， 我们将10个与非门电路的版图和一个非门电路的版图进行合理布局、连线，再进行 DRC 验证，将可初步完成版图的设计。值得注意的是，在绘制每一个 MOS 管的时候，都要知道 MOS 管的各个参数，特别是栅长和栅宽，用以确定 poly 层的面积大小。最初绘制的主从 JK 触发器版图电路如下图16所示</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619074641561-21dd3cc7-dbd5-4263-8b34-5cd2a6c76195.png#clientId=u6ece1c38-457f-4&from=paste&height=636&id=u30b47999&margin=%5Bobject%20Object%5D&name=image.png&originHeight=636&originWidth=551&originalType=binary&size=296976&status=done&style=none&taskId=u1577bec4-2ca6-4c97-a850-03ac0c3f0a3&width=551" alt="image.png"></p>
<h1 id="版图设计参数分析"><a href="#版图设计参数分析" class="headerlink" title="版图设计参数分析"></a>版图设计参数分析</h1><p>因为版图设计受工艺水平的限制，因此首先要遵从DRC规则：<strong>最小宽度为3um即封闭几何图形的内边与外边的最小距离；最小间距3um即几何图形外边界之间的最小距离</strong>。另外在设计PMOS和NMOS时，由于电子和空穴的迁移率不同，因此要加大PMOS的尺寸以及掺杂浓度，以保证器件的速率以及电气属性达到一个平衡，在本次版图设计中选取PMOS的集电极尺寸是NMOS的两倍左右，接触孔的位置也应带在器件的中间，以达到对称的效果，否则会因为接触孔的位置而改变，对称元器件尺寸相同，方向一致，否则会有横向效应引起期间的不匹配。</p>
<h1 id="电路布局问题及改进"><a href="#电路布局问题及改进" class="headerlink" title="电路布局问题及改进"></a>电路布局问题及改进</h1><p>版图最开始画的时候，只是在理论上完成了电气连接的功能，版图设计十分松散，衔接距离过大，器件摆放随意，对此问题肯定要重新布局，尽量将等电位点从新连接，为此首先应该梳理器件的种类，将其对称摆布，以抵消信号的延迟、散热不均、电场干扰等问题，在理论上还应该考虑大功率器件散热问题，因此大功率散热器件分布一定要对称，以免局部过热。布局对称后，然后将电位相等的部分尽量减小衔接距离，这样可以尽可能减少电阻的存在，让器件的运行速度更快。<br>本次版图的设计较为基础所用的版图也十分普通，在灵敏度上表现不是那么良好，因此，在此提出改进意见，在电路埋层部分可以加深，解决低温灵敏度不高的问题，另外也可以将普通三极管用肖特基钳位三极管来代替，这样三极管通断的速率将会更快，尤其是对于高频率时钟信号可以有更出色的表现。<br>对于电路中的气驱动作用的三极管来说，可以将原本的结构改成梳状结构，这样可以提高管子的额定功率，减小烧毁的概率，提高管子的可靠性，另外明显增大开关瞬间的电流增益，大大改善了电路的带负载能力。CMOS中的PMOS管子虽然不带负载，但是作为图腾柱结构的一部分，在基极和地之间增加一个二极管可以有效的保护电路，同时在泄放的时候也可以加快速率。<br>在改进的过程中也应该不断进行DRC检查，以免布局布线发生错误，尤其是在金属连接处，好多接触孔无法看到，容易发生混淆，因此实时DRC检查是十分必要的。</p>
<h1 id="总结及心得"><a href="#总结及心得" class="headerlink" title="总结及心得"></a>总结及心得</h1><p>通过对JK触发器的版图设计，不仅对软件的流程熟悉了许多，更重要的是对电路以及版图和电路之间的联系有了深刻的认识，基本器件的绘制已经掌握，集成电路中，元器件都比较抽象，设计一定要仔细，随意的一个掺杂就可能多一两个PN结，是将电路原理图和工艺相结合的纽带，版图的布局布线也是设计中的难点，合理的布线不仅能够提升器件的速度，还能延长器件的寿命，总之，从本次的设计中学习到了许多。</p>
]]></content>
      <categories>
        <category>项目篇</category>
      </categories>
      <tags>
        <tag>版图</tag>
        <tag>数字</tag>
      </tags>
  </entry>
  <entry>
    <title>聪明的学习Vim（下）</title>
    <url>/2020/05/21/%E8%81%AA%E6%98%8E%E7%9A%84%E5%AD%A6%E4%B9%A0Vim%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇文章转载的GitHub上一个很火的项目<br><a href="https://github.com/iggredible/Learn-Vim">英文版本</a></p>
<h1 id="全局命令"><a href="#全局命令" class="headerlink" title="全局命令"></a>全局命令</h1><p>到目前为止，您已经了解了如何使用点命令(<code>.</code>)重复上一次更改，如何使用宏(<code>q</code>)重播动作以及将文本存储在寄存器中(<code>&quot;</code>)。</p>
<p>在本章中，您将学习如何在全局命令中重复命令行命令。运行一次，应用于任何地方（在缓冲区中）。</p>
<h2 id="全局命令概述"><a href="#全局命令概述" class="headerlink" title="全局命令概述"></a>全局命令概述</h2><p>Vim的全局命令用于同时在多行上运行命令行命令。</p>
<p>顺便说一句，您之前可能已经听说过“ Ex命令”一词。在本书中，我将它们称为命令行命令，但Ex命令和命令行命令是相同的。它们是以冒号（<code>:</code>）开头的命令。在上一章中，您了解了替代命令。这是一个Ex命令的示例。它们之所以称为Ex，是因为它们最初来自Ex文本编辑器。在本书中，我将继续将它们称为命令行命令。有关Ex命令的完整列表，请查看<code>:h ex-cmd-index</code>。</p>
<p>全局命令具有以下语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:g/pattern/command</span><br></pre></td></tr></table></figure>


<p><code>pattern</code>匹配包含该模式的所有行，类似于替代命令中的模式。<code>command</code>可以是任何命令行命令。全局命令通过对与<code>pattern</code>匹配的每一行执行<code>command</code>来工作。</p>
<p>如果您具有以下表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const one = 1;</span><br><span class="line">console.log(&quot;one: &quot;, one);</span><br><span class="line"></span><br><span class="line">const two = 2;</span><br><span class="line">console.log(&quot;two: &quot;, two);</span><br><span class="line"></span><br><span class="line">const three = 3;</span><br><span class="line">console.log(&quot;three: &quot;, three);</span><br></pre></td></tr></table></figure>


<p>要删除所有包含“控制台”的行，可以运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:g/console/d</span><br></pre></td></tr></table></figure>


<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const one = 1;</span><br><span class="line"></span><br><span class="line">const two = 2;</span><br><span class="line"></span><br><span class="line">const three = 3;</span><br></pre></td></tr></table></figure>


<p>全局命令在与“控制台”模式匹配的所有行上执行删除命令(<code>d</code>)。</p>
<p>运行<code>g</code>命令时，Vim对文件进行两次扫描。在第一次运行时，它将扫描每行并标记与<code>/console/</code>模式匹配的行。一旦所有匹配的行都被标记，它将进行第二次运行，并在标记的行上执行d命令。</p>
<p>如果要删除所有包含“const”的行，请运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:g/const/d</span><br></pre></td></tr></table></figure>


<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(&quot;one: &quot;, one);</span><br><span class="line"></span><br><span class="line">console.log(&quot;two: &quot;, two);</span><br><span class="line"></span><br><span class="line">console.log(&quot;three: &quot;, three);</span><br></pre></td></tr></table></figure>


<h2 id="逆向比赛"><a href="#逆向比赛" class="headerlink" title="逆向比赛"></a>逆向比赛</h2><p>要在不匹配的行上运行全局命令，可以运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:g!/&#123;pattern&#125;/&#123;command&#125;</span><br></pre></td></tr></table></figure>


<p>要么</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:v/&#123;pattern&#125;/&#123;command&#125;</span><br></pre></td></tr></table></figure>


<p>如果运行<code>:v/console/d</code>，它将删除_不_包含“console”的所有行。</p>
<h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><p>全局命令使用与替代命令相同的模式系统，因此本节将作为更新。随意跳到下一部分或继续阅读！</p>
<p>如果您具有以下表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const one = 1;</span><br><span class="line">console.log(&quot;one: &quot;, one);</span><br><span class="line"></span><br><span class="line">const two = 2;</span><br><span class="line">console.log(&quot;two: &quot;, two);</span><br><span class="line"></span><br><span class="line">const three = 3;</span><br><span class="line">console.log(&quot;three: &quot;, three);</span><br></pre></td></tr></table></figure>


<p>要删除包含“one”或“two”的行，请运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:g/one\|two/d</span><br></pre></td></tr></table></figure>


<p>要删除包含任何一位数字的行，请运行以下任一命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:g/[0-9]/d</span><br></pre></td></tr></table></figure>


<p>要么</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:g/\d/d</span><br></pre></td></tr></table></figure>


<p>如果您有表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const oneMillion = 1000000;</span><br><span class="line">const oneThousand = 1000;</span><br><span class="line">const one = 1;</span><br></pre></td></tr></table></figure>


<p>要匹配包含三到六个零的行，请运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:g/0\&#123;3,6\&#125;/d</span><br></pre></td></tr></table></figure>


<h2 id="传递范围"><a href="#传递范围" class="headerlink" title="传递范围"></a>传递范围</h2><p>您可以在<code>g</code>命令之前传递一个范围。您可以通过以下几种方法来做到这一点：</p>
<ul>
<li><code>:1,5/g/console/d</code>  在第1行和第5行之间匹配字符串”console”并将其删除。</li>
<li><code>:,5/g/console/d</code> 如果逗号前没有地址，则从当前行开始。它在当前行和第5行之间寻找字符串”console”并将其删除。</li>
<li><code>:3,/g/console/d</code> 如果逗号后没有地址，则在当前行结束。它在第3行和当前行之间寻找字符串”console”并将其删除。</li>
<li><code>:3g/console/d</code> 如果只传递一个地址而不带逗号，则仅在第3行执行命令。在第3行查找，如果字符串为”console”，则将其删除。</li>
</ul>
<p>除了数字，您还可以将这些符号用作范围：</p>
<ul>
<li><code>.</code> 表示当前行。范围<code>.,3</code>表示当前行和第3行之间。</li>
<li><code>$</code> 表示文件的最后一行。 <code>3,$</code>范围表示在第3行和最后一行之间。</li>
<li><code>+n</code> 表示当前行之后的n行。您可以将其与<code>.</code>结合使用，也可以不结合使用。  <code>3,+1</code>或<code>3,.+1</code>表示在第3行和当前行之后的行之间。</li>
</ul>
<p>如果您不给它任何范围，默认情况下它将影响整个文件。这实际上不是常态。如果您不传递任何范围，Vim的大多数命令行命令仅在当前行上运行。两个值得注意的例外是全局(<code>:g</code>)和save(<code>:w</code>)命令。</p>
<h2 id="普通命令"><a href="#普通命令" class="headerlink" title="普通命令"></a>普通命令</h2><p>您可以将全局命令和<code>:normal</code>命令行命令一起运行。</p>
<p>如果您有以下文字：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const one = 1;</span><br><span class="line">console.log(&quot;one: &quot;, one);</span><br><span class="line"></span><br><span class="line">const two = 2;</span><br><span class="line">console.log(&quot;two: &quot;, two);</span><br><span class="line"></span><br><span class="line">const three = 3;</span><br><span class="line">console.log(&quot;three: &quot;, three);</span><br></pre></td></tr></table></figure>


<p>要添加”;”运行到每一行的末尾：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:g/./normal A;</span><br></pre></td></tr></table></figure>


<p>让我们分解一下：</p>
<ul>
<li><code>:g</code> 是全局命令。</li>
<li><code>/./</code> 是“非空行”的模式。回想一下正则表达式中的点（<code>.</code>）表示_任何字符_。它将行与至少一个字符匹配，因此将行与“const”和“console”匹配。它不匹配空行。</li>
<li><code>normal A;</code> 运行<code>:normal</code>命令行命令。 <code>A;</code> 是普通模式命令，用于在该行的末尾插入”;”。</li>
</ul>
<h2 id="执行宏"><a href="#执行宏" class="headerlink" title="执行宏"></a>执行宏</h2><p>您也可以使用全局命令执行宏。宏只是普通模式下的操作，因此可以使用<code>:normal</code>来执行宏。如果您有以下表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const one = 1</span><br><span class="line">console.log(&quot;one: &quot;, one);</span><br><span class="line"></span><br><span class="line">const two = 2</span><br><span class="line">console.log(&quot;two: &quot;, two);</span><br><span class="line"></span><br><span class="line">const three = 3</span><br><span class="line">console.log(&quot;three: &quot;, three);</span><br></pre></td></tr></table></figure>


<p>请注意，带有”const”的行没有分号。让我们创建一个宏，以在寄存器”a”的这些行的末尾添加逗号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qa0A;&lt;esc&gt;q</span><br></pre></td></tr></table></figure>


<p>如果您需要复习，请查看有关宏的章节。现在运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:g/const/normal @a</span><br></pre></td></tr></table></figure>


<p>现在，所有带有”const”的行都将带有”;”在末尾。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const one = 1;</span><br><span class="line">console.log(&quot;one: &quot;, one);</span><br><span class="line"></span><br><span class="line">const two = 2;</span><br><span class="line">console.log(&quot;two: &quot;, two);</span><br><span class="line"></span><br><span class="line">const three = 3;</span><br><span class="line">console.log(&quot;three: &quot;, three);</span><br></pre></td></tr></table></figure>


<h2 id="递归全局命令"><a href="#递归全局命令" class="headerlink" title="递归全局命令"></a>递归全局命令</h2><p>全局命令本身是命令行命令的一种，因此您可以从技术上在全局命令中运行全局命令。</p>
<p>给定表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const one = 1;</span><br><span class="line">console.log(&quot;one: &quot;, one);</span><br><span class="line"></span><br><span class="line">const two = 2;</span><br><span class="line">console.log(&quot;two: &quot;, two);</span><br><span class="line"></span><br><span class="line">const three = 3;</span><br><span class="line">console.log(&quot;three: &quot;, three);</span><br></pre></td></tr></table></figure>


<p>如果您运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:g/console/g/two/d</span><br></pre></td></tr></table></figure>


<p>首先，“g”将查找包含模式“console”的行，并找到3个匹配项。然后，第二个“g”将从那三个匹配项中查找包含模式“two”的行。最后，它将删除该匹配项。</p>
<p>您也可以将“g”与“v”结合使用以找到正负模式。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:g/console/v/two/d</span><br></pre></td></tr></table></figure>


<p>而不是查找包含模式”two”的行，它将查找_不_包含”two”的行。</p>
<h2 id="更改定界符"><a href="#更改定界符" class="headerlink" title="更改定界符"></a>更改定界符</h2><p>您可以像替代命令一样更改全局命令的定界符。规则是相同的：您可以使用任何单字节字符，但字母，数字，<code>&quot;</code>, <code>|</code>, 和 <code>\</code>除外。</p>
<p>要删除包含”console”的行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:g@console@d</span><br></pre></td></tr></table></figure>


<p>如果在全局命令中使用替代命令，则可以有两个不同的定界符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g@one@s+const+let+g</span><br></pre></td></tr></table></figure>


<p>此处，全局命令将查找包含“one”的所有行。 替换命令将从这些匹配项中将字符串”const”替换为”let”。</p>
<h2 id="默认命令"><a href="#默认命令" class="headerlink" title="默认命令"></a>默认命令</h2><p>如果在全局命令中未指定任何命令行命令，会发生什么？</p>
<p>全局命令将使用打印(<code>:p</code>)命令来打印当前行的文本。如果您运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:g/console</span><br></pre></td></tr></table></figure>


<p>它将在屏幕底部打印所有包含”console”的行。</p>
<p>顺便说一下，这是一个有趣的事实。因为全局命令使用的默认命令是<code>p</code>，所以这使<code>g</code>语法为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:g/re/p</span><br></pre></td></tr></table></figure>


<ul>
<li><code>g</code> = 全局命令</li>
<li><code>re</code> = 正则表达式模式</li>
<li><code>p</code> = 打印命令</li>
</ul>
<p>它拼写_”grep”_，与命令行中的<code>grep</code> 相同。但这 <strong>不</strong> 是巧合。 <code>g/re/p</code>命令最初来自第一行文本编辑器之一的Ed编辑器。 <code>grep</code>命令的名称来自Ed。</p>
<p>您的计算机可能仍具有Ed编辑器。从终端运行<code>ed</code>（提示：要退出，请键入<code>q</code>）。</p>
<h2 id="更多示例"><a href="#更多示例" class="headerlink" title="更多示例"></a>更多示例</h2><h3 id="反转整个缓冲区"><a href="#反转整个缓冲区" class="headerlink" title="反转整个缓冲区"></a>反转整个缓冲区</h3><p>要撤消整个文件，请运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:g/^/m 0</span><br></pre></td></tr></table></figure>


<p><code>^</code>是“行的开始”的模式。使用<code>^</code>匹配所有行，包括空行。</p>
<p>如果只需要反转几行，请将其传递一个范围。要将第五行到第十行之间的行反转，请运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:5,10g/^/m 0</span><br></pre></td></tr></table></figure>


<p>要了解有关move命令的更多信息，请查看<code>:h :move</code>。</p>
<h3 id="汇总所有待办事项"><a href="#汇总所有待办事项" class="headerlink" title="汇总所有待办事项"></a>汇总所有待办事项</h3><p>当我编码时，有时我会想到一个随机的绝妙主意。不想失去专注，我通常将它们写在我正在编辑的文件中，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const one = 1;</span><br><span class="line">console.log(&quot;one: &quot;, one);</span><br><span class="line">// TODO: feed the puppy</span><br><span class="line"></span><br><span class="line">const two = 2;</span><br><span class="line">// TODO：自动喂小狗</span><br><span class="line">console.log(&quot;two: &quot;, two);</span><br><span class="line">const three = 3;</span><br><span class="line">console.log(&quot;three: &quot;, three);</span><br><span class="line">// TODO：创建一家销售自动小狗喂食器的初创公司</span><br></pre></td></tr></table></figure>


<p>跟踪所有已创建的TODO可能很困难。 Vim有一个<code>:t</code>（copy）方法来将所有匹配项复制到一个地址。要了解有关复制方法的更多信息，请查看<code>:h :copy</code>。</p>
<p>要将所有TODO复制到文件末尾以便于自省，请运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:g/TODO/t $</span><br></pre></td></tr></table></figure>


<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const one = 1;</span><br><span class="line">console.log(&quot;one: &quot;, one);</span><br><span class="line">// TODO：喂小狗</span><br><span class="line"></span><br><span class="line">const two = 2;</span><br><span class="line">// TODO：自动喂小狗</span><br><span class="line">console.log(&quot;two: &quot;, two);</span><br><span class="line"></span><br><span class="line">const three = 3;</span><br><span class="line">console.log(&quot;three: &quot;, three);</span><br><span class="line">// TODO：创建一家销售自动小狗喂食器的初创公司</span><br><span class="line"></span><br><span class="line">// TODO：喂小狗</span><br><span class="line">// TODO：自动喂小狗</span><br><span class="line">// TODO：创建一家销售自动小狗喂食器的初创公司</span><br></pre></td></tr></table></figure>


<p>现在，我可以查看我创建的所有TODO，找到时间来完成它们或将它们委托给其他人，然后继续执行下一个任务。</p>
<p>另一种选择是使用<code>m</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:g/TODO/m $</span><br></pre></td></tr></table></figure>


<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const one = 1;</span><br><span class="line">console.log(&quot;one: &quot;, one);</span><br><span class="line"></span><br><span class="line">const two = 2;</span><br><span class="line">console.log(&quot;two: &quot;, two);</span><br><span class="line"></span><br><span class="line">const three = 3;</span><br><span class="line">console.log(&quot;three: &quot;, three);</span><br><span class="line"></span><br><span class="line">// TODO：喂小狗</span><br><span class="line">// TODO：自动喂小狗</span><br><span class="line">// TODO：创建一家销售自动小狗喂食器的初创公司</span><br></pre></td></tr></table></figure>


<p>一旦决定要删除列表，就可以删除它。</p>
<h3 id="黑洞删除"><a href="#黑洞删除" class="headerlink" title="黑洞删除"></a>黑洞删除</h3><p>从寄存器一章回想一下，已删除的文本存储在已编号的寄存器中（允许它们足够大）。每当运行<code>:g/console/d</code>时，Vim都会将删除的行存储在编号寄存器中。如果删除许多行，则可以快速填充所有编号的寄存器。为了避免这种情况，您始终可以使用黑洞寄存器（<code>“ _</code>）_不_将删除的行存储到寄存器中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:g/console/d _</span><br></pre></td></tr></table></figure>


<p>通过在<code>d</code>之后传递<code>_</code>，Vim不会将删除的行保存到任何寄存器中。</p>
<h3 id="将多条空行减少为一条空行"><a href="#将多条空行减少为一条空行" class="headerlink" title="将多条空行减少为一条空行"></a>将多条空行减少为一条空行</h3><p>如果您的文件带有多个空行，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const one = 1;</span><br><span class="line">console.log(&quot;one: &quot;, one);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const two = 2;</span><br><span class="line">console.log(&quot;two: &quot;, two);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const three = 3;</span><br><span class="line">console.log(&quot;three: &quot;, three);</span><br></pre></td></tr></table></figure>


<p>您可以快速将每条长长的空行减少为一条空行。运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:g/^$/,/./-1j</span><br></pre></td></tr></table></figure>


<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const one = 1;</span><br><span class="line">console.log(&quot;one: &quot;, one);</span><br><span class="line"></span><br><span class="line">const two = 2;</span><br><span class="line">console.log(&quot;two: &quot;, two);</span><br><span class="line"></span><br><span class="line">const three = 3;</span><br><span class="line">console.log(&quot;three: &quot;, three);</span><br></pre></td></tr></table></figure>


<p>让我们分解一下：</p>
<ul>
<li><code>:g</code> 是全局命令</li>
<li><code>/^$/</code> 是空行的模式。回想一下，<code>^</code>表示行的开始，<code>$</code>表示行的结束。 <code>^ $</code>匹配一个空行（一个零字符长的行）。</li>
<li><code>,/./-1</code>  是<code>j</code>命令的范围。由于您没有传递起始范围的值，因此它从当前行开始。您之前已经了解到<code>/./</code>是非空行的模式。 <code>,/./</code>是从当前行到下一个非空行的范围。全局命令的范围<code>/^$/</code>会将您带到<code>console.log(&quot;one: &quot;, one);</code>下面的第一行。这是当前行。 <code>/./</code> 匹配第一条非空行，即<code>const two = 2;</code>行。最后，<code>-1</code>将其偏移一行。第一次匹配的有效范围是<code>console.log(&quot;one: &quot;, one);</code>下方的空行和<code>const two = 2;</code>上方的空行。</li>
<li><code>j</code> 是连接命令<code>:j</code>。您可以加入所有作为其范围的行。例如，<code>:1,5j</code>连接第一到第五行。<br>请注意，您正在<code>j</code>命令之前传递范围(<code>,/./-1</code>)。仅仅因为您在全局命令中使用了命令行命令，并不意味着您不能给它一个范围。在这段代码中，您将传递给<code>j</code>命令自己的范围来执行。您可以在执行全局命令时将范围传递给任何命令。</li>
</ul>
<p>顺便说一句，如果您想将多条空行减少为无行，而不是将<code>,/./-1</code> 用作<code>j</code>命令的范围，只需使用<code>,/./</code>作为范围：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:g/^$/,/./j</span><br></pre></td></tr></table></figure>


<p>或更简单：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:g/^$/-j</span><br></pre></td></tr></table></figure>


<p>您的文字现在减少为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const one = 1;</span><br><span class="line">console.log(&quot;one: &quot;, one);</span><br><span class="line">const two = 2;</span><br><span class="line">console.log(&quot;two: &quot;, two);</span><br><span class="line">const three = 3;</span><br><span class="line">console.log(&quot;three: &quot;, three);</span><br></pre></td></tr></table></figure>


<h3 id="高级排序"><a href="#高级排序" class="headerlink" title="高级排序"></a>高级排序</h3><p>Vim有一个<code>:sort</code>命令来对一个范围内的行进行排序。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d</span><br><span class="line">b</span><br><span class="line">a</span><br><span class="line">e</span><br><span class="line">c</span><br></pre></td></tr></table></figure>


<p>您可以通过运行<code>:sort</code>对它们进行排序。如果给它一个范围，它将只对该范围内的行进行排序。例如，<code>:3,5sort</code>仅在第三和第五行之间排序。</p>
<p>如果您具有以下表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arrayB = [</span><br><span class="line">  &quot;i&quot;,</span><br><span class="line">  &quot;g&quot;,</span><br><span class="line">  &quot;h&quot;,</span><br><span class="line">  &quot;b&quot;,</span><br><span class="line">  &quot;f&quot;,</span><br><span class="line">  &quot;d&quot;,</span><br><span class="line">  &quot;e&quot;,</span><br><span class="line">  &quot;c&quot;,</span><br><span class="line">  &quot;a&quot;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">const arrayA = [</span><br><span class="line">  &quot;h&quot;,</span><br><span class="line">  &quot;b&quot;,</span><br><span class="line">  &quot;f&quot;,</span><br><span class="line">  &quot;d&quot;,</span><br><span class="line">  &quot;e&quot;,</span><br><span class="line">  &quot;a&quot;,</span><br><span class="line">  &quot;c&quot;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>


<p>如果需要排序数组中的元素，而不是数组本身，可以运行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:g/\[/+1,/\]/-1sort</span><br></pre></td></tr></table></figure>


<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arrayB = [</span><br><span class="line">  &quot;a&quot;,</span><br><span class="line">  &quot;b&quot;,</span><br><span class="line">  &quot;c&quot;,</span><br><span class="line">  &quot;d&quot;,</span><br><span class="line">  &quot;e&quot;,</span><br><span class="line">  &quot;f&quot;,</span><br><span class="line">  &quot;g&quot;,</span><br><span class="line">  &quot;h&quot;,</span><br><span class="line">  &quot;i&quot;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">const arrayA = [</span><br><span class="line">  &quot;a&quot;</span><br><span class="line">  &quot;b&quot;,</span><br><span class="line">  &quot;c&quot;,</span><br><span class="line">  &quot;d&quot;,</span><br><span class="line">  &quot;e&quot;,</span><br><span class="line">  &quot;f&quot;,</span><br><span class="line">  &quot;h&quot;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>


<p>这很棒！但是命令看起来很复杂。让我们分解一下。该命令包含三个主要部分：全局命令模式，排序命令范围和排序命令。</p>
<p><code>:g/\[/</code> 是全局命令模式。</p>
<ul>
<li><code>:g</code> 是全局命令。</li>
<li><code>/\[/</code> 是全局命令使用的模式。 <code>\[</code>查找文字”[“字符串。</li>
</ul>
<p><code>+1,/\]/-1</code>  是排序命令的范围。</p>
<ul>
<li>范围可以有开始和结束地址。在这种情况下，<code>+1</code>是起始地址，<code>/\]/-1</code>是结束地址。</li>
<li><code>+1</code> 表示当前行之后的行，这是与全局命令中的模式“ [”匹配的行。 “ +1”将当前行偏移一行。因此，在第一个匹配项中，范围实际上是在<code>const arrayB = [</code>文本_之后_的一行。</li>
<li><code>/\]/-1</code> 是结束地址。 <code>\]</code>代表一个文字的右方括号“]”。 <code>-1</code>将其偏移一行。结束地址是”]”上方的行。</li>
</ul>
<p><code>sort</code>是sort命令行命令。它对给定范围内的所有内容进行排序。 “[“到上方的行”]”之后的所有内容均已排序。</p>
<p>如果您仍然对该命令感到困惑，请不要担心。我花了很长时间才掌握它。稍事休息，离开屏幕，然后重新思考。</p>
<h2 id="聪明地学习全局命令"><a href="#聪明地学习全局命令" class="headerlink" title="聪明地学习全局命令"></a>聪明地学习全局命令</h2><p>全局命令针对所有匹配的行执行命令行命令。有了它，您只需要运行一次命令，Vim就会为您完成其余的工作。要精通全局命令，需要做两件事：良好的命令行命令词汇表和正则表达式知识。随着您花费更多的时间使用Vim，您自然会学到更多的命令行命令。正则表达式知识将需要更积极的方法。但是，一旦您对正则表达式感到满意，您将领先于很多。</p>
<p>这里的一些例子很复杂。不要被吓到。真是花时间了解它们。学习阅读模式。确保您知道每个命令中的每个字母代表什么。不要放弃。</p>
<p>每当需要在多个位置应用命令时，请暂停并查看是否可以使用<code>g</code>命令。寻找最适合工作的命令，并编写一个模式以同时定位多个目标。然后重复执行此操作，直到您无需考虑即可进行操作。下次，看看是否有更快，更有效的方法。</p>
<p>既然您已经知道全局命令的功能强大，那么让我们学习如何使用外部命令来增加工具库。</p>
<h1 id="外部命令"><a href="#外部命令" class="headerlink" title="外部命令"></a>外部命令</h1><p>在Unix系统内部，您会发现许多小型的，超专业化命令，每个命令都能很好地完成一件事情。您可以将这些命令链接在一起以共同解决一个复杂的问题。如果可以从Vim内部使用这些命令，那不是很好吗？</p>
<p>在本章中，您将学习如何扩展Vim以使其与外部命令无缝协作。</p>
<h2 id="Bang-命令"><a href="#Bang-命令" class="headerlink" title="Bang 命令"></a>Bang 命令</h2><p>Vim有一个Bang(<code>!</code>)命令，可以执行三件事：</p>
<p>1.将外部命令的STDOUT读入当前缓冲区。<br>2.将缓冲区的内容作为STDIN写入外部命令。<br>3.从Vim内部执行外部命令。</p>
<h2 id="将STDOUT作为命令读入Vim"><a href="#将STDOUT作为命令读入Vim" class="headerlink" title="将STDOUT作为命令读入Vim"></a>将STDOUT作为命令读入Vim</h2><p>将外部命令的STDOUT读入当前缓冲区的语法为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:r !&#123;cmd&#125;</span><br></pre></td></tr></table></figure>


<p><code>:r</code>是Vim的读命令。如果不带<code>!</code>使用它，则可以使用它来获取文件的内容。如果当前目录中有文件<code>file1.txt</code>并运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:r file1.txt</span><br></pre></td></tr></table></figure>


<p>Vim会将<code>file1.txt</code>的内容放入当前缓冲区。</p>
<p>如果您运行<code>:r</code>命令，然后再执行<code>!</code>和外部命令，则该命令的输出将插入到当前缓冲区中。要获取<code>ls</code>命令的结果，请运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:r !ls</span><br></pre></td></tr></table></figure>


<p>它返回类似：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file1.txt</span><br><span class="line">file2.txt</span><br><span class="line">file3.txt</span><br></pre></td></tr></table></figure>


<p>您可以从<code>curl</code>命令读取数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:r !curl -s &#x27;https://jsonplaceholder.typicode.com/todos/1&#x27;</span><br></pre></td></tr></table></figure>


<p>r命令也接受一个地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:10r !cat file1.txt</span><br></pre></td></tr></table></figure>


<p>现在，将在第10行之后插入来自运行<code>cat file.txt</code>的STDOUT。</p>
<h2 id="将缓冲区内容写入外部命令"><a href="#将缓冲区内容写入外部命令" class="headerlink" title="将缓冲区内容写入外部命令"></a>将缓冲区内容写入外部命令</h2><p>除了保存文件，您还可以使用写命令(<code>:w</code>)将当前缓冲区中的文本作为STDIN传递给外部命令。语法为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:w !cmd</span><br></pre></td></tr></table></figure>


<p>如果您具有以下表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(&quot;Hello Vim&quot;);</span><br><span class="line">console.log(&quot;Vim is awesome&quot;);</span><br></pre></td></tr></table></figure>


<p>确保在计算机中安装了<a href="https://nodejs.org/en/">node</a>，然后运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:w !node</span><br></pre></td></tr></table></figure>


<p>Vim将使用<code>node</code>执行Javascript表达式来打印“ Hello Vim”和“Vim is awesome”。</p>
<p>当使用<code>：w</code>命令时，Vim使用当前缓冲区中的所有文本，与global命令类似（大多数命令行命令，如果不给它传递范围，则仅对当前行执行该命令）。如果您通过<code>：w</code>来指定地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:2w !node</span><br></pre></td></tr></table></figure>


<p>Vim只使用第二行中的文本到<code>node</code>解释器中。</p>
<p><code>:w !node</code>和<code>:w! node</code>之间有一个细微但重要的区别。节点<code>。使用</code>:w !node<code>，您可以将当前缓冲区中的文本“写入”到外部命令</code>node<code>中。用</code>:w! node`，则您将强制保存文件并将其命名为”node”。</p>
<h2 id="执行外部命令"><a href="#执行外部命令" class="headerlink" title="执行外部命令"></a>执行外部命令</h2><p>您可以使用bang命令从Vim内部执行外部命令。语法为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:!cmd</span><br></pre></td></tr></table></figure>


<p>要以长格式查看当前目录的内容，请运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:!ls -ls</span><br></pre></td></tr></table></figure>


<p>要终止在PID 3456上运行的进程，可以运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:!kill -9 3456</span><br></pre></td></tr></table></figure>


<p>您可以在不离开Vim的情况下运行任何外部命令，因此您可以专注于自己的任务。</p>
<h2 id="过滤文字"><a href="#过滤文字" class="headerlink" title="过滤文字"></a>过滤文字</h2><p>如果给<code>!</code>范围，则可用于过滤文本。假设您有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello vim</span><br><span class="line">hello vim</span><br></pre></td></tr></table></figure>


<p>让我们使用<code>tr</code> (translate)命令将当前行大写。运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:.!tr &#x27;[:lower:]&#x27; &#x27;[:upper:]&#x27;</span><br></pre></td></tr></table></figure>


<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HELLO VIM</span><br><span class="line">hello vim</span><br></pre></td></tr></table></figure>


<p>细目：</p>
<ul>
<li><code>.!</code> 在当前行执行filter命令。</li>
<li><code>!tr &#39;[:lower:]&#39; &#39;[:upper:]&#39;</code> 调用<code>tr</code>命令将所有小写字符替换为大写字符。</li>
</ul>
<p>必须传递范围以运行外部命令作为过滤器。如果您尝试在没有<code>.</code>的情况下运行上述命令(<code>:!tr &#39;[:lower:]&#39; &#39;[:upper:]&#39;</code>)，则会看到错误。</p>
<p>假设您需要使用awk命令删除两行的第二列：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:%!awk &quot;&#123;print $1&#125;&quot;</span><br></pre></td></tr></table></figure>


<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>


<p>细目：</p>
<ul>
<li><code>:%!</code>  在所有行上执行filter命令(<code>%</code>)。</li>
<li><code>awk &quot;&#123;print $1&#125;&quot;</code> 仅打印匹配项的第一列。在这种情况下，单词“你好”。</li>
</ul>
<p>您可以使用链运算符（<code>|</code>）链接多个命令，就像在终端中一样。假设您有一个包含这些美味早餐的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name price</span><br><span class="line">chocolate pancake 10</span><br><span class="line">buttermilk pancake 9</span><br><span class="line">blueberry pancake 12</span><br></pre></td></tr></table></figure>


<p>如果您需要根据价格对它们进行排序，并且仅以均匀的间距显示菜单，则可以运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:%!awk &#x27;NR &gt; 1&#x27; | sort -nk 3 | column -t</span><br></pre></td></tr></table></figure>


<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">buttermilk pancake 9</span><br><span class="line">chocolate pancake 10</span><br><span class="line">blueberry pancake 12</span><br></pre></td></tr></table></figure>


<p>细目：</p>
<ul>
<li><code>:%!</code> 将过滤器应用于所有行（％）。</li>
<li><code>awk &#39;NR &gt; 1&#39;</code> 仅从第二行开始显示文本。</li>
<li><code>|</code>链接下一个命令。</li>
<li><code>sort -nk 3</code>使用列3（<code>k 3</code>）中的值对数字进行排序（<code>n</code>）。</li>
<li><code>column -t</code>以均匀的间距组织文本。</li>
</ul>
<h2 id="普通模式命令"><a href="#普通模式命令" class="headerlink" title="普通模式命令"></a>普通模式命令</h2><p>在正常模式下，Vim有一个过滤运算符（<code>!</code>）。如果您有以下问候：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello vim</span><br><span class="line">hola vim</span><br><span class="line">bonjour vim</span><br><span class="line">salve vim</span><br></pre></td></tr></table></figure>


<p>要大写当前行和下面的行，可以运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">!jtr &#x27;[a-z]&#x27; &#x27;[A-Z]&#x27;</span><br></pre></td></tr></table></figure>


<p>细目：</p>
<ul>
<li><code>!j</code> 运行常规命令过滤器运算符（<code>!</code>），目标是当前行及其下方的行。回想一下，因为它是普通模式运算符，所以适用语法规则“动词+名词”。</li>
<li><code>tr &#39;[a-z]&#39; &#39;[A-Z]&#39;</code>将小写字母替换为大写字母。</li>
</ul>
<p>filter normal命令仅适用于至少一行或更长的运动/文本对象。如果您尝试运行<code>!iwtr&#39;[az]&#39;&#39;[AZ]&#39;</code>（在内部单词上执行<code>tr</code>），您会发现它在整个行上都应用了tr命令，而不是光标所在的单词开启。</p>
<h2 id="聪明地学习外部命令"><a href="#聪明地学习外部命令" class="headerlink" title="聪明地学习外部命令"></a>聪明地学习外部命令</h2><p>Vim不是IDE。它是一种轻量级的模式编辑器，通过设计可以高度扩展。由于这种可扩展性，您可以轻松访问系统中的任何外部命令。这样，Vim离成为IDE仅一步之遥。有人说Unix系统是有史以来的第一个IDE。</p>
<p>Bang 命令与您知道多少个外部命令一样有用。如果您的外部命令知识有限，请不要担心。我还有很多东西要学。以此作为持续学习的动力。每当您需要过滤文本时，请查看是否存在可以解决问题的外部命令。不必担心掌握特定命令的所有内容。只需学习完成当前任务所需的内容即可。</p>
<h1 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h1><p>在前三章中，您已经学习了如何使用搜索命令(<code>/</code>, <code>?</code>)、替换命令(<code>:s</code>)、全局命令(<code>:g</code>)，以及外部命令(<code>!</code>)。这些都是命令行模式命令的一些例子。</p>
<p>在本章中，您将学习命令行模式的更多技巧。</p>
<h2 id="进入和退出命令行模式"><a href="#进入和退出命令行模式" class="headerlink" title="进入和退出命令行模式"></a>进入和退出命令行模式</h2><p>命令行模式本身也是一种模式，就像普通模式、输入模式、可视模式一样。在这种模式中，光标将转到屏幕底部，此时您可以输入不同的命令。</p>
<p>有 4 种进入命令行模式的方式：</p>
<ul>
<li>搜索命令 (<code>/</code>, <code>?</code>)</li>
<li>命令行指令 (<code>:</code>)</li>
<li>外部命令 (<code>!</code>)</li>
</ul>
<p>您可以从正常模式或可视模式进入命令行模式。</p>
<p>若要离开命令行模式，您可以使用 <code>&lt;esc&gt;</code>、<code>Ctrl-c</code>、<code>Ctrl-[</code>。</p>
<p><em>有时其他资料可能会将“命令行指令”称为“Ex 命令”，将“外部命令”称为“过滤命令”或者“叹号运算符”。</em></p>
<h2 id="重复上一个命令"><a href="#重复上一个命令" class="headerlink" title="重复上一个命令"></a>重复上一个命令</h2><p>您可以用 <code>@:</code> 来重复上一个命令行指令或外部命令。</p>
<p>如果您刚运行 <code>:s/foo/bar/g</code>，执行 <code>@:</code> 将重复该替换。</p>
<p>如果您刚运行 <code>:.!tr &#39;[a-z]&#39; &#39;[A-Z]&#39;</code>，执行 <code>@:</code> 将重复上一次外部命令转换过滤。</p>
<h2 id="命令行模式快捷键"><a href="#命令行模式快捷键" class="headerlink" title="命令行模式快捷键"></a>命令行模式快捷键</h2><p>在命令行模式中，您可以使用 <code>Left</code> 或 <code>Right</code> 键，来左右移动一个字符。</p>
<p>如果需要移动一个单词，使用 <code>Shift-Left</code> 或 <code>Shift-Right</code> (在某些操作系统中，您需要使用 <code>Ctrl</code> 而不是 <code>Shift</code>)。</p>
<p>使用 <code>Ctrl-b</code>移动到该行的开始，使用 <code>Ctrl-e</code>移动到该行的结束。</p>
<p>和输入模式类似，在命令行模式中，有三种方法可以删除字符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ctrl-h    删除一个字符</span><br><span class="line">Ctrl-w    删除一个单词</span><br><span class="line">Ctrl-u    删除一整行</span><br></pre></td></tr></table></figure>


<p>最后，如果您想像编辑文本文件一样来编辑命令，可以使用 <code>Ctrl-f</code>。</p>
<p>这样还可以查看过往的命令，并在这种“命令行编辑的普通模式”中编辑它们，同时还能按下 <code>Enter</code> 来运行它们。</p>
<h2 id="寄存器和自动补全"><a href="#寄存器和自动补全" class="headerlink" title="寄存器和自动补全"></a>寄存器和自动补全</h2><p>在编程中，只要能使用自动补全，就尽量不要重复输入。这种思想不仅能节省时间，还能减少打错字的可能。</p>
<p>您可以使用 <code>Ctrl-r</code> 来插入 Vim 寄存器中的文本（就和输入模式中的一样）。如果寄存器 “a 中存储着 “foo” 字符串，运行 <code>Ctrl-r a</code> 就可以插入它。输入模式中的寄存器能做到的一切，同样能在命令行模式中做到。</p>
<p>命令也能使用自动补全。例如，要在命令行模式中自动补全 <code>echo</code> 命令，首先输入 “ec”，接着按下 <code>&lt;Tab&gt;</code>，此时您应该能在左下角看到一些 “ec” 开头的 Vim 命令（例如：<code>echo echoerr echohl echomsg econ</code>）。按下 <code>&lt;Tab&gt;</code> 或 <code>Ctrl-n</code> 可以去到下一个选项。按下 <code>&lt;Shift-Tab&gt;</code> 或 <code>Ctrl-p</code> 可以回到上一个选项。</p>
<p>一些命令行指令接受文件名作为参数。<code>edit</code> 就是一个例子。输入 <code>:e</code> 后（不要忘记空格了），按下 <code>&lt;Tab&gt;</code>，Vim 将列出所有相关的文件名。</p>
<h2 id="历史记录窗口"><a href="#历史记录窗口" class="headerlink" title="历史记录窗口"></a>历史记录窗口</h2><p>您可以查看命令行指令和搜索项的历史记录（要确保在运行 <code>vim --version</code> 时，Vim 的编译选项中含有<code>+cmdline_hist</code>）。</p>
<p>运行 <code>:his :</code> 来查看命令行指令的历史记录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##  cmd History</span><br><span class="line">2  e file1.txt</span><br><span class="line">3  g/foo/d</span><br><span class="line">4  s/foo/bar/g</span><br></pre></td></tr></table></figure>


<p>Vim 列出了您运行的所有 <code>:</code> 命令。默认情况下，Vim 存储最后 50 个命令。运行 <code>:set history=100</code> 可以将 Vim 记住的条目总数更改为 100。</p>
<p>在命令行模式中，您可以按下 <code>Up</code> 和 <code>Down</code> 键来遍历此历史记录列表。假设您的命令行指令历史记录如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">51  s/foo/bar/g</span><br><span class="line">52  s/foo/baz/g</span><br><span class="line">53  s/foo//g</span><br></pre></td></tr></table></figure>


<p>按 <code>:</code> 后再按 <code>Up</code>，您可以看到 <code>:s/foo//g</code>。再按 <code>Up</code> 可以看到 <code>:s/foo/baz/g</code>。Vim 向上遍历了历史记录。</p>
<p>类似地，运行 <code>:his /</code> 可以查看搜索记录。运行后，按下<code>Up</code> 或 <code>Down</code>可以遍历此历史记录栈。</p>
<p>Vim 非常聪明，可以区分不同的历史记录。按下<code>:</code>后再按<code>Up</code> 或 <code>Down</code>，Vim 自动显示命令历史记录。按下<code>/</code>后再按<code>Up</code> 或 <code>Down</code>，Vim 自动显示搜索记录。</p>
<h2 id="命令行窗口"><a href="#命令行窗口" class="headerlink" title="命令行窗口"></a>命令行窗口</h2><p>历史记录窗口只能显示过往命令行指令，但无法运行它们。但在命令行窗口中，可以边浏览边执行。有三种命令行窗口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">q:    命令行窗口</span><br><span class="line">q/    向前搜索窗口</span><br><span class="line">q?    向后搜索窗口</span><br></pre></td></tr></table></figure>


<p>运行 <code>q:</code> 来打开命令行窗口。Vim 将在屏幕底部启动一个新窗口。 您可以使用 <code>Up</code> 或<code>Ctrl-p</code> 键向上遍历，使用 <code>Down</code> 或 <code>Ctrl-n</code> 键可以向下遍历。按下 <code>&lt;Return&gt;</code>，Vim 将执行该命令。按下 <code>Ctrl-c</code>、<code>Ctrl-w c</code>、<code>:quit</code> 可以退出命令行窗口。</p>
<p>类似地，运行 <code>q/</code> 可以启动向前搜索命令行窗口，运行 <code>q?</code> 可以启动向后搜索命令行窗口。</p>
<h2 id="聪明地学习命令行模式"><a href="#聪明地学习命令行模式" class="headerlink" title="聪明地学习命令行模式"></a>聪明地学习命令行模式</h2><p>对比其他三种模式，命令行模式就像是文本编辑中的瑞士军刀。寥举几例，您可以编辑文本、修改文件和执行命令。本章是命令行模式的零碎知识的集合。同时，Vim 模式的介绍也走向尾声。现在，您已经知道如何使用普通、输入、可视以及命令行模式，您可以比以往更快地使用 Vim 来编辑文本了。</p>
<p>是时候离开 Vim 模式，来了解如何使用 Vim 标记进行更快的导航了。</p>
<h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><p>快速转到任意定义处，是文本编辑中一个非常有用的特性。在本章中，您将学习如何使用 Vim 标签来做到这一点。</p>
<h2 id="标签概述"><a href="#标签概述" class="headerlink" title="标签概述"></a>标签概述</h2><p>假设有人给了您一个新的代码库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">one = One.new</span><br><span class="line">one.donut</span><br></pre></td></tr></table></figure>


<p><code>One</code>？<code>donut</code>？呃，对于当时编写代码的开发者而言，这些代码的含义可能显而易见。问题是当时的开发者已经不在了，现在要由您来理解这些费解的代码。而跟随有<code>One</code> 和 <code>donut</code>定义的源代码，是帮助您理解的一个有效方法。</p>
<p>您可以使用<code>fzf</code> 或 <code>grep</code>来搜索它们，但使用标签将更快。</p>
<p>把标签想象成地址簿：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Name    Address</span><br><span class="line">Iggy1   1234 Cool St, 11111</span><br><span class="line">Iggy2   9876 Awesome Ave, 2222</span><br></pre></td></tr></table></figure>


<p>当然，标签可不是存储着“姓名-地址”对，而是“定义-地址”对。</p>
<p>假设您在一个目录中有两个 Ruby 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## one.rb</span><br><span class="line">class One</span><br><span class="line">  def initialize</span><br><span class="line">    puts &quot;Initialized&quot;</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  def donut</span><br><span class="line">    puts &quot;Bar&quot;</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>


<p>以及</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## two.rb</span><br><span class="line">require &#x27;./one&#x27;</span><br><span class="line"></span><br><span class="line">one = One.new</span><br><span class="line">one.donut</span><br></pre></td></tr></table></figure>


<p>在普通模式下，您可以使用<code>Ctrl-]</code>跳转到定义。在<code>two.rb</code>中，转到<code>one.donut</code>所在行，将光标移到<code>donut</code>处，按下<code>Ctrl-]</code>。</p>
<p>哦豁，Vim 找不到标签文件，您需要先生成它。</p>
<h2 id="标签生成器"><a href="#标签生成器" class="headerlink" title="标签生成器"></a>标签生成器</h2><p>现代 Vim 不自带标签生成器，您需要额外下载它。有几个选项可供选择：</p>
<ul>
<li>ctags = 仅用于 C，基本随处可见。</li>
<li>exuberant ctags = 最流行的标签生成器之一，支持许多语言。</li>
<li>universal ctags = 和 exuberant ctags 类似，但比它更新。</li>
<li>etags = 用于 Emacs，嗯……</li>
<li>JTags = Java</li>
<li>ptags.py = Python</li>
<li>ptags = Perl</li>
<li>gnatxref = Ada</li>
</ul>
<p>如果您查看 Vim 在线教程，您会发现许多都会推荐 <a href="http://ctags.sourceforge.net/">exuberant ctags</a>，它支持 <a href="http://ctags.sourceforge.net/languages.html">41 种编程语言</a>，我用过它，挺不错的。但自2009年以来一直没有维护，因此 Universal ctags 更好些，它和 exuberant ctags 相似，并仍在维护。</p>
<p>我不打算详细介绍如何安装 Universal ctags，您可以在 <a href="https://github.com/universal-ctags/ctags">universal ctags</a> 仓库了解更多说明。在您安装 universal ctags 后，运行 <code>ctags --version</code>，它会显示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Universal Ctags 0.0.0(b43eb39), Copyright (C) 2015 Universal Ctags Team</span><br><span class="line">Universal Ctags is derived from Exuberant Ctags.</span><br><span class="line">Exuberant Ctags 5.8, Copyright (C) 1996-2009 Darren Hiebert</span><br></pre></td></tr></table></figure>


<p>请确保您看到了 “<code>Universal Ctags</code>“。</p>
<p>接下来，生成一个基本的标签文件。运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctags -R .</span><br></pre></td></tr></table></figure>


<p><code>R</code> 选项告诉 <code>ctags</code> 从当前位置 (<code>.</code>) 递归扫描文件。稍后，您应该在当前文件夹看到一个<code>tags</code> 文件，里面您将看到类似这样的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;&quot; to lines/</span><br><span class="line">!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/</span><br><span class="line">!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/</span><br><span class="line">!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/</span><br><span class="line">!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/</span><br><span class="line">!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//</span><br><span class="line">!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/</span><br><span class="line">!_TAG_PROGRAM_URL	&lt;https://ctags.io/&gt;	/official site/</span><br><span class="line">!_TAG_PROGRAM_VERSION	0.0.0	/b43eb39/</span><br><span class="line">One	one.rb	/^class One$/;&quot;	c</span><br><span class="line">donut	one.rb	/^  def donut$/;&quot;	f	class:One</span><br><span class="line">initialize	one.rb	/^  def initialize$/;&quot;	f	class:One</span><br></pre></td></tr></table></figure>


<p>根据 Vim 设置和 ctag 生成器的不同，您的<code>tags</code> 文件可能会有些不同。一个标签文件由两部分组成：标签元数据和标签列表。那些标签元数据 (<code>!TAG_FILE...</code>) 通常由 ctags 生成器控制。这里我不打算介绍它们，您可以随意查阅文档。</p>
<p>现在回到 <code>two.rb</code>，将光标移至 <code>donut</code>，再输入<code>Ctrl-]</code>，Vim 将带您转到 <code>one.rb</code> 文件里<code>def donut</code> 所在的行上。成功啦！但 Vim 怎么做到的呢？</p>
<h2 id="解剖标签文件"><a href="#解剖标签文件" class="headerlink" title="解剖标签文件"></a>解剖标签文件</h2><p>来看看<code>donut</code> 标签项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">donut	one.rb	/^  def donut$/;&quot;	f	class:One</span><br></pre></td></tr></table></figure>


<p>上面的标签项由四个部分组成：一个<code>tagname</code>、一个<code>tagfile</code>、一个<code>tagaddress</code>，以及标签选项。</p>
<ul>
<li><code>donut</code> 是 <code>tagname</code>。当光标在 “donut” 时，Vim 搜索标签文件里含有 “donut” 字符串的一行。</li>
<li><code>one.rb</code> 是 <code>tagfile</code>。Vim 会搜寻 <code>one.rb</code> 文件。</li>
<li><code>/^ def donut$/</code> 是 <code>tagaddress</code>。<code>/.../</code> 是模式指示器。<code>^</code> 代表一行中第一个元素，后面跟着两个空格，然后是<code>def donut</code>字符串，最后 <code>$</code> 代表一行中最后一个元素。</li>
<li><code>f class:One</code> 是标签选项，它告诉 Vim，<code>donut</code> 是一种函数 (<code>f</code>)，并且是 <code>One</code> 类的一部分。</li>
</ul>
<p>再看看另一个标签项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">One	one.rb	/^class One$/;&quot;	c</span><br></pre></td></tr></table></figure>


<p>这一行也是一样的：</p>
<ul>
<li><code>One</code> 是 <code>tagname</code>。注意，对于标签，第一次扫描区分大小写。如果列表中有 <code>One</code> 和 <code>one</code>， Vim 会优先考虑 <code>One</code> 而不是 <code>one</code>。</li>
<li><code>one.rb</code> 是 <code>tagfile</code>。Vim 会搜寻 <code>one.rb</code> 文件。</li>
<li><code>/^class One$/</code> 是 <code>tagaddress</code> 。Vim 会查找以 <code>class</code> 开头 (<code>^</code>) 、以 <code>One</code> 结尾 (<code>$</code>) 的行。</li>
<li><code>c</code> 是可用标签选项之一。由于 <code>One</code> 是一个 ruby 类而不是过程，因此被标签为 <code>c</code>。</li>
</ul>
<p>标签文件的内容可能不尽相同，根据您使用的标签生成器而定。但至少，标签文件必须具有以下格式之一：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.  &#123;tagname&#125; &#123;TAB&#125; &#123;tagfile&#125; &#123;TAB&#125; &#123;tagaddress&#125;</span><br><span class="line">2.  &#123;tagname&#125; &#123;TAB&#125; &#123;tagfile&#125; &#123;TAB&#125; &#123;tagaddress&#125; &#123;term&#125; &#123;field&#125; ..</span><br></pre></td></tr></table></figure>


<h2 id="标签文件"><a href="#标签文件" class="headerlink" title="标签文件"></a>标签文件</h2><p>您知道，在运行 <code>ctags -R .</code> 后，一个新 <code>tags</code> 文件会被创建。但是，Vim 是如何知道在哪儿查找标签文件的呢？</p>
<p>如果运行 <code>:set tags?</code>，您可能会看见 <code>tags=./tags,tags</code>（根据您的 Vim 设置，内容可能有所不同）。对于 <code>./tags</code>，Vim 会在当前文件所在路径查找所有标签；对于 <code>tags</code>，Vim 会在当前目录（您的项目根路径）中查找。</p>
<p>此外，对于 <code>./tags</code>，Vim 会在当前文件所在路径内查找一个标签文件，无论它被嵌套得有多深。接下来，Vim 会在当前目录（项目根路径）查找。Vim 在找到第一个匹配项后会停止搜索。</p>
<p>如果您的 <code>&#39;tags&#39;</code> 文件是 <code>tags=./tags,tags,/user/iggy/mytags/tags</code>，那么 Vim 在搜索完 <code>./tags</code> 和 <code>tags</code> 目录后，还会在 <code>/user/iggy/mytags</code> 目录内查找。所以您可以分开存放标签文件，不必将它们置于项目文件夹中。</p>
<p>要添加标签文件位置，只需要运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:set tags+=path/to/my/tags/file</span><br></pre></td></tr></table></figure>


<h2 id="为大型项目生成标签："><a href="#为大型项目生成标签：" class="headerlink" title="为大型项目生成标签："></a>为大型项目生成标签：</h2><p>如果您尝试在大型项目中运行 ctag，则可能需要很长时间，因为 Vim 也会查看每个嵌套目录。如果您是 Javascript 开发者，您会知道 <code>node_modules</code> 非常大。假设您有五个子项目，每个都包含自己的 <code>node_modules</code> 目录。一旦运行 <code>ctags -R .</code>，ctags 将尝试扫描这5个 <code>node_modules</code>。但您可能不需要为 <code>node_modules</code> 运行 ctag。</p>
<p>如果要排除 <code>node_modules</code> 后执行 ctags，可以运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctags -R --exclude=node_modules .</span><br></pre></td></tr></table></figure>


<p>这次应该只需要不到一秒钟的时间。另外，您还可以多次使用 <code>exclude</code> 选项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctags -R --exclude=.git --exclude=vendor --exclude=node_modules --exclude=db --exclude=log .</span><br></pre></td></tr></table></figure>


<h2 id="标签导航"><a href="#标签导航" class="headerlink" title="标签导航"></a>标签导航</h2><p>仅使用 <code>Ctrl-]</code> 也挺好，但我们还可以多学几个技巧。其实，标签跳转键 <code>Ctrl-]</code> 还有命令行模式：<code>:tag my-tag</code>。如果您运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:tag donut</span><br></pre></td></tr></table></figure>


<p>Vim 就会跳转至 <code>donut</code> 方法，就像在 “donut” 字符串上按 <code>Ctrl-]</code> 一样。您还可以使用 <code>&lt;Tab&gt;</code> 来自动补全参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:tag d&lt;Tab&gt;</span><br></pre></td></tr></table></figure>


<p>Vim 会列出所有以 “d” 开头的标签。对于上面的命令，结果则是 “donut”。</p>
<p>在实际项目中，您可能会遇到多个同名的方法。我们来更新下这两个文件。先是 <code>one.rb</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## one.rb</span><br><span class="line">class One</span><br><span class="line">  def initialize</span><br><span class="line">    puts &quot;Initialized&quot;</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  def donut</span><br><span class="line">    puts &quot;one donut&quot;</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  def pancake</span><br><span class="line">    puts &quot;one pancake&quot;</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>


<p>然后 <code>two.rb</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## two.rb</span><br><span class="line">require &#x27;./one.rb&#x27;</span><br><span class="line"></span><br><span class="line">def pancake</span><br><span class="line">  &quot;Two pancakes&quot;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">one = One.new</span><br><span class="line">one.donut</span><br><span class="line">puts pancake</span><br></pre></td></tr></table></figure>


<p>由于新添加了一些过程，因此编写完代码后，不要忘记运行 <code>ctags -R .</code>。现在，您有了两个 <code>pancake</code> 过程。如果您在 <code>two.rb</code> 内按下 <code>Ctrl-]</code>，会发生什么呢？</p>
<p>Vim 会跳转到 <code>two.rb</code> 内的 <code>def pancake</code>，而不是 <code>one.rb</code> 的 <code>def pancake</code>。这是因为 Vim 认为 <code>two.rb</code> 内部的 <code>pancake</code> 过程比其他的<code>pancake</code> 过程具有更高优先级。</p>
<h2 id="标签优先级"><a href="#标签优先级" class="headerlink" title="标签优先级"></a>标签优先级</h2><p>并非所有的标签都有着相同的地位。一些标签有着更高的优先级。如果有重复的标签项，Vim 会检查关键词的优先级。顺序是：</p>
<ol>
<li>当前文件中完全匹配的静态标签。</li>
<li>当前文件中完全匹配的全局标签。</li>
<li>其他文件中完全匹配的全局标签。</li>
<li>其他文件中完全匹配的静态标签。</li>
<li>当前文件中不区分大小写匹配的静态标签。</li>
<li>当前文件中不区分大小写匹配的全局标签。</li>
<li>其他文件中区分大小写匹配的全局标签。</li>
<li>当前文件中不区分大小写匹配的静态标签。</li>
</ol>
<p>根据优先级列表，Vim 会对在同一个文件上找到的精确匹配项进行优先级排序。这就是为什么 Vim 会选择 <code>two.rb</code> 里的 <code>pancake</code> 过程而不是 <code>one.rb</code> 里的。但是，上述优先级列表有些例外，取决于您的<code>&#39;tagcase&#39;</code>、<code>&#39;ignorecase&#39;</code>、<code>&#39;smartcase&#39;</code> 设置。我不打算介绍它们，您可以自行查阅 <code>:h tag-priority</code>。</p>
<h2 id="选择性跳转标签"><a href="#选择性跳转标签" class="headerlink" title="选择性跳转标签"></a>选择性跳转标签</h2><p>如果可以选择要跳转到哪个标签，而不是始终转到优先级最高的，那就太好了。因为您可能想跳转到 <code>one.rb</code> 里的 <code>pancake</code> 方法，而不是 <code>two.rb</code> 里的。现在您可以使用 <code>:tselect</code> 做到它！运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:tselect pancake</span><br></pre></td></tr></table></figure>


<p>您可以在屏幕底部看到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## pri kind tag               file</span><br><span class="line">1 F C f    pancake           two.rb</span><br><span class="line">             def pancake</span><br><span class="line">2 F   f    pancake           one.rb</span><br><span class="line">             class:One</span><br><span class="line">             def pancake</span><br></pre></td></tr></table></figure>


<p>如果输入<code>2</code> 后再 <code>&lt;Return&gt;</code>，Vim 将跳转到 <code>one.rb</code> 里的<code>pancake</code> 过程。如果输入<code>1</code> 后再 <code>&lt;Return&gt;</code>，Vim 将跳转到 <code>two.rb</code> 里的。</p>
<p>注意<code>pri</code> 列，第一个匹配中该列是<code>F C</code>，第二个匹配中则是<code>F</code>。这就是 Vim 用来确定标签优先级的凭据。<code>F C</code>表示在当前 (<code>C</code>) 文件中完全匹配 (<code>F</code>) 的全局标签。<code>F</code> 表示仅完全匹配 (<code>F</code>) 的全局标签。<code>F C</code> 的优先级永远比 <code>F</code> 高。<em>（译注：是，是）</em></p>
<p>如果运行<code>:tselect donut</code>，即使只有一个标签可选，Vim 也会提示您选择跳转到哪一个。有没有什么方法可以让 Vim 仅在有多个匹配项时才提示标签列表，而只找到一个标签时就立即跳转呢？</p>
<p>当然！Vim 有一个 <code>:tjump</code> 方法。运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:tjump donut</span><br></pre></td></tr></table></figure>


<p>Vim 将立即跳转到 <code>one.rb</code> 里的<code>donut</code> 过程，就像在运行 <code>:tag donut</code> 一样。现在试试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:tjump pancake</span><br></pre></td></tr></table></figure>


<p>Vim 将提示您从标签选项中选择一个，就像在运行<code>:tselect pancake</code>。<code>tjump</code> 能两全其美。</p>
<p><code>tjump</code> 在普通模式下有一个快捷键：<code>g Ctrl-]</code>。我个人喜欢<code>g Ctrl-]</code>胜过 <code>Ctrl-]</code>。</p>
<h2 id="标签的自动补全"><a href="#标签的自动补全" class="headerlink" title="标签的自动补全"></a>标签的自动补全</h2><p>标签能有助于自动补全。回想下第6章“插入模式”，您可以使用 <code>Ctrl-x</code> 子模式来进行各式自动补全。其中有一个我没有提到过的自动补全子模式便是 <code>Ctrl-]</code>。如果您在插入模式中输入<code>Ctrl-x Ctrl-]</code>，Vim 将使用标签文件来自动补全。</p>
<p>在插入模式下输入<code>Ctrl-x Ctrl-]</code>，您会看到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">One</span><br><span class="line">donut</span><br><span class="line">initialize</span><br><span class="line">pancake</span><br></pre></td></tr></table></figure>


<h2 id="标签堆栈"><a href="#标签堆栈" class="headerlink" title="标签堆栈"></a>标签堆栈</h2><p>Vim 维持着一个标签堆栈，上面记录着所有您从哪儿来、跳哪儿去的标签列表。使用 <code>:tags</code> 可以看到这个堆栈。如果您首先跳转到<code>pancake</code>，紧接着是<code>donut</code>，此时运行<code>:tags</code>，您将看到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  # TO tag         FROM line  in file/text</span><br><span class="line">  1  1 pancake            10  ch16_tags/two.rb</span><br><span class="line">  2  1 donut               9  ch16_tags/two.rb</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>


<p>注意上面的 <code>&gt;</code> 符号，它代表着您当前在堆栈中的位置。要“弹出”堆栈，从而回到上一次的状态，您可以运行<code>:pop</code>。试试它，再运行<code>:tags</code>看看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  # TO tag         FROM line  in file/text</span><br><span class="line">  1  1 pancake            10  puts pancake</span><br><span class="line">&gt; 2  1 donut               9  one.donut</span><br></pre></td></tr></table></figure>


<p>注意现在 <code>&gt;</code> 符号位于 <code>donut</code> 所在的第二行了。再 <code>pop</code> 一次，然后运行<code>:tags</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  # TO tag         FROM line  in file/text</span><br><span class="line">&gt; 1  1 pancake            10  puts pancake</span><br><span class="line">  2  1 donut               9  one.donut</span><br></pre></td></tr></table></figure>


<p>在普通模式下，您可以按下 <code>Ctrl-t</code> 来达到和 <code>:pop</code> 一样的效果。</p>
<h2 id="自动生成标签"><a href="#自动生成标签" class="headerlink" title="自动生成标签"></a>自动生成标签</h2><p>Vim 标签最大的缺点之一是，每当进行重大改变时，您需要重新生成标签文件。如果您将<code>pancake</code> 过程重命名为 <code>waffle</code>，标签文件不知道 <code>pancake</code> 被重命名了，标签列表仍旧存储着 <code>pancake</code> 过程。运行<code>ctags -R .</code> 可以创建更新的标签文件，但这可能会很缓慢。</p>
<p>幸运的是，有几种可以自动生成标签的方法。这一小节不打算介绍一个简单明了的过程，而是提出一些想法，以便您可以扩展它们。</p>
<h2 id="在保存时生成标签"><a href="#在保存时生成标签" class="headerlink" title="在保存时生成标签"></a>在保存时生成标签</h2><p>Vim 有一个自动命令 (<code>autocmd</code>) 方法，可以在触发事件时执行任意命令。您可以使用这个方法，以便在每次保存时生成标签。运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:autocmd BufWritePost *.rb silent !ctags -R .</span><br></pre></td></tr></table></figure>


<p>上面命令的分解如下：</p>
<ul>
<li><code>autocmd</code> 是 Vim 的自动命令方法，它接受一个事件名称、文件和一个命令。</li>
<li><code>BufWritePost</code> 是保存缓冲区时的一个事件。每次保存文件时将触发一次 <code>BufWritePost</code> 事件。</li>
<li><code>.rb</code> 是 ruby (<code>rb</code>) 文件的一种文件模式。</li>
<li><code>silent</code> 是您传递的命令的一部分。如果不输入它，每次触发自动命令时，Vim 都会提示  <code>press ENTER or type command to continue</code>。</li>
<li><code>!ctags -R .</code> 是要执行的命令。回想一下，<code>!cmd</code> 从 Vim 内部执行终端命令。</li>
</ul>
<p>现在，每次您保存一个 ruby 文件时，Vim 都会运行<code>ctags -R .</code>。</p>
<p>在 <code>two.rb</code> 中添加一个新过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def waffle</span><br><span class="line">  &quot;Two waffles&quot;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>


<p>现在保存文件，接着检查一下标签文件，您会在里面看到 <code>waffle</code> 了。成功啦！</p>
<h2 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h2><p>有几种插件可以自动生成 ctags：</p>
<ul>
<li><a href="https://github.com/ludovicchabant/vim-gutentags">vim-gutentags</a></li>
<li><a href="https://github.com/szw/vim-tags">vim-tags</a></li>
<li><a href="https://github.com/xolox/vim-easytags">vim-easytags</a></li>
<li><a href="https://github.com/craigemery/vim-autotag">vim-autotag</a></li>
</ul>
<p>我使用 vim-gutentags。如果您使用了 Vim 插件管理器 (<a href="https://github.com/junegunn/vim-plug">vim-plug</a>, <a href="https://github.com/VundleVim/Vundle.vim">vundle</a>, <a href="https://github.com/Shougo/dein.vim">dein.vim</a>, 等)，只需要直接安装就能工作。</p>
<h2 id="Ctags-以及-Git-钩子"><a href="#Ctags-以及-Git-钩子" class="headerlink" title="Ctags 以及 Git 钩子"></a>Ctags 以及 Git 钩子</h2><p>Tim Pope 是一个写了很多非常棒的 Vim 插件的作者，他写了一篇博客，建议使用 git 钩子。<a href="https://tbaggery.com/2011/08/08/effortless-ctags-with-git.html">可以看一看</a>。</p>
<h2 id="聪明地学习标签"><a href="#聪明地学习标签" class="headerlink" title="聪明地学习标签"></a>聪明地学习标签</h2><p>只要配置得当，标签是非常有用的。如果您像我一样很容易地忘记事情，标签可以帮助您可视化一个项目。</p>
<p>假设在一个新的代码库中，您想要搞清楚 <code>functionFood</code> 干了什么，您可以通过跳转到它的定义来搞懂它们。在那儿可以看到，它又调用了 <code>functionBreakfast</code>。继续跟踪，发现还调用了 <code>functionPancake</code>。现在您明白了，函数调用路径图长这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">functionFood -&gt; functionBreakfast -&gt; functionPancake</span><br></pre></td></tr></table></figure>


<p>进一步可以知道，这段代码和早餐吃煎饼有关。</p>
<p>现在您已经知道如何使用标签，通过 <code>:h tags</code> 可以学习更多有关标签的知识。接下来让我们一起来探索另一个功能：折叠。</p>
<h1 id="折叠"><a href="#折叠" class="headerlink" title="折叠"></a>折叠</h1><p>在阅读文件时，经常会有一些不相关的文本会妨碍您理解。使用 Vim 折叠可以隐藏这些不必要的信息。</p>
<p>本章中，您将学习如何使用不同的折叠方法。</p>
<h2 id="手动折叠"><a href="#手动折叠" class="headerlink" title="手动折叠"></a>手动折叠</h2><p>想象您正在折叠一张纸来覆盖一些文本，实际的文本不会消失，它仍在那儿。Vim 折叠的工作方式与此相同，它_折叠_一段文本，在显示时会隐藏起来，但实际上并不会真的删除它。</p>
<p>折叠操作符是<code>z</code>。折叠纸张时，它看起来也像字母 “z”。</p>
<p>假设有如下文本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fold me</span><br><span class="line">Hold me</span><br></pre></td></tr></table></figure>


<p>输入 <code>zfj</code>。Vim 将这两行折叠成一行，同时会看到类似消息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-- 2 lines: Fold me -----</span><br></pre></td></tr></table></figure>


<p>上面的命令分解如下：</p>
<ul>
<li><code>zf</code> 是折叠操作符。</li>
<li><code>j</code> 是用于折叠操作符的动作。</li>
</ul>
<p>您可以使用 <code>zo</code> 打开/展开已折叠文本，使用 <code>zc</code> 关闭/收缩文本。</p>
<p>Vim 折叠遵循语法规则。您可以在折叠运算符后，加上一个动作或文本对象。例如，使用 <code>zfap</code> 可以折叠外部段落；使用 <code>zfG</code> 可以折叠至文件末尾；使用 <code>zfa&#123;</code> 可以折叠 <code>&#123;</code> 和 <code>&#125;</code> 之间的文本。</p>
<p>您可以在可视模式下进行折叠。高亮您想要折叠的区域后 (<code>v</code>, <code>V</code>, 或 <code>Ctrl-v</code>)，再输入 <code>zf</code> 即可。</p>
<p>一个没有命令行模式版本的 Vim 操作符是不完整的。在命令行模式下，使用 <code>:fold</code> 命令可以执行一次折叠。若要折叠当前行及紧随其后的第二行，可以运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:,+1fold</span><br></pre></td></tr></table></figure>


<p><code>,+1</code> 是要折叠的范围。如果不传递范围参数，默认当前行。<code>+1</code> 是代表下一行的范围指示器。运行 <code>:5,10fold</code> 可以折叠第5至10行。运行 <code>:,$fold</code> 可以折叠当前行至文件末尾。</p>
<p>还有许多其他折叠和展开的命令。我发现他们实在太多，以至于在刚起步时很难记住。最有用的一些命令是：</p>
<ul>
<li><code>zR</code> 展开所有折叠。</li>
<li><code>zM</code> 收缩所有折叠。</li>
<li><code>za</code> 切换折叠状态。</li>
</ul>
<p><code>zR</code> 和 <code>zM</code> 可用于任意行上，但 <code>za</code> 仅能用于已折叠/未折叠的行上。输入 <code>:h fold-commands</code> 可查阅更多有关折叠的指令。</p>
<h2 id="不同的折叠方法"><a href="#不同的折叠方法" class="headerlink" title="不同的折叠方法"></a>不同的折叠方法</h2><p>以上部分涵盖了 Vim 手动折叠的内容。实际上，Vim 有六种不同的折叠方法：</p>
<ol>
<li>手动折叠</li>
<li>缩进折叠</li>
<li>表达式折叠</li>
<li>语法折叠</li>
<li>差异折叠</li>
<li>标志折叠</li>
</ol>
<p>运行 <code>:set foldmethod?</code> 可查看您当前正在使用哪一种折叠方式。默认情况下，Vim 使用手动方式。</p>
<p>在本章的剩余部分，您将学习其他五种折叠方法。让我们从缩进折叠开始。</p>
<h2 id="缩进折叠"><a href="#缩进折叠" class="headerlink" title="缩进折叠"></a>缩进折叠</h2><p>要使用缩进折叠，需要将 <code>&#39;foldmethod&#39;</code> 选项更改为缩进：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:set foldmethod=indent</span><br></pre></td></tr></table></figure>


<p>假设有如下文本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">One</span><br><span class="line">  Two</span><br><span class="line">  Two again</span><br></pre></td></tr></table></figure>


<p>运行 <code>:set foldmethod=indent</code> 后将看到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">One</span><br><span class="line">+-- 2 lines: Two -----</span><br></pre></td></tr></table></figure>


<p>使用缩进折叠后，Vim 将会查看每行的开头有多少空格，并将它与 <code>&#39;shiftwidth&#39;</code> 选项进行比较，以此来决定该行可折叠性。<code>&#39;shiftwidth&#39;</code> 返回每次缩进所需的空格数。如果运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:set shiftwidth?</span><br></pre></td></tr></table></figure>


<p>Vim 的默认 <code>&#39;shiftwidth&#39;</code> 值为2。对于上面的文本而言，”Two” 和 “Two again” 的开头都有两个空格。当 Vim 看到了空格数_且_<code>&#39;shiftwidth&#39;</code>值为2时，Vim 认为该行的缩进折叠级别为1。</p>
<p>假设这次文本开头只有一个空格：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">One</span><br><span class="line"> Two</span><br><span class="line"> Two again</span><br></pre></td></tr></table></figure>


<p>运行 <code>:set foldmethod=indent</code> 后，Vim 不再折叠已缩进的行了，因为这些行没有足够的空格。然而，当您改变 <code>&#39;shiftwidth&#39;</code> 的值为1后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:set shiftwidth=1</span><br></pre></td></tr></table></figure>


<p>文本现在可以折叠了！现在，我们将 <code>&#39;shiftwidth&#39;</code> 以及文本开头的空格数都重新恢复为2后，另外添加一些内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">One</span><br><span class="line">  Two</span><br><span class="line">  Two again</span><br><span class="line">    Three</span><br><span class="line">    Three again</span><br></pre></td></tr></table></figure>


<p>运行折叠命令 (<code>zM</code>) 后可以看到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">One</span><br><span class="line">+-- 4 lines: Two -----</span><br></pre></td></tr></table></figure>


<p>展开已折叠的行 (<code>zR</code>)，接着移动光标至 “Three”，然后切换文本的折叠状态 (<code>za</code>)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">One</span><br><span class="line">  Two</span><br><span class="line">  Two again</span><br><span class="line">+-- 2 lines: Three -----</span><br></pre></td></tr></table></figure>


<p>这是啥？叠中叠？</p>
<p>是的，您可以嵌套折叠。文本 “Two” 和 “Two again” 的折叠级别都为1，文本 “Three” 和 “Three again” 的折叠级别都为2。如果在一段可折叠文本中，具有另一段折叠级别更高的可折叠文本，则可以具有多个折叠层。</p>
<h2 id="标志折叠"><a href="#标志折叠" class="headerlink" title="标志折叠"></a>标志折叠</h2><p>要使用标志折叠，请运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:set foldmethod=marker</span><br></pre></td></tr></table></figure>


<p>假设有如下文本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello</span><br><span class="line"></span><br><span class="line">&#123;&#123;&#123;</span><br><span class="line">world</span><br><span class="line">vim</span><br><span class="line">&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>


<p>输入 <code>zM</code> 后会看到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello</span><br><span class="line"></span><br><span class="line">+-- 4 lines: -----</span><br></pre></td></tr></table></figure>


<p>Vim 将 <code>&#123;&#123;&#123;` 和 `&#125;&#125;&#125;</code> 视为折叠指示器，并折叠其中的内容。使用标志折叠时，Vim 会寻找由 <code>&#39;foldmarker&#39;</code> 选项定义的特殊标志，并标记折叠区域。要查看 Vim 使用的标志，请运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:set foldmarker?</span><br></pre></td></tr></table></figure>


<p>默认情况下，Vim 把 <code>&#123;&#123;&#123;` 和 `&#125;&#125;&#125;</code> 作为指示器。如果您想将指示器更改为其他诸如 “foo1” 或 “foo2” 的字符串，可以运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:set foldmarker=foo1,foo2</span><br></pre></td></tr></table></figure>


<p>假设有如下文本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello</span><br><span class="line"></span><br><span class="line">foo1</span><br><span class="line">world</span><br><span class="line">vim</span><br><span class="line">foo2</span><br></pre></td></tr></table></figure>


<p>现在，Vim 将使用 <code>foo1</code> 和 <code>foo2</code> 作为新折叠标志。注意，指示器必须是文本字符串，不能是正则表达式。</p>
<h2 id="语法折叠"><a href="#语法折叠" class="headerlink" title="语法折叠"></a>语法折叠</h2><p>Vim 有一个能够自定义文本语法（高亮、字体粗细、颜色等）的语法系统。本章不会讨论语法系统的工作原理，但您可以使用它来指示要折叠的文本。要使用语法折叠，请运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:set foldmethod=syntax</span><br></pre></td></tr></table></figure>


<p>假设您有如下文本，并且想折叠方括号里的所有内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &quot;one&quot;,</span><br><span class="line">  &quot;two&quot;,</span><br><span class="line">  &quot;three&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>


<p>您需要设置正确的语法定义，来捕获方括号之间的字符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:syn region testFold start=&quot;\\[&quot; end=&quot;\\]&quot; transparent fold</span><br></pre></td></tr></table></figure>


<p>您应该能看到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-- 5 lines: [ -----</span><br></pre></td></tr></table></figure>


<p>上面的命令分解如下：</p>
<ul>
<li><code>:syn</code> 是语法命令。</li>
<li><code>region</code> 构造一个可以跨越几行的语法区域。查阅 <code>:h syntax.txt</code> 可以获得更多信息。</li>
<li><code>start=&quot;\\[&quot; end=&quot;\\]&quot;</code> 定义区域的起始和结束。您需要转义 (<code>\\</code>) 方括号，因为它们是特殊字符。</li>
<li><code>transparent</code> 防止高亮。</li>
<li><code>fold</code> 当语法匹配到起始字符和结束字符时，增加折叠级别。</li>
</ul>
<h2 id="表达式折叠"><a href="#表达式折叠" class="headerlink" title="表达式折叠"></a>表达式折叠</h2><p>表达式折叠允许您定义要匹配折叠的表达式。定义折叠表达式后，Vim 会计算每行的 <code>&#39;foldexpr&#39;</code> 值。这是必须配置的变量，它要返回适当的值。如果返回 0，则不折叠行。如果它返回 1，则该行的折叠级别为 1。如果它返回 2，则该线的折叠级别为 2。除了整数外还有其他的值，但我不打算介绍它们。如果你好奇，可以查阅<code>:h fold-expr</code>。</p>
<p>首先，更改折叠方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:set foldmethod=expr</span><br></pre></td></tr></table></figure>


<p>假设您有一份早餐食品列表，并且想要折叠所有以 “p” 开头的早餐项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">donut</span><br><span class="line">pancake</span><br><span class="line">pop-tarts</span><br><span class="line">protein bar</span><br><span class="line">salmon</span><br><span class="line">scrambled eggs</span><br></pre></td></tr></table></figure>


<p>其次，更改 <code>foldexpr</code> 为捕获以 “p” 开头的表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:set foldexpr=getline(v:lnum)[0]==\\&quot;p\\&quot;</span><br></pre></td></tr></table></figure>


<p>这表达式看起来有点吓人。我们来分解下：</p>
<ul>
<li><code>:set foldexpr</code> 设置 <code>&#39;foldexpr&#39;</code> 为自定义表达式。</li>
<li><code>getline()</code> 是 Vim 脚本的一个函数，它返回指定行的内容。如运行 <code>:echo getline(5)</code> 可以获取第5行的内容。</li>
<li><code>v:lnum</code> 是 Vim <code>&#39;foldexpr&#39;</code> 表达式的特殊变量。Vim 在扫描每一行时，都会将行号存储至 <code>v:lnum</code> 变量。</li>
<li><code>[0]</code> 处于 <code>getline(v:lnum)[0]</code> 语境时，代表每一行的第一个字符。Vim 在扫描某一行时，<code>getline(v:lnum)</code> 返回该行的内容，而 <code>getline(v:lnum)[0]</code> 则返回这一行的第一个字符。例如，我们早餐食品列表的第一行是 “donut”，则 <code>getline(v:lnum)[0]</code> 返回 “d”；列表的第二行是 “pancake”，则 <code>getline(v:lnum)[0]</code> 返回 “p”。</li>
<li><code>==\\&quot;s\\&quot;</code> 是等式表达式的后半部分，它检查刚才表达式的计算结果是否等于 “s”。如果是，则返回1，否则返回0。在 Vim 的世界里，1代表真，0代表假。所以，那些以 “s” 开头的行，表达式都会返回1。回想一下本节的开始，如果 <code>&#39;foldexpr&#39;</code> 的值为1，则折叠级别为1。</li>
</ul>
<p>在运行这个表达式后，您将看到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">donut</span><br><span class="line">+-- 3 lines: pancake -----</span><br><span class="line">salmon</span><br><span class="line">scrambled eggs</span><br></pre></td></tr></table></figure>


<h2 id="差异折叠"><a href="#差异折叠" class="headerlink" title="差异折叠"></a>差异折叠</h2><p>Vim 可以对多个文件进行差异比较。</p>
<p>如果您有 <code>file1.txt</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br></pre></td></tr></table></figure>


<p>以及 <code>file2.txt</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">emacs is ok</span><br></pre></td></tr></table></figure>


<p>运行 <code>vimdiff file1.txt file2.txt</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-- 3 lines: vim is awesome -----</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">vim is awesome</span><br><span class="line">[vim is awesome] / [emacs is ok]</span><br></pre></td></tr></table></figure>


<p>Vim 会自动折叠一些相同的行。运行 <code>vimdiff</code> 命令时，Vim 会自动使用 <code>foldmethod=diff</code>。此时如果运行 <code>:set foldmethod?</code>，它将返回 <code>diff</code>。</p>
<h2 id="持久化折叠"><a href="#持久化折叠" class="headerlink" title="持久化折叠"></a>持久化折叠</h2><p>当关闭 Vim 会话后，您将失去所有的折叠信息。假设您有 <code>count.txt</code> 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br><span class="line">four</span><br><span class="line">five</span><br></pre></td></tr></table></figure>


<p>手动从第三行开始往下折叠 (<code>:3,$fold</code>)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br><span class="line">+-- 3 lines: three ---</span><br></pre></td></tr></table></figure>


<p>当您退出 Vim 再重新打开 <code>count.txt</code> 后，这些折叠都不见了！</p>
<p>要在折叠后保留它们，可以运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:mkview</span><br></pre></td></tr></table></figure>


<p>当打开 <code>count.txt</code> 后，运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:loadview</span><br></pre></td></tr></table></figure>


<p>您的折叠信息都被保留下来了。然而，您需要手动运行 <code>mkview</code> 和 <code>loadview</code>。我知道，终有一日，我会忘记运行 <code>mkview</code> 就关闭文件了，接着便会丢失所有折叠信息。能不能自动实现这个呢？</p>
<p>当然能！要在关闭 <code>.txt</code> 文件时自动运行 <code>mkview</code>，以及在打开 <code>.txt</code> 文件后自动运行 <code>loadview</code>，将下列内容添加至您的 vimrc：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">autocmd BufWinLeave *.txt mkview</span><br><span class="line">autocmd BufWinEnter *.txt silent loadview</span><br></pre></td></tr></table></figure>


<p>在上一章您已经见过 <code>autocommand</code> 了，它用于在事件触发时执行一条命令。现在有两个事件可以用于实现操作：</p>
<ul>
<li><code>BufWinLeave</code> 从窗口中删除缓冲时。</li>
<li><code>BufWinEnter</code> 在窗口中加载缓冲时。</li>
</ul>
<p>现在，即使您在 <code>.txt</code> 文件内折叠内容后直接退出 Vim，下次再打开该文件时，您的折叠信息都能自动恢复。</p>
<p>默认情况下，在 Unix 系统的 <code>~/.vim/view</code> 内运行 <code>mkview</code> 时，Vim 都会保存折叠信息。您可以查阅 <code>:h &#39;viewdir&#39;</code> 来了解更多信息。</p>
<h2 id="聪明地学习折叠"><a href="#聪明地学习折叠" class="headerlink" title="聪明地学习折叠"></a>聪明地学习折叠</h2><p>当我刚开始使用 Vim 时， 我会跳过学习 Vim 折叠，因为我觉得它不太实用。然而，随着我码龄的增长，我越发觉得折叠功能大有用处。得当地使用折叠功能，文本结构可以更加清晰，犹如一本书籍的目录。</p>
<p>当您学习折叠时，请从手动折叠开始，因为它可以随学随用。然后逐渐学习不同的技巧来使用缩进和标志折叠。最后，学习如何使用语法和表达式折叠。您甚至可以使用后两个来编写您自己的 Vim 插件。</p>
<p>现在，您已经知道如何进行折叠了。让我们来学习下一个：使用 git 进行版本控制。</p>
<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p>Vim 和 Git 是两种实现不同功能的伟大工具。Vim 用于文本编辑，Git 用于版本控制。在本章中，您将学习如何将 Vim 和 Git 集成在一起。</p>
<h2 id="差异比较"><a href="#差异比较" class="headerlink" title="差异比较"></a>差异比较</h2><p>在上一章中，您看到了如何运行 <code>vimdiff</code> 命令以显示多个文件之间的差异。</p>
<p>假设您有两个文件，<code>file1.txt</code> 和 <code>file2.txt</code>。<code>file1.txt</code> 的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pancakes</span><br><span class="line">waffles</span><br><span class="line">apples</span><br><span class="line"></span><br><span class="line">milk</span><br><span class="line">apple juice</span><br><span class="line"></span><br><span class="line">yogurt</span><br></pre></td></tr></table></figure>


<p><code>file2.txt</code> 的内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pancakes</span><br><span class="line">waffles</span><br><span class="line">oranges</span><br><span class="line"></span><br><span class="line">milk</span><br><span class="line">orange juice</span><br><span class="line"></span><br><span class="line">yogurt</span><br></pre></td></tr></table></figure>


<p>若要查看两个文件之间的差异，请运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vimdiff file1.txt file2.txt</span><br></pre></td></tr></table></figure>


<p>或者也可以运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim -d file1.txt file2.txt</span><br></pre></td></tr></table></figure>


<p>  <img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1620184778608-e265bd0d-04cf-4e89-99e3-d1f0f9900440.png#clientId=u52f13e61-1a27-4&from=drop&id=u513e4b74&margin=%5Bobject%20Object%5D&name=diffing-basic.png&originHeight=530&originWidth=829&originalType=binary&size=65477&status=done&style=none&taskId=u99249820-8928-411c-bb63-b8875eff04c" alt="diffing-basic.png"></p>
<p><code>vimdiff</code> 并排显示两个缓冲区。左边是 <code>file1.txt</code>，右边是 <code>file2.txt</code>。不同的两行（apples 和 oranges）会被高亮显示。</p>
<p>假设您要使第二个缓冲区变成 apples，而不是 oranges。若想从 <code>file1.txt</code> 传输您当前位置的内容到 <code>file2.txt</code>，首先使用 <code>]c</code> 跳转到下一处差异（使用 <code>[c</code> 可跳回上一处），现在光标应该在 apples 上了。接着运行 <code>:diffput</code>。此时，这两个文件都是 apples 了。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1620184815564-939dda06-7849-448e-aefc-2f7160f6fbaf.png#clientId=u52f13e61-1a27-4&from=drop&id=u519af719&margin=%5Bobject%20Object%5D&name=diffing-apples.png&originHeight=530&originWidth=829&originalType=binary&size=62297&status=done&style=none&taskId=ud9a01ede-2263-4282-9445-416ef1cc82c" alt="diffing-apples.png"></p>
<p>如果您想从另一个缓冲区（orange juice）传输文本来替代当前缓冲区（apple juice），首先使用 <code>]c</code> 跳转至下一处差异，此时光标应该在 apple juice 上。接着运行 <code>:diffget</code> 获取另一个缓冲区的 orange juice 来替代当前缓冲区中的 apple juice。</p>
<p><code>:diffput</code> 将文本从当前缓冲区_输出_到另一个缓冲区。<code>:diffget</code> 从另一个缓冲区_获取_文本到当前缓冲区。如果有多个缓冲区，可以运行 <code>:diffput fileN.txt</code> 和 <code>:diffget fileN.txt</code> 来指定缓冲区 fileN。</p>
<h2 id="使用-Vim-作为合并工具"><a href="#使用-Vim-作为合并工具" class="headerlink" title="使用 Vim 作为合并工具"></a>使用 Vim 作为合并工具</h2><blockquote>
<p>“我非常喜欢解决合并冲突。” ——佚名</p>
</blockquote>
<p>我不知道有谁喜欢解决合并冲突，但总之，合并冲突是无法避免的。在本节中，您将学习如何利用 Vim 作为解决合并冲突的工具。</p>
<p>首先，运行下列命令来将默认合并工具更改为 <code>vimdiff</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config merge.tool vimdiff</span><br><span class="line">git config merge.conflictstyle diff3</span><br><span class="line">git config mergetool.prompt false</span><br></pre></td></tr></table></figure>


<p>或者您也可以直接修改 <code>~/.gitconfig</code>（默认情况下，它应该处于根目录中，但您的可能在不同的位置）。配置您的 <code>gitconfig</code> 成如下内容，就可以开始了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[core]</span><br><span class="line">  editor = vim</span><br><span class="line">[merge]</span><br><span class="line">  tool = vimdiff</span><br><span class="line">  conflictstyle = diff3</span><br><span class="line">[difftool]</span><br><span class="line">  prompt = false</span><br></pre></td></tr></table></figure>


<p>让我们创建一个假的合并冲突来测试一下。首先创建一个目录 <code>/food</code>，并初始化 git 仓库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>


<p>添加 <code>breakfast.txt</code> 文件，内容为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pancakes</span><br><span class="line">waffles</span><br><span class="line">oranges</span><br></pre></td></tr></table></figure>


<p>添加文件并提交它：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;Initial breakfast commit&quot;</span><br></pre></td></tr></table></figure>


<p>接着，创建一个新分支 apples：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b apples</span><br></pre></td></tr></table></figure>


<p>更改 <code>breakfast.txt</code> 文件为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pancakes</span><br><span class="line">waffles</span><br><span class="line">apples</span><br></pre></td></tr></table></figure>


<p>保存文件，添加并提交更改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;Apples not oranges&quot;</span><br></pre></td></tr></table></figure>


<p>真棒！现在 master 分支有 oranges，而 apples 分支有 apples。接着回到 master 分支：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure>


<p>在 <code>breakfast.txt</code> 文件中，您应该能看到原来的文本 oranges。接着将它改成 grapes，因为它是现在的应季水果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pancakes</span><br><span class="line">waffles</span><br><span class="line">grapes</span><br></pre></td></tr></table></figure>


<p>保存、添加、提交：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;Grapes not oranges&quot;</span><br></pre></td></tr></table></figure>


<p>嚯！这么多步骤！现在准备要将 apples 分支合并进 master 分支了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git merge apples</span><br></pre></td></tr></table></figure>


<p>您应该会看到如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Auto-merging breakfast.txt</span><br><span class="line">CONFLICT (content): Merge conflict in breakfast.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>


<p>没错，一个冲突！现在一起来用一下新配置的 <code>mergetool</code> 来解决冲突吧！运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git mergetool</span><br></pre></td></tr></table></figure>


<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1620184864093-148bb94c-91ba-432a-a9ad-a17846dbf09d.png#clientId=u52f13e61-1a27-4&from=drop&id=uc369cbb9&margin=%5Bobject%20Object%5D&name=mergetool-initial.png&originHeight=530&originWidth=829&originalType=binary&size=73687&status=done&style=none&taskId=u51d35d33-5487-459f-b94b-adcd8a2150c" alt="mergetool-initial.png"></p>
<p>Vim 显示了四个窗口。注意一下顶部三个：</p>
<ul>
<li><code>LOCAL</code> 包含了 <code>grapes</code>。这是“本地”中的变化，也是您要合并的内容。</li>
<li><code>BASE</code> 包含了 <code>oranges</code>。这是 <code>LOCAL</code> 和 <code>REMOTE</code> 的共同祖先，用于比较它们之间的分歧。</li>
<li><code>REMOTE</code> 包含了 <code>apples</code>。这是要被合并的内容。</li>
</ul>
<p>底部窗口（也即第四个窗口），您能看到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pancakes</span><br><span class="line">waffles</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">grapes</span><br><span class="line">||||||| db63958</span><br><span class="line">oranges</span><br><span class="line">=======</span><br><span class="line">apples</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; apples</span><br></pre></td></tr></table></figure>


<p>第四个窗口包含了合并冲突文本。有了这步设置，就能更轻松看到哪个环境发生了什么变化。您可以同时查看 <code>LOCAL</code>、<code>BASE</code> 和 <code>REMOTE</code> 的内容。如果您在第四个窗口，将光标移至高亮处，再运行 <code>:diffget LOCAL</code>，就可以_获取_来自 <code>LOCAL</code> 的改变（<code>grapes</code>）。同样，运行 <code>:diffget BASE</code> 可以获取来自 <code>BASE</code> 的改变（<code>oranges</code>），而运行 <code>:diffget REMOTE</code> 可以获取来自 <code>REMOTE</code> 的改变（<code>apples</code>）。</p>
<p>在这个例子中，我们试着获取来自 <code>LOCAL</code> 的改变。运行 <code>:diffget LO</code>（<code>LOCAL</code> 的简写），第四个窗口变成了 grapes。完成后，就可以保存并退出所有文件（<code>:qall</code>）了。还不错吧？</p>
<p>稍加留意您会发现，现在多了一个 <code>breakfast.txt.orig</code> 文件。这是 Git 防止事与愿违而创建的备份文件。如果您不希望 Git 在合并期间创建备份文件，可以运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global mergetool.keepBackup false</span><br></pre></td></tr></table></figure>


<h2 id="在-Vim-中使用-Git"><a href="#在-Vim-中使用-Git" class="headerlink" title="在 Vim 中使用 Git"></a>在 Vim 中使用 Git</h2><p>Vim 本身没有集成 Git，但您仍然可以在 Vim 中执行 Git 命令。一种方法是在命令行模式中使用 <code>!</code> 叹号运算符。</p>
<p>使用 <code>!</code> 可以运行任何 Git 命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:!git status</span><br><span class="line">:!git commit</span><br><span class="line">:!git diff</span><br><span class="line">:!git push origin master</span><br></pre></td></tr></table></figure>


<p>您还可以使用 Vim 的特殊字符 <code>%</code> (当前缓冲区) 或 <code>#</code> (其他缓冲区)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:!git add %         &quot; git add current file</span><br><span class="line">:!git checkout #    &quot; git checkout the other file</span><br></pre></td></tr></table></figure>


<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>如果要在 Vim 中集成 Git，您必须使用插件。以下是 Vim 中较流行的 Git 相关插件列表：</p>
<ul>
<li><a href="https://github.com/airblade/vim-gitgutter">vim-gitgutter</a></li>
<li><a href="https://github.com/mhinz/vim-signify">vim-signify</a></li>
<li><a href="https://github.com/tpope/vim-fugitive">vim-fugitive</a></li>
<li><a href="https://github.com/junegunn/gv.vim">gv.vim</a></li>
<li><a href="https://github.com/jreybert/vimagit">vimagit</a></li>
<li><a href="https://github.com/sodapopcan/vim-twiggy">vim-twiggy</a></li>
<li><a href="https://github.com/tpope/vim-rhubarb">rhubarb</a></li>
</ul>
<p>其中最流行的是 vim-fugitive。本章的剩余部分，我将使用此插件来介绍几个 git 工作流。</p>
<h2 id="Vim-Fugitive"><a href="#Vim-Fugitive" class="headerlink" title="Vim-Fugitive"></a>Vim-Fugitive</h2><p>vim-fugitive 插件允许您在不离开 Vim 编辑器的情况下运行 git 命令行界面。您会发现，有些命令在 Vim 内部执行时会更好。</p>
<p>开始前，请先使用 Vim 插件管理器（<a href="https://github.com/junegunn/vim-plug">vim-plug</a>、<a href="https://github.com/VundleVim/Vundle.vim">vundle</a>、<a href="https://github.com/Shougo/dein.vim">dein.vim</a> 等）安装 vim-fugitive。</p>
<h2 id="Git-Status"><a href="#Git-Status" class="headerlink" title="Git Status"></a>Git Status</h2><p>当您不带参数地运行 <code>:Git</code> 命令时，vim-fugitive 将显示一个 git 概要窗口，它显示了未跟踪、未暂存和已暂存的文件。在此 “<code>git status</code>” 模式下，您可以做一些操作：</p>
<ul>
<li><code>Ctrl-n</code> / <code>Ctrl-p</code> 转到下一个 / 上一个文件。</li>
<li><code>-</code> 暂存或取消暂存光标处的文件。</li>
<li><code>s</code> 暂存光标处的文件。</li>
<li><code>u</code> 取消暂存光标处的文件。</li>
<li><code>&gt;</code> / <code>&lt;</code> 内联显示或隐藏光标处文件的差异变化。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1620184947317-3e3eed5d-ffa5-4790-b488-5d6781dd65af.png#clientId=u52f13e61-1a27-4&from=drop&id=ubb535aa9&margin=%5Bobject%20Object%5D&name=fugitive-git.png&originHeight=581&originWidth=815&originalType=binary&size=76506&status=done&style=none&taskId=u95fbd9bc-e0c8-4afa-8e1d-42ad75e3fa5" alt="fugitive-git.png"> </p>
<p>查阅 <code>:h fugitive-staging-maps</code> 可获得更多信息。</p>
<h2 id="Git-Blame"><a href="#Git-Blame" class="headerlink" title="Git Blame"></a>Git Blame</h2><p>在当前文件运行 <code>:Git blame</code> 命令，vim-fugitive 可以显示一个拆分的问责窗口。这有助于追踪那些 BUG 是谁写的，接着就可以冲他/她怒吼（虽然那个人可能是我）。</p>
<p>在  <code>&quot;git blame&quot;</code> 模式下您可以做：</p>
<ul>
<li><code>q</code> 关闭问责窗口。</li>
<li><code>A</code> 调整大小至作者列。</li>
<li><code>C</code> 调整大小至提交列。</li>
<li><code>D</code> 调整大小至日期/时间列。</li>
</ul>
<p>查阅 <code>:h :Git_blame</code> 可获得更多信息。</p>
<p> <img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1620184976812-dde685fc-b632-45dd-b904-9257a25dfc6b.png#clientId=u52f13e61-1a27-4&from=drop&id=u2b6fca57&margin=%5Bobject%20Object%5D&name=fugitive-git-blame.png&originHeight=581&originWidth=815&originalType=binary&size=82484&status=done&style=none&taskId=ue3a845a5-9fcf-4470-b31d-f1358b7f5a5" alt="fugitive-git-blame.png"></p>
<h2 id="Gdiffsplit"><a href="#Gdiffsplit" class="headerlink" title="Gdiffsplit"></a>Gdiffsplit</h2><p>当您运行 <code>:Gdiffsplit</code> 命令后，vim-fugitive 会根据索引或工作树中的版本，与当前文件的最新更改执行 <code>vimdiff</code>。如果运行 <code>:Gdiffsplit &lt;commit&gt;</code>，vim-fugitive 则会根据 <code>&lt;commit&gt;</code> 中的版本来执行 <code>vimdiff</code>。</p>
<p> <img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1620184994876-12a3d7aa-6774-471a-b177-9d1502d1728f.png#clientId=u52f13e61-1a27-4&from=drop&id=u0a577946&margin=%5Bobject%20Object%5D&name=fugitive-gdiffsplit.png&originHeight=581&originWidth=815&originalType=binary&size=68484&status=done&style=none&taskId=u8657d20e-8b2e-4a4e-af8c-20f506072d2" alt="fugitive-gdiffsplit.png"> </p>
<p>由于您处于 <code>vimdiff</code> 模式中，因此您可以使用 <code>:diffput</code> 和 <code>:diffget</code> 来_获取_ 或 _输出_差异。</p>
<h2 id="Gwrite-和-Gread"><a href="#Gwrite-和-Gread" class="headerlink" title="Gwrite 和 Gread"></a>Gwrite 和 Gread</h2><p>当您在更改文件后运行 <code>:Gwrite</code> 命令，vim-fugitive 将暂存更改，就像运行 <code>git add &lt;current-file&gt;</code> 一样。</p>
<p>当您在更改文件后运行 <code>:Gread</code> 命令，vim-fugitive 会将文件还原至更改前的状态，就像运行 <code>git checkout &lt;current-file&gt;</code> 一样。使用 <code>:Gread</code> 还有一个好处是操作可撤销。如果在运行 <code>:Gread</code> 后您改变主意，想要保留原来的更改，您只需要撤消（<code>u</code>），Vim 将撤回 <code>:Gread</code> 操作。要换作是在命令行中运行 <code>git checkout &lt;current-file&gt;</code>，就完成不了这种操作了。</p>
<h2 id="Gclog"><a href="#Gclog" class="headerlink" title="Gclog"></a>Gclog</h2><p>当您运行 <code>:Gclog</code> 命令时，vim-fugitive 将显示提交历史记录，就像运行 <code>git log</code> 命令一样。Vim-fugitive 使用 Vim 的快速修复来完成此任务，因此您可以使用 <code>:cnext</code> 和 <code>:cprevious</code> 来遍历下一个或上一个日志信息。您还可以使用 <code>:copen</code> 和 <code>:cclose</code> 打开或关闭日志列表。</p>
<p> <img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1620185029510-05007c4f-7932-4161-9524-895756bccc13.png#clientId=u52f13e61-1a27-4&from=drop&id=ub5e2b98e&margin=%5Bobject%20Object%5D&name=fugitive-git-log.png&originHeight=581&originWidth=815&originalType=binary&size=100768&status=done&style=none&taskId=uf58a242c-5267-44bf-9c5e-1d84fa1018d" alt="fugitive-git-log.png"></p>
<p>在 <code>&quot;git log&quot;</code> 模式中，您可以做两件事：</p>
<ul>
<li>查看树。</li>
<li>访问父级（上一个提交）。</li>
</ul>
<p>您可以像 <code>git log</code> 命令一样，传递参数给 <code>:Gclog</code> 命令。如果您项目的提交历史记录很长，只想看最后三个提交，则可以运行 <code>:Gclog -3</code>。如果需要根据提交日期来筛选记录，可以运行类似 <code>:Gclog --after=&quot;January 1&quot; --before=&quot;March 14&quot;</code> 的命令。</p>
<h2 id="Vim-Fugitive-的更多功能"><a href="#Vim-Fugitive-的更多功能" class="headerlink" title="Vim-Fugitive 的更多功能"></a>Vim-Fugitive 的更多功能</h2><p>以上只是寥寥几个 vim-fugitive 功能的例子，您可以查阅 <code>:h fugitive.txt</code> 来了解更多有关 vim-fugitive 的信息。关键是，大多数甚至所有流行的 git 命令可能都有他们的 vim-fugitive 版本，您只需在文档中查找它们。</p>
<p>如果您处于 vim-fugitive 的“特殊模式”（如 <code>:Git</code> 或 <code>:Git blame</code> 模式）中，按下 <code>g?</code> 可以了解当前有哪些可用的快捷键，Vim-fugitive 将为您所处的模式显示相应的 <code>:help</code> 窗口。棒极了！</p>
<h2 id="聪明地学习-Vim-和-Git"><a href="#聪明地学习-Vim-和-Git" class="headerlink" title="聪明地学习 Vim 和 Git"></a>聪明地学习 Vim 和 Git</h2><p>每个人都有不同的 git 工作流，可能 vim-fugitive 非常合适您的工作流（也可能不适合）。总之，我强烈建议您试试上面列出的所有插件。可能还有一些其他的我没有列出来，但适合您工作的就是最好的。</p>
<p>更多地了解 git 可以使您与 Vim-git 集成插件工作得更好。Git 本身是一个很庞大的主题，我只向您展示了它其中很小的一部分。好了，接下来谈谈如何使用 Vim 编译您的代码。</p>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>编译是许多编程语言的重要主题。在本章中，您将学习如何在 Vim 中编译。此外，您将看到如何利用好 Vim 的 <code>:make</code> 命令。</p>
<h2 id="从命令行编译"><a href="#从命令行编译" class="headerlink" title="从命令行编译"></a>从命令行编译</h2><p>您可以使用叹号运算符（<code>!</code>）进行编译。如果您需要使用 <code>g++</code> 来编译 <code>.cpp</code> 文件，可以运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:!g++ hello.cpp -o hello</span><br></pre></td></tr></table></figure>


<p>但要每次手动指定文件名和输出文件名会非常繁琐和容易出错。而 makefile 是条可行之路。</p>
<h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><p>在本节中，我将简要介绍一些 makefile 的基础知识。如果您已经知道如何使用 makefile，可以直接跳转到下一部分。在当前目录中，创建一个 <code>makefile</code> 文件，内容是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">all:</span><br><span class="line">	echo &quot;Hello all&quot;</span><br></pre></td></tr></table></figure>


<p>在终端中运行 <code>make</code> 命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>


<p>您将看到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;Hello all&quot;</span><br><span class="line">Hello all</span><br></pre></td></tr></table></figure>


<p>终端输出了 echo 命令本身及其输出。您可以在 makefile 中编写多个“目标”。现在我们多添加几个：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">all:</span><br><span class="line">	echo &quot;Hello all&quot;</span><br><span class="line">foo:</span><br><span class="line">	echo &quot;Hello foo&quot;</span><br><span class="line">list_pls:</span><br><span class="line">	ls</span><br></pre></td></tr></table></figure>


<p>接着您可以用不同目标运行 <code>make</code>  命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make foo</span><br><span class="line">## returns &quot;Hello foo&quot;</span><br><span class="line"></span><br><span class="line">make list_pls</span><br><span class="line">## returns the ls command</span><br></pre></td></tr></table></figure>


<p>除了输出之外，<code>make</code> 还输出了实际命令。要停止输出实际命令，可以在命令开头添加 <code>@</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">all:</span><br><span class="line">  @echo &quot;Hello all&quot;</span><br></pre></td></tr></table></figure>


<p>现在运行 <code>make</code>，您将仅看到 “Hello all” 而没有 <code>echo &quot;Hello all&quot;</code> 了。</p>
<h2 id="make"><a href="#make" class="headerlink" title=":make"></a><code>:make</code></h2><p>Vim 有运行 makefile 的 <code>:make</code> 命令。当您运行它时，Vim 会在当前目录查找 makefile 并执行它。</p>
<p>您可以在当前目录创建 <code>makefile</code> 文件并添加如下内容来跟随教程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">all:</span><br><span class="line">	echo &quot;Hello all&quot;</span><br><span class="line">foo:</span><br><span class="line">	echo &quot;Hello foo&quot;</span><br><span class="line">list_pls:</span><br><span class="line">	ls</span><br></pre></td></tr></table></figure>


<p>在 Vim 中运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:make</span><br></pre></td></tr></table></figure>


<p>Vim 执行它的方式与从终端运行它的方式相同。<code>:make</code> 命令也接受终端中 <code>make</code> 命令的参数。运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:make foo</span><br><span class="line"></span><br><span class="line">:make list_pls</span><br></pre></td></tr></table></figure>


<p>如果命令执行异常，<code>:make</code> 命令将使用 Vim 的 <code>quickfix</code> 来存储这些错误。现在试着运行一个不存在的目标：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:make dontexist</span><br></pre></td></tr></table></figure>


<p>您应该会看到该命令执行错误。运行 <code>quickfix</code> 命令 <code>:copen</code> 可以打开 <code>quickfix</code> 窗口来查看该错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|| make: *** No rule to make target `dontexist&#x27;.  Stop.</span><br></pre></td></tr></table></figure>


<h2 id="使用-make-编译"><a href="#使用-make-编译" class="headerlink" title="使用 make 编译"></a>使用 <code>make</code> 编译</h2><p>让我们使用 makefile 来编译一个基本的 <code>.cpp</code> 程序。首先创建一个 <code>hello.cpp</code> 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello!\n&quot;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>然后，更新 <code>makefile</code> 来编译和运行 <code>.cpp</code> 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">all:</span><br><span class="line">	echo &quot;build, run&quot;</span><br><span class="line">build:</span><br><span class="line">	g++ hello.cpp -o hello</span><br><span class="line">run:</span><br><span class="line">	./hello</span><br></pre></td></tr></table></figure>


<p>现在运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:make build</span><br></pre></td></tr></table></figure>


<p><code>g++</code> 将编译 <code>./hello.cpp</code> 并且输出 <code>./hello</code>。接着运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:make run</span><br></pre></td></tr></table></figure>


<p>您应该会看到终端上打印出了 <code>&quot;Hello!&quot;</code>。</p>
<h2 id="makeprg"><a href="#makeprg" class="headerlink" title="makeprg"></a><code>makeprg</code></h2><p>当您运行 <code>:make</code> 时，Vim 实际上会执行 <code>makeprg</code> 选项所设置的任何命令，您可以运行 <code>:set makeprg?</code> 来查看它：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">makeprg=make</span><br></pre></td></tr></table></figure>


<p><code>:make</code> 的默认命令是外部的 <code>make</code> 命令。若要将 <code>:make</code> 命令更改为：每次运行它则执行 <code>g++ &lt;your-file-name&gt;</code>，请运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:set makeprg=g++\\ %</span><br></pre></td></tr></table></figure>


<p><code>\\</code> 用于转义 <code>g++</code> 后的空格（转义本身也需要转义）。Vim 中 <code>%</code> 符号代表当前文件。因此，<code>g++\\ %</code> 命令等于运行 <code>g++ hello.cpp</code>。</p>
<p>转到 <code>./hello.cpp</code> 然后运行 <code>:make</code>，Vim 将编译 <code>hello.cpp</code> 并输出 <code>a.out</code>（因为您没有指定输出）。让我们重构一下，使用去掉扩展名的原始文件名来命名编译后的输出。运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:set makeprg=g++\\ %\\ -o\\ %&lt;</span><br></pre></td></tr></table></figure>


<p>上面的命令分解如下：</p>
<ul>
<li><code>g++\\ %</code> 如上所述，等同于运行 <code>g++ &lt;your-file&gt;</code>。</li>
<li><code>-o</code> 输出选项。</li>
<li><code>%&lt;</code> 在 Vim 中代表了没有扩展名的当前文件名（如 <code>hello.cpp</code> 变成 <code>hello</code>）。</li>
</ul>
<p>当您在 <code>./hello.cpp</code> 中运行 <code>:make</code> 时，它将编译为 <code>./hello</code>。要在 <code>./hello.cpp</code> 中快速地执行 <code>./hello</code>，可以运行 <code>:!./%&lt;</code>。同样，它等同于运行 <code>:!./&lt;current-file-name-minus-the-extension&gt;</code>。</p>
<p>查阅 <code>:h :compiler</code> 和 <code>:h write-compiler-plugin</code> 可以了解更多信息。</p>
<h2 id="保存时自动编译"><a href="#保存时自动编译" class="headerlink" title="保存时自动编译"></a>保存时自动编译</h2><p>有了自动化编译，您可以让生活更加轻松。回想一下，您可以使用 Vim 的 <code>autocommand</code> 来根据某些事件自动执行操作。例如，要自动在每次保存后编译 <code>.cpp</code> 文件，您可以运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:autocmd BufWritePost *.cpp make</span><br></pre></td></tr></table></figure>


<p>现在您每次保存 <code>.cpp</code> 文件后，Vim 都将自动执行 <code>make</code> 命令。</p>
<h2 id="切换编译器"><a href="#切换编译器" class="headerlink" title="切换编译器"></a>切换编译器</h2><p>Vim 有一个 <code>:compiler</code> 命令可以快速切换编译器。您的 Vim 可能附带了一些预构建的编译配置。要检查您拥有哪些编译器，请运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:e $VIMRUNTIME/compilers/&lt;tab&gt;</span><br></pre></td></tr></table></figure>


<p>您应该会看到一个不同编程语言的编译器列表。</p>
<p>若要使用 <code>:compiler</code> 命令，假设您有一个 ruby 文件 <code>hello.rb</code>，内容是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">puts &quot;Hello ruby&quot;</span><br></pre></td></tr></table></figure>


<p>回想一下，如果运行 <code>:make</code>，Vim 将执行赋值给 <code>makeprg</code> 的任何命令（默认是 <code>make</code>）。如果您运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:compiler ruby</span><br></pre></td></tr></table></figure>


<p>Vim 执行 <code>$VIMRUNTIME/compiler/ruby.vim</code> 脚本，并将 <code>makeprg</code> 更改为使用 <code>ruby</code> 命令。现在如果您运行 <code>:set makeprg?</code>，它会显示 <code>makeprg=ruby</code>（这取决于您 <code>$VIMRUNTIME/compiler/ruby.vim</code> 里的内容，或者是否有其他自定义的 ruby 编译器，因此您的结果可能会有不同）。<code>:compiler &lt;your-lang&gt;</code> 命令允许您快速切换至其他编译器。如果您的项目使用多种语言，这会非常有用。</p>
<p>您不必使用 <code>:compiler</code> 或 <code>makeprg</code> 来编译程序。您可以运行测试脚本、分析文件、发送信号或任何您想要的内容。</p>
<h2 id="创建自定义编译器"><a href="#创建自定义编译器" class="headerlink" title="创建自定义编译器"></a>创建自定义编译器</h2><p>让我们来创建一个简单的 Typescript 编译器。先在您的设备上安装 Typescript（<code>npm install -g typescript</code>），安装完后您将有 <code>tsc</code> 命令。如果您之前没有尝试过 typescript，<code>tsc</code> 将 Typescript 文件编译成 Javascript 文件。假设您有一个 <code>hello.ts</code> 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const hello = &quot;hello&quot;;</span><br><span class="line">console.log(hello);</span><br></pre></td></tr></table></figure>


<p>运行 <code>tsc hello.ts</code> 后，它将被编译成 <code>hello.js</code>。然而，如果 <code>hello.ts</code> 变成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const hello = &quot;hello&quot;;</span><br><span class="line">hello = &quot;hello again&quot;;</span><br><span class="line">console.log(hello);</span><br></pre></td></tr></table></figure>


<p>这会抛出错误，因为不能更改一个 <code>const</code> 变量。运行 <code>tsc hello.ts</code> 的错误如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello.ts:2:1 - error TS2588: Cannot assign to &#x27;person&#x27; because it is a constant.</span><br><span class="line"></span><br><span class="line">2 person = &quot;hello again&quot;;</span><br><span class="line">  ~~~~~~</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Found 1 error.</span><br></pre></td></tr></table></figure>


<p>要创建一个简单的 Typescript 编译器，请在您的 <code>~/.vim/</code> 目录中新添加一个 <code>compiler</code> 目录（即 <code>~/.vim/compiler/</code>），接着创建 <code>typescript.vim</code> 文件（即 <code>~/.vim/compiler/typescript.vim</code>），并添加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CompilerSet makeprg=tsc</span><br><span class="line">CompilerSet errorformat=%f:\ %m</span><br></pre></td></tr></table></figure>


<p>第一行设置 <code>makeprg</code> 为运行 <code>tsc</code> 命令。第二行将错误格式设置为显示文件（<code>%f</code>），后跟冒号（<code>:</code>）和转义的空格（<code>\</code>），最后是错误消息（<code>%m</code>）。查阅 <code>:h errorformat</code> 可了解更多关于错误格式的信息。</p>
<p>您还可以阅读一些预制的编译器，看看它们是如何实现的。输入 <code>:e $VIMRUNTIME/compiler/&lt;some-language&gt;.vim</code> 查看。</p>
<p>有些插件可能会干扰 Typescript 文件，可以使用 <code>--noplugin</code> 标志以零插件的形式打开<code>hello.ts</code> 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim --noplugin hello.ts</span><br></pre></td></tr></table></figure>


<p>检查 <code>makeprg</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:set makeprg?</span><br></pre></td></tr></table></figure>


<p>它应该会显示默认的 <code>make</code> 程序。要使用新的 Typescript 编译器，请运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:compiler typescript</span><br></pre></td></tr></table></figure>


<p>当您运行 <code>:set makeprg?</code> 时，它应该会显示 <code>tsc</code> 了。我们来测试一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:make %</span><br></pre></td></tr></table></figure>


<p>回想一下，<code>%</code> 代表当前文件。看看您的 Typescript 编译器是否如预期一样工作。运行 <code>:copen</code> 可以查看错误列表。</p>
<h2 id="异步编译器"><a href="#异步编译器" class="headerlink" title="异步编译器"></a>异步编译器</h2><p>有时编译可能需要很长时间。在等待编译时，您不会想眼睁睁盯着已冻结的 Vim 的。如果可以异步编译，就可以在编译期间继续使用 Vim 了，岂不美哉？</p>
<p>幸运的是，有插件来运行异步进程。有两个比较好的是：</p>
<ul>
<li><a href="https://github.com/tpope/vim-dispatch">vim-dispatch</a></li>
<li><a href="https://github.com/skywind3000/asyncrun.vim">asyncrun.vim</a></li>
</ul>
<p>在这一章中，我将介绍 vim-dispatch，但我强烈建议您尝试上述列表中所有插件。</p>
<p><em>Vim 和 NeoVim 实际上都支持异步作业，但它们超出了本章的范围。如果您好奇，可以查阅 。</em></p>
<h2 id="插件：Vim-dispatch"><a href="#插件：Vim-dispatch" class="headerlink" title="插件：Vim-dispatch"></a>插件：Vim-dispatch</h2><p>Vim-dispatch 有几个命令，最主要的两个是 <code>:Make</code> 和 <code>:Dispatch</code>。</p>
<h2 id="Make"><a href="#Make" class="headerlink" title=":Make"></a><code>:Make</code></h2><p>Vim-dispatch 的 <code>:Make</code> 命令与 Vim 的 <code>:make</code> 相似，但它以异步方式运行。如果您正处于 Javascript 项目中，并且需要运行 <code>npm t</code>，可以将 <code>makeprg</code> 设置为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:set makeprg=npm\\ t</span><br></pre></td></tr></table></figure>


<p>如果运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:make</span><br></pre></td></tr></table></figure>


<p>Vim 将执行 <code>npm t</code>。但同时，您只能盯着冻结了的屏幕。有了 vim-dispatch，您只需要运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:Make</span><br></pre></td></tr></table></figure>


<p>Vim 将启用后台进程异步运行 <code>npm t</code>，同时您还能在 Vim 中继续编辑您的文本。棒极了！</p>
<h2 id="Dispatch"><a href="#Dispatch" class="headerlink" title=":Dispatch"></a><code>:Dispatch</code></h2><p><code>:Dispatch</code> 命令的工作方式和 <code>:compiler</code> 及 <code>:!</code> 类似。</p>
<p>假设您在 ruby spec 文件中，需要执行测试，可以运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:Dispatch rspec %</span><br></pre></td></tr></table></figure>


<p>Vim 将对当前文件异步运行 <code>rspec</code> 命令。</p>
<h2 id="自动调度"><a href="#自动调度" class="headerlink" title="自动调度"></a>自动调度</h2><p>Vim-dispatch 有 <code>b:dispatch</code> 缓冲区变量，您可以配置它来执行特定命令，并利用上 <code>autocmd</code>。如果在您的 vimrc 中添加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">autocmd BufEnter *_spec.rb let b:dispatch = &#x27;bundle exec rspec %&#x27;</span><br></pre></td></tr></table></figure>


<p>现在每当您进入一个以 <code>_spec.rb</code> 结尾的文件（<code>BufEnter</code>），<code>:Dispatch</code> 将被自动运行以执行 <code>bundle exec rspec &lt;your-current-ruby-spec-file&gt;</code>。</p>
<h2 id="聪明地学习编译"><a href="#聪明地学习编译" class="headerlink" title="聪明地学习编译"></a>聪明地学习编译</h2><p>在本章中，您了解到可以使用 <code>make</code> 和 <code>compiler</code> 命令从Vim内部异步运行_任何_进程，以完善您的编程工作流。Vim 拥有通过其他程序来扩展自身的能力，这使其变得强大。</p>
<h1 id="视图、会话和-Viminfo"><a href="#视图、会话和-Viminfo" class="headerlink" title="视图、会话和 Viminfo"></a>视图、会话和 Viminfo</h1><p>当您做了一段时间的项目后，您可能会发现这个项目逐渐形了成自己的设置、折叠、缓冲区、布局等，就像住了一段时间公寓后精心装饰了它一样。问题是，关闭 Vim 后，所有的这些更改都会丢失。如果能保留这些更改，等到下次打开 Vim 时，一切恢复如初，岂不美哉？</p>
<p>本章中，您将学习如何使用 视图、会话 和 Viminfo 来保存项目的“快照”。</p>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图是这三个部分（视图、会话、Viminfo）中的最小子集，它是一个窗口的设置的集合。如果您长时间在一个窗口上工作，并且想要保留其映射和折叠，您可以使用视图。</p>
<p>我们来创建一个 <code>foo.txt</code> 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">foo1</span><br><span class="line">foo2</span><br><span class="line">foo3</span><br><span class="line">foo4</span><br><span class="line">foo5</span><br><span class="line">foo6</span><br><span class="line">foo7</span><br><span class="line">foo8</span><br><span class="line">foo9</span><br><span class="line">foo10</span><br></pre></td></tr></table></figure>


<p>在这个文件中，做三次修改：</p>
<ol>
<li>在第 1 行，创建一个自定义折叠 <code>zf4j</code>（折叠接下来 4 行）。</li>
<li>更改 <code>number</code> 设置：<code>setlocal nonumber norelativenumber</code>。这会移除窗口左侧的数字指示器。</li>
<li>创建本地映射，每当按一次 <code>j</code> 时，向下两行：<code>:nnoremap &lt;buffer&gt; j jj</code>。</li>
</ol>
<p>您的文件看起来应该像：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-- 5 lines: foo1 -----</span><br><span class="line">foo6</span><br><span class="line">foo7</span><br><span class="line">foo8</span><br><span class="line">foo9</span><br><span class="line">foo10</span><br></pre></td></tr></table></figure>


<h3 id="配置视图属性"><a href="#配置视图属性" class="headerlink" title="配置视图属性"></a>配置视图属性</h3><p>运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:set viewoptions?</span><br></pre></td></tr></table></figure>


<p>默认情况下会显示（根据您的 vimrc 可能会有所不同）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">viewoptions=folds,cursor,curdir</span><br></pre></td></tr></table></figure>


<p>我们来配置 <code>viewoptions</code>。要保留的三个属性分别是折叠、映射和本地设置选项。如果您的设置和我的相似，那么您已经有了 <code>folds</code> 选项。运行下列命令使视图记住 <code>localoptions</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:set viewoptions+=localoptions</span><br></pre></td></tr></table></figure>


<p>查阅 <code>:h viewoptions</code> 可了解 <code>viewoptions</code> 的其他可用选项。现在运行 <code>:set viewoptions?</code>，您将看到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">viewoptions=folds,cursor,curdir,localoptions</span><br></pre></td></tr></table></figure>


<h3 id="保存视图"><a href="#保存视图" class="headerlink" title="保存视图"></a>保存视图</h3><p>在 <code>foo.txt</code> 窗口经过适当折叠并设置了 <code>nonumber norelativenumber</code> 选项后，现在我们来保存视图。运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:mkview</span><br></pre></td></tr></table></figure>


<p>Vim 创建了一个视图文件。</p>
<h3 id="视图文件"><a href="#视图文件" class="headerlink" title="视图文件"></a>视图文件</h3><p>您可能会想“Vim 将这个视图文件保存到哪儿了呢？”，运行下列命令就可以看到答案了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:set viewdir?</span><br></pre></td></tr></table></figure>


<p>默认情况下会显示 <code>~/.vim/view</code>（根据您的操作系统，可能会有不同的路径。查阅 <code>:h viewdir</code> 获得更多信息）。在您的 vimrc 中添加下列内容，可以更改为不同路径：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set viewdir=$HOME/else/where</span><br></pre></td></tr></table></figure>


<h3 id="加载视图文件"><a href="#加载视图文件" class="headerlink" title="加载视图文件"></a>加载视图文件</h3><p>关闭并重新打开 <code>foo.txt</code>，您会看到原来的文本，没有任何改变。这是预期行为。运行下列命令可以加载视图文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:loadview</span><br></pre></td></tr></table></figure>


<p>现在您将看到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-- 5 lines: foo1 -----</span><br><span class="line">foo6</span><br><span class="line">foo7</span><br><span class="line">foo8</span><br><span class="line">foo9</span><br><span class="line">foo10</span><br></pre></td></tr></table></figure>


<p>那些折叠、本地设置以及映射都恢复了。如果您细心还可以发现，光标位于上一次您运行 <code>:mkview</code> 时所处的行上。只要您有 <code>cursor</code> 选项，视图将记住光标位置。</p>
<h3 id="多个视图"><a href="#多个视图" class="headerlink" title="多个视图"></a>多个视图</h3><p>Vim 允许您保存 9 个编号的视图（1-9）。</p>
<p>假设您想用 <code>:9,10 fold</code> 来额外折叠最后两行，我们把这存为视图 1。运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:mkview 1</span><br></pre></td></tr></table></figure>


<p>如果您又想用 <code>:6,7 fold</code> 再折叠一次，并存为不同的视图，运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:mkview 2</span><br></pre></td></tr></table></figure>


<p>关闭并重新打开 <code>foo.txt</code> 文件，运行下列命令可以加载视图 1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:loadview 1</span><br></pre></td></tr></table></figure>


<p>要加载视图 2，运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:loadview 2</span><br></pre></td></tr></table></figure>


<p>要加载原始视图，运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:loadview</span><br></pre></td></tr></table></figure>


<h3 id="自动创建视图"><a href="#自动创建视图" class="headerlink" title="自动创建视图"></a>自动创建视图</h3><p>有一件可能会发生的很倒霉的事情是，您花了很长时间在一个大文件中进行折叠，一不小心关闭了窗口，接着丢失了所有折叠信息。您可以在 vimrc 中添加下列内容，使得在关闭缓冲区后 Vim 能自动创建视图，防止此类灾难发生：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">autocmd BufWinLeave *.txt mkview</span><br></pre></td></tr></table></figure>


<p>另外也能在打开缓冲区后自动加载视图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">autocmd BufWinEnter *.txt silent loadview</span><br></pre></td></tr></table></figure>


<p>现在，当您编辑 <code>txt</code> 文件时，不用再担心创建和加载视图了。但也注意，随着时间的推移，视图文件会不断积累，记得每隔几个月清理一次。</p>
<h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><p>如果说视图保存了某个窗口的设置，那么会话则保存了所有窗口（包括布局）的信息。</p>
<h3 id="创建新会话"><a href="#创建新会话" class="headerlink" title="创建新会话"></a>创建新会话</h3><p>假设您在 <code>foobarbaz</code> 工程中编辑着 3 个文件：</p>
<p><code>foo.txt</code> 的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">foo1</span><br><span class="line">foo2</span><br><span class="line">foo3</span><br><span class="line">foo4</span><br><span class="line">foo5</span><br><span class="line">foo6</span><br><span class="line">foo7</span><br><span class="line">foo8</span><br><span class="line">foo9</span><br><span class="line">foo10</span><br></pre></td></tr></table></figure>


<p><code>bar.txt</code> 的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bar1</span><br><span class="line">bar2</span><br><span class="line">bar3</span><br><span class="line">bar4</span><br><span class="line">bar5</span><br><span class="line">bar6</span><br><span class="line">bar7</span><br><span class="line">bar8</span><br><span class="line">bar9</span><br><span class="line">bar10</span><br></pre></td></tr></table></figure>


<p><code>baz.txt</code> 的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">baz1</span><br><span class="line">baz2</span><br><span class="line">baz3</span><br><span class="line">baz4</span><br><span class="line">baz5</span><br><span class="line">baz6</span><br><span class="line">baz7</span><br><span class="line">baz8</span><br><span class="line">baz9</span><br><span class="line">baz10</span><br></pre></td></tr></table></figure>


<p>假设您的窗口布局如下所示（适当地使用 <code>split</code> 和 <code>vsplit</code> 来放置）：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1620185126749-e195bcc1-336a-49af-9f87-a1e6a2343400.png#clientId=u52f13e61-1a27-4&from=drop&id=u54903b9d&margin=%5Bobject%20Object%5D&name=session-layout.png&originHeight=890&originWidth=1552&originalType=binary&size=23677&status=done&style=none&taskId=ueebb8a73-6946-4cd3-967d-58b3b2fbb7b" alt="session-layout.png"></p>
<p>要保留这个外观，您需要保存会话。运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:mksession</span><br></pre></td></tr></table></figure>


<p>与默认存储在 <code>~/.vim/view</code> 的 <code>mkview</code> 不同，<code>mksession</code> 在当前目录存储会话文件（<code>Session.vim</code>）。如果好奇，您可以看看文件。</p>
<p>如果您想将会话文件另存他处，可以将参数传递给 <code>mksession</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:mksession ~/some/where/else.vim</span><br></pre></td></tr></table></figure>


<p>使用 <code>!</code> 来调用命令可以覆盖一个已存在的会话文件（<code>:mksession! ~/some/where/else.vim</code>）。</p>
<h3 id="加载会话"><a href="#加载会话" class="headerlink" title="加载会话"></a>加载会话</h3><p>运行下列命令可以加载会话：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:source Session.vim</span><br></pre></td></tr></table></figure>


<p>现在 Vim 看起来就像您离开它时的样子！或者，您也可以从终端加载会话文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim -S Session.vim</span><br></pre></td></tr></table></figure>


<h3 id="配置会话属性"><a href="#配置会话属性" class="headerlink" title="配置会话属性"></a>配置会话属性</h3><p>您可以配置会话要保存的属性。若要查看当前哪些属性正被保存，请运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:set sessionoptions?</span><br></pre></td></tr></table></figure>


<p>我的显示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">blank,buffers,curdir,folds,help,tabpages,winsize,terminal</span><br></pre></td></tr></table></figure>


<p>如果在保存会话时不想存储 <code>terminal</code>，可以运行下列命令将其从会话选项中删除：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:set sessionoptions-=terminal</span><br></pre></td></tr></table></figure>


<p>如果要在保存会话时存储 <code>options</code>，请运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:set sessionoptions+=options</span><br></pre></td></tr></table></figure>


<p>下面是一些 <code>sessionoptions</code> 可以存储的属性：</p>
<ul>
<li><code>blank</code> 存储空窗口</li>
<li><code>buffers</code> 存储缓冲区</li>
<li><code>folds</code> 存储折叠</li>
<li><code>globals</code> 存储全局变量（必须以大写字母开头，并且至少包含一个小写字母）</li>
<li><code>options</code> 存储选项和映射</li>
<li><code>resize</code> 存储窗口行列</li>
<li><code>winpos</code> 存储窗口位置</li>
<li><code>winsize</code> 存储窗口大小</li>
<li><code>tabpages</code> 存储选项卡</li>
<li><code>unix</code> 以 Unix 格式存储文件</li>
</ul>
<p>查阅 <code>:h &#39;sessionoptions&#39;</code> 来获取完整列表。</p>
<p>会话是保存项目外部属性的好工具。但是，一些内部属性不存储在会话中，如本地标记、寄存器、历史记录等。要保存它们，您需要使用 Viminfo！</p>
<h2 id="Viminfo"><a href="#Viminfo" class="headerlink" title="Viminfo"></a>Viminfo</h2><p>如果您留意，在复制一个单词进寄存器 a，再退出并重新打开 Vim 后，您仍然可以看到存储在寄存器中的文本。这就是 Viminfo 的功劳。没有它，在您关闭 Vim 后，Vim 会忘记这些寄存器。</p>
<p>如果您使用 Vim 8 或更高版本，Vim 会默认启用 Viminfo。因此您可能一直在使用 Viminfo，而您对它毫不知情！</p>
<p>您可能会问：Viminfo 存储了什么？与会话有何不同？</p>
<p>要使用 Viminfo，您必须启用了 <code>+viminfo</code> 特性（<code>:version</code>）。Viminfo 存储着：</p>
<ul>
<li>命令行历史记录。</li>
<li>字符串搜索历史记录。</li>
<li>输入行历史记录。</li>
<li>非空寄存器的内容。</li>
<li>多个文件的标记。</li>
<li>文件标记，它指向文件中的位置。</li>
<li>上次搜索 / 替换模式（用于 “n” 和 “&amp;”）。</li>
<li>缓冲区列表。</li>
<li>全局变量。</li>
</ul>
<p>通常，会话存储“外部”属性，Viminfo 存储“内部”属性。</p>
<p>每个项目可以有一个会话文件，而 Viminfo 与会话不同，通常每台计算机只使用一个 Viminfo。Viminfo 是项目无关的。</p>
<p>对于 Unix，Viminfo 的默认位置是 <code>$HOME/.viminfo</code>（<code>~/.viminfo</code>）。根据您的操作系统，Viminfo 位置可能会有所不同。可以查阅 <code>:h viminfo-file-name</code>。每一次您做出的“内部”更改，如将文本复制进一个寄存器，Vim 都会自动更新 Viminfo 文件。</p>
<p><em>请确保您设置了  选项（），否则您的 Viminfo 将不起作用。</em></p>
<h3 id="读写-Viminfo"><a href="#读写-Viminfo" class="headerlink" title="读写 Viminfo"></a>读写 Viminfo</h3><p>尽管只使用一个 Viminfo 文件，但您还是可以创建多个 Viminfo 文件。使用 <code>:wviminfo</code> 命令（缩写为 <code>:wv</code>）来创建多个 Viminfo 文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:wv ~/.viminfo_extra</span><br></pre></td></tr></table></figure>


<p>要覆盖现有的 Viminfo 文件，向 <code>wv</code> 命令多添加一个叹号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:wv! ~/.viminfo_extra</span><br></pre></td></tr></table></figure>


<p>Vim 默认情况下会读取 <code>~/.viminfo</code> 文件。运行 <code>:rviminfo</code>（缩写为 <code>:rv</code>）可以读取不同的 Vimfile 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:rv ~/.viminfo_extra</span><br></pre></td></tr></table></figure>


<p>要在终端使用不同的 Viminfo 文件来启动 Vim，请使用 “i” 标志：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim -i viminfo_extra</span><br></pre></td></tr></table></figure>


<p>如果您要将 Vim 用于不同的任务，比如写代码和写作，您可以创建两个 Viminfo，一个针对写作优化，另一个为写代码优化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim -i viminfo_writing</span><br><span class="line"></span><br><span class="line">vim -i viminfo_coding</span><br></pre></td></tr></table></figure>


<h3 id="不使用-Viminfo-启动-Vim"><a href="#不使用-Viminfo-启动-Vim" class="headerlink" title="不使用 Viminfo 启动 Vim"></a>不使用 Viminfo 启动 Vim</h3><p>要不使用 Viminfo 启动 Vim，可以在终端运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim -i NONE</span><br></pre></td></tr></table></figure>


<p>要永不使用 Viminfo，可以在您的 vimrc 文件添加：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set viminfo=&quot;NONE&quot;</span><br></pre></td></tr></table></figure>


<h3 id="配置-Viminfo-属性"><a href="#配置-Viminfo-属性" class="headerlink" title="配置 Viminfo 属性"></a>配置 Viminfo 属性</h3><p>和 <code>viewoptions</code> 以及 <code>sessionoptions</code> 类似，您可以用 <code>viminfo</code> 选项指定要存储的属性。请运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:set viminfo?</span><br></pre></td></tr></table></figure>


<p>您会得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">!,&#x27;100,&lt;50,s10,h</span><br></pre></td></tr></table></figure>


<p>看起来有点晦涩难懂。命令分解如下：</p>
<ul>
<li><code>!</code> 保存以大写字母开头、却不包含小写字母的全局变量。回想一下 <code>g:</code> 代表了一个全局变量。例如，假设您写了赋值语句 <code>let g:FOO = &quot;foo&quot;</code>，Viminfo 将存储全局变量 <code>FOO</code>。然而如果您写了 <code>let g:Foo = &quot;foo&quot;</code>，Viminfo 将不存储它，因为它包含了小写字母。没有 <code>!</code>，Vim 不会存储这些全局变量。</li>
<li><code>&#39;100</code> 代表标记。在这个例子中，Viminfo 将保存最近 100 个文件的本地标记（a-z）。注意，如果存储的文件过多，Vim 会变得很慢，1000 左右就可以了。</li>
<li><code>&lt;50</code> 告诉 Viminfo 每个寄存器最多保存多少行（这个例子中是 50 行）。如果我复制 100 行文本进寄存器 a（<code>&quot;ay99j</code>）后关闭 Vim，下次打开 Vim 并从寄存器 a（<code>&quot;ap</code>）粘贴时，Vim 最多只粘贴 50 行；如果不指定最大行号，_所有_行都将被保存；如果指定 0，什么都不保存了。</li>
<li><code>s10</code> 为寄存器设置大小限制（kb）。在这个例子中，任何大于 10kb 的寄存器都会被排除。</li>
<li><code>h</code> 禁用高亮显示（<code>hlsearch</code> 时）。</li>
</ul>
<p>可以查阅 <code>:h &#39;viminfo&#39;</code> 来了解其他更多选项。</p>
<h2 id="聪明地使用视图、会话和-Viminfo"><a href="#聪明地使用视图、会话和-Viminfo" class="headerlink" title="聪明地使用视图、会话和 Viminfo"></a>聪明地使用视图、会话和 Viminfo</h2><p>Vim 能使用视图、会话和 Viminfo 来保存不同级别的 Vim 环境快照。对于微型项目，可以使用视图；对于大型项目，可以使用会话。您应该花些时间来查阅视图、会话和 Viminfo 提供的所有选项。</p>
<p>为您的编辑风格创建属于您自己的视图、会话和 Viminfo。如果您要换台计算机使用 Vim，只需加载您的设置，立刻就会感到宾至如归！</p>
<h1 id="许可和版权"><a href="#许可和版权" class="headerlink" title="许可和版权"></a>许可和版权</h1><p>这些材料全部归 ©2020 Igor Irianto 所有。</p>
<p><img src="https://licensebuttons.net/l/by-nc-sa/4.0/88x31.png#id=RvMY0&originHeight=31&originWidth=88&originalType=binary&status=done&style=none"></p>
<p>这项作品已获得<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">&lt;&lt;知识共享署名-非商业性-相同方式共享 4.0 版&gt;&gt;</a>的许可。</p>
]]></content>
      <categories>
        <category>工具篇</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>聪明的学习Vim（上）</title>
    <url>/2020/05/21/%E8%81%AA%E6%98%8E%E7%9A%84%E5%AD%A6%E4%B9%A0Vim%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇文章转载的GitHub上一个很火的项目<br><a href="https://github.com/iggredible/Learn-Vim">英文版本</a></p>
<h1 id="Vim-语法"><a href="#Vim-语法" class="headerlink" title="Vim 语法"></a>Vim 语法</h1><p>刚接触Vim时很容易被Vim许多复杂的命令吓到，如果你看到一个Vim的用户使用<code>gUfV</code>或<code>1GdG</code>，你可能不能立刻想到这些命令是在做什么。这一章中，我将把Vim命令的结构拆分成一个简单的语法规则进行讲解。</p>
<p>这一章将是本书中最重要的一章，一旦你理解了Vim命令的语法结构，你将能够和Vim”说话”。注意，在这一章中当我讨论Vim语言时，我讨论并不是<br>Vimscript(Vim自带的插件编写和自定义设置的语言)，这里我讨论的是Vim中normal模式的下的命令的通用规则。</p>
<h2 id="如何学习一门语言"><a href="#如何学习一门语言" class="headerlink" title="如何学习一门语言"></a>如何学习一门语言</h2><p>我并不是一个英语为母语的人，当我13岁移民到美国时我学习的英语，我会通过做三件事情建立我的语言能力：</p>
<ol>
<li>学习语法规则</li>
<li>扩展我的词汇量</li>
<li>练习，练习，练习</li>
</ol>
<p>同样的，为了说好Vim语言，你需要学习语法规则，增加词汇量，并且不断练习直到你可以把执行命令变成肌肉记忆。</p>
<h2 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h2><p>你只需要知道一个Vim语言的语法规则：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">verb + noun # 动词 + 名词</span><br></pre></td></tr></table></figure>


<p>这就类似与在英语中的祈使句：</p>
<ul>
<li>Eat(verb) a donut(noun)</li>
<li>Kick(verb) a ball(noun)</li>
<li>Learn(verb) the Vim Editor(noun)</li>
</ul>
<p>现在你需要的就是用Vim中基本的动词和名字来建立你的词汇表</p>
<h2 id="词汇表"><a href="#词汇表" class="headerlink" title="词汇表"></a>词汇表</h2><h3 id="名词-动作-Motion"><a href="#名词-动作-Motion" class="headerlink" title="名词(动作 Motion)"></a>名词(动作 Motion)</h3><p>我们这里将<strong>动作</strong>作为名词，<strong>动作</strong>用来在Vim中到处移动，他们也是Vim中的名词。下面列出了一些常见的<strong>动作</strong>的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">h	左</span><br><span class="line">j	下</span><br><span class="line">k	上</span><br><span class="line">l	右</span><br><span class="line">w	向前移动到下一个单词的开头</span><br><span class="line">&#125;	跳转到下一个段落</span><br><span class="line">$	跳转到当前行的末尾</span><br></pre></td></tr></table></figure>


<p>在之后的章节你将学习更多的关于<strong>动作</strong>的内容，所以如果你不理解上面这些<strong>动作</strong>也不必担心。</p>
<h3 id="动词-操作符-Operator"><a href="#动词-操作符-Operator" class="headerlink" title="动词(操作符 Operator)"></a>动词(操作符 Operator)</h3><p>根据<code>:h operator</code>，Vim共有16个<strong>操作符</strong>，然而根据我的经验，学习这3个<strong>操作符</strong>在80%的情况下就已经够用了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">y	yank(复制)</span><br><span class="line">d	delete(删除)</span><br><span class="line">c	change 删除文本，将删除的文本存到寄存器中，进入插入模式</span><br></pre></td></tr></table></figure>


<p>现在你已经知道了基本的动词和名词，我们来用一下我们的语法规则。假设你有下面这段文本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const learn = &quot;Vim&quot;;</span><br></pre></td></tr></table></figure>


<ul>
<li>复制当前位置到行尾的所有内容：<code>y$</code></li>
<li>删除当前位置到下一个单词的开头：<code>dw</code></li>
<li>修改当前位置到这个段落的结尾：<code>c&#125;</code></li>
</ul>
<p><strong>动作</strong>也接受数字作为参数(这个部分我将在下个章节展开)，如果你需要向上移动3行，你可以用<code>3k</code>代替按3次<code>k</code></p>
<ul>
<li>向左拷贝2个字符：<code>y2h</code></li>
<li>删除后两个单词：<code>d2w</code></li>
<li>修改后面两行：<code>c2j</code></li>
</ul>
<p>目前，你也许需要想很久才能完成一个简单的命令，不过我刚开始时也是这样，我也经历过类似的挣扎的阶段但是不久我的速度就快了起来，你也一样。</p>
<p>作为补充，行级的<strong>操作符</strong>在文本编辑中和其他的<strong>操作符</strong>一样，Vim允许你通过按两次命令执行行级的操作，例如<code>dd</code>，<code>yy</code>，<code>cc</code>来执行删除，复制或修改整个行。</p>
<p>我希望这些内容能够对你有用，但是到目前为止还没有结束，Vim有另一种类型的名词：文本对象(text object)</p>
<h2 id="更多名词-文本对象"><a href="#更多名词-文本对象" class="headerlink" title="更多名词(文本对象)"></a>更多名词(文本对象)</h2><p>想象一下你现在正在某个被括号包围的文本中例如<code>(hello Vim)</code>，你现在想要删掉括号中的所有内容，你会怎样快速的完成它？是否有一种方法能够把括号中内容作为整体删除呢？</p>
<p>答案是有的。文本通常是结构化的，特别是代码经常被放置在小括号、中括号、大括号、引号等当中。Vim提供了一种处理这种结构的文本对象的方法。</p>
<p>文本对象可以被<strong>操作符</strong>使用，这里有两类文本对象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i + object  内部文本对象</span><br><span class="line">a + object  外部文本对象</span><br></pre></td></tr></table></figure>


<p><strong>内部文本对象</strong>选中的部分不包含包围文本对象的空白或括号等，<strong>外部文本对象</strong>则包括了包围内容的空白或括号等对象。外部对象总是比内部对象选中的内容更多，因此如果你的光标位于一对括号内部，例如<code>(hello Vim)</code>中：</p>
<ul>
<li>删除括号内部的内容但保留括号：<code>di(</code></li>
<li>删除括号以及内部的内容：<code>da(</code></li>
</ul>
<p>让我们看一些别的例子，假设你有这样一段Javascript的函数，你的光标停留在”Hello”上：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const hello = function() &#123;</span><br><span class="line">    console.log(&quot;Hello Vim&quot;);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>删除整个”Hello Vim”：<code>di(</code></li>
<li>删除整个函数(被{}包含)：<code>di&#123;</code></li>
<li>删除”Hello”这个词：<code>diw</code></li>
</ul>
<p>文本对象很强大因为你可以在一个位置指向不同的对象，能够删除一对括号、函数体或整个单词的文本对象中的内容。此外，当你看到<code>di(</code>，<code>di&#123;</code>和<code>diw</code>时，你也可以很好的意识到他们表示的是什么。</p>
<p>让我们来看最后一个例子。假设你有这样一些html的标签的文本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;h1&gt;Header1&lt;/h1&gt;</span><br><span class="line">  &lt;p&gt;Paragraph1&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Paragraph2&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>


<p>如果你的光标位于”Header1”文本上：</p>
<ul>
<li>删除”Header1”：<code>dit</code></li>
<li>删除<code>&lt;h1&gt;Header1&lt;/h1&gt;</code>：<code>dat</code></li>
</ul>
<p>如果你的光标在”div”文本上：</p>
<ul>
<li>删除<code>h1</code>和所有<code>p</code>标签的行：<code>dit</code></li>
<li>删除所有文本：<code>dat</code></li>
<li>删除”div”：<code>di&lt;</code></li>
</ul>
<p>下面列举的一些通常见到的文本对象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">w     一个单词</span><br><span class="line">p     一个段落</span><br><span class="line">s     一个句子</span><br><span class="line">(或)  一对()</span><br><span class="line">&#123;或&#125;  一对&#123;&#125;</span><br><span class="line">[或]  一对[]</span><br><span class="line">&lt;或&gt;  一对&lt;&gt;</span><br><span class="line">t     XML标签</span><br><span class="line">&quot;     一对&quot;&quot;</span><br><span class="line">&#x27;     一对&#x27;&#x27;</span><br><span class="line">`     一对``</span><br></pre></td></tr></table></figure>


<p>你可以通过<code>:h text-objects</code>了解更多</p>
<h2 id="结合性和语法"><a href="#结合性和语法" class="headerlink" title="结合性和语法"></a>结合性和语法</h2><p>在学习Vim的语法之后，让我们来讨论一下Vim中的结合性以及为什么在文本编辑器中这是一个强大的功能。</p>
<p>结合性意味着你有很多可以组合起来完成更复杂命令的普通命令，就像你在编程中可以通过一些简单的抽象建立更复杂的抽象，在Vim中你可以通过简单的命令的组合执行更复杂的命令。Vim语法正是Vim中命令的可结合性的体现。</p>
<p>Vim的结合性最强大之处体现在它和外部程序结合时，Vim有一个<strong>过滤操作符</strong><code>!</code>可以用外部程序过滤我们的文本。假设你有下面这段混乱的文本并且你想把它用tab格式化的更好看的一些：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Id|Name|Cuteness</span><br><span class="line">01|Puppy|Very</span><br><span class="line">02|Kitten|Ok</span><br><span class="line">03|Bunny|Ok</span><br></pre></td></tr></table></figure>


<p>这件事情通过Vim命令不太容易完成，但是你可以通过终端提供的命令<code>column</code>很快的完成它，当你的光标位于”Id”上时，运行<code>!&#125;column -t -s &quot;|&quot;</code>，你的文本就变得整齐了许多：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Id  Name    Cuteness</span><br><span class="line">01  Puppy   Very</span><br><span class="line">02  Kitten  Ok</span><br><span class="line">03  Bunny   Ok</span><br></pre></td></tr></table></figure>


<p>让我们分解一下上面那条命令，动词是<code>!</code>(<strong>过滤操作符</strong>)，名词是<code>&#125;</code>(到下一个段落)。<strong>过滤操作符</strong><code>!</code>接受终端命令作为另一个参数，因此我把<code>column -t -s &quot;|&quot;</code>传给它。我不想详细描述<code>column</code>是如何工作的，但是总之它格式化了文本。</p>
<p>假设你不止想格式化你的文本，还想只展示<code>Ok</code>结尾的行，你知道<code>awk</code>命令可以做这件事情，那么你可以这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">!&#125;column -t -s &quot;|&quot; | awk &#x27;NR &gt; 1 &amp;&amp; /Ok/&#123;print $0&#125;&#x27;</span><br></pre></td></tr></table></figure>


<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">02  Kitten  Ok</span><br><span class="line">03  Bunny   Ok</span><br></pre></td></tr></table></figure>


<p>666！管道竟然在Vim中也能起作用。</p>
<p>这就是Vim的结合性的强大之处。你知道的<strong>操作符</strong>，<strong>动作</strong>，终端命令越多，你组建复杂操作的能力成倍增长。</p>
<p>换句话说，假设你只知道四个<strong>动作</strong>：<code>w, $, &#125;, G</code>和删除操作符(<code>d</code>)，你可以做8件事：按四种方式移动(<code>w, $, &#125;, G</code>)和删除4种文本对象(<code>dw, d$, d&#125;, dG</code>)。如果有一天你学习了小写变大写的<strong>操作符</strong>(<code>gU</code>)，你的Vim工具箱中多的不是1种工具，而是4种：<code>gUw, gU$, gU&#125;, gUG</code>。现在你的Vim工具箱中就有12种工具了。如果你知道10个<strong>动作</strong>和5个<strong>操作符</strong>，那么你就有60种工具(50个操作+10个移动)。另外，行号动作(<code>nG</code>)给你了<code>n</code>种<strong>动作</strong>，其中<code>n</code>是你文件中的行数(例如前往第5行，<code>5G</code>)。搜索动作(<code>/</code>)实际上给你带来无限数量的<strong>动作</strong>因为你可以搜索任何内容。你知道多少终端命令，外部命令操作符(<code>!</code>)就给你了多少种过滤工具。使用Vim这种能够组合的工具，所有你知道的东西都可以被串起来完成更复杂的操作。你知道的越多，你就越强大。</p>
<p>这种具有结合性的行为也正符合Unix的哲学：_一个命令做好一件事_。<strong>动作</strong>只需要做一件事：前往X。<strong>操作符</strong>只需要做一件事：完成Y。通过结合一个<strong>操作符</strong>和一个<strong>动作</strong>，你就获得了YX：在X上完成Y。</p>
<p>甚至，<strong>动作</strong>和<strong>操作符</strong>都是可拓展的，你可以自己创造<strong>动作</strong>和<strong>操作符</strong>去丰富你的Vim工具箱，<code>Vim-textobj-user</code>有一系列自定义的文本对象。</p>
<p>另外，如果你不知道我刚才使用的<code>column</code>和<code>awk</code>命令也没有关系，重要的是Vim可以和终端命令很好的结合起来。</p>
<h2 id="聪明地学习语法"><a href="#聪明地学习语法" class="headerlink" title="聪明地学习语法"></a>聪明地学习语法</h2><p>你刚刚学完Vim唯一的语法规则：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">verb + noun</span><br></pre></td></tr></table></figure>


<p>我学Vim中最大的”AHA moment”之一是当我刚学完大写命令(<code>gU</code>)时，想要把一个单词变成大写，我本能的运行了<code>gUiW</code>，它居然成功了，我光标所在的单词都大写了。我正是从那是开始理解Vim的。我希望你也会在不久之后有你自己的”AHA moment”，如果之前没有的话。</p>
<p>这一章的目标是向你展现Vim中的<code>verb+noun</code>模式，因此之后你就可以像学习一门新的语言一样渐进的学习Vim而不是死记每个命令的组合。</p>
<p>学习这种模式并且理解其中的含义，这是聪明的学习方式。</p>
<h1 id="在文件中移动"><a href="#在文件中移动" class="headerlink" title="在文件中移动"></a>在文件中移动</h1><p>一开始，通过键盘移动会让你感觉特别慢特别不自在，但是不要放弃！一旦你习惯了它，比起鼠标你可以更快的在文件中去到任何地方。</p>
<p>这一章，你将学习必要的移动以及如何高效的使用它们。 记住，这一章所讲的并不是Vim的全部移动命令，我们的目标是介绍有用的移动来快速提高效率。 如果你需要学习更多的移动命令，查看<code>:h motion.txt</code>。</p>
<h2 id="字符导航"><a href="#字符导航" class="headerlink" title="字符导航"></a>字符导航</h2><p>最基本的移动单元是上下左右移动一个字符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">h   左</span><br><span class="line">j   下</span><br><span class="line">k   上</span><br><span class="line">l   右</span><br></pre></td></tr></table></figure>


<p>你也可以通过方向键进行移动，如果你只是初学者，使用任何你觉得最舒服的方法都没有关系。</p>
<p>我更喜欢<code>hjkl</code>因为我的右手可以保持在键盘上的默认姿势，这样做可以让我更快的敲到周围的键。 为了习惯它，我实际上在刚开始的时候通过<code>~/.vimrc</code>关闭了方向键：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">noremap &lt;Up&gt; &lt;NOP&gt;</span><br><span class="line">noremap &lt;Down&gt; &lt;NOP&gt;</span><br><span class="line">noremap &lt;Left&gt; &lt;NOP&gt;</span><br><span class="line">noremap &lt;Right&gt; &lt;NOP&gt;</span><br></pre></td></tr></table></figure>


<p>也有一些插件可以帮助改掉这个坏习惯，其中有一个叫<a href="https://github.com/takac/vim-hardtime">vim-hardtime</a>。 让我感到惊讶的是，我只用了几天就习惯了使用<code>hjkl</code>。</p>
<p>另外，如果你想知道为什么Vim使用<code>hjkl</code>进行移动，_这实际上是因为Bill Joy写VI用的Lear-Siegler ADM-3A终端没有方向键，而是把当做方向键_。</p>
<p>如果你想移动到附近的某个地方，比如从一个单词的一个部分移动到另一个部分，我会使用<code>h</code>和<code>l</code>。 如果我需要在可见的范围内上下移动几行，我会使用<code>j</code>和<code>k</code>。 如果我想去更远的地方，我倾向于使用其他移动命令。</p>
<h2 id="相对行号"><a href="#相对行号" class="headerlink" title="相对行号"></a>相对行号</h2><p>我觉得设置<code>number</code>和<code>relativenumber</code>非常有用，你可以在<code>~/.vimrc</code>中设置:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set relativenumber number</span><br></pre></td></tr></table></figure>


<p>这将会展示当前行号和其他行相对当前行的行号。</p>
<p>为什么这个功能有用呢？这个功能能够帮助我知道我离我的目标位置差了多少行，有了它我可以很轻松的知道我的目标行在我下方12行，因此我可以使用<code>12j</code>去前往。 否则，如果我在69行，我的目标是81行，我需要去计算81-69=12行，这太费劲了，当我需要去一个地方时，我需要思考的部分越少越好。</p>
<p>这是一个100%的个人偏好，你可以尝试<code>relativenumber</code>/<code>norelativenumber</code>，<code>number</code>/<code>nonumber</code> 然后选择自己觉得最有用的。</p>
<h2 id="对移动计数"><a href="#对移动计数" class="headerlink" title="对移动计数"></a>对移动计数</h2><p>在继续之前，让我们讨论一下”计数”参数。 一个移动可以接受一个数字前缀作为参数，上面我提到的你可以通过<code>12j</code>向下移动12行，其中<code>12j</code>中的<code>12</code>就是计数数字。</p>
<p>你使用带计数的移动的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[计数] + 移动</span><br></pre></td></tr></table></figure>


<p>你可以把这个应用到所有移动上，如果你想向右移动9个字符，你可以使用<code>9l</code>来代替按9次<code>l</code>。 当你学到了更多的动作时，你都可以试试给定计数参数。</p>
<h2 id="单词导航"><a href="#单词导航" class="headerlink" title="单词导航"></a>单词导航</h2><p>我们现在移动一个更长的单元：单词(word)。 你可以通过<code>w</code>移动到下一个单词的开始，通过<code>e</code>移动到下一个单词的结尾，通过<code>b</code>移动到上一个单词的开始，通过<code>ge</code>移动到前一个单词的结尾。</p>
<p>另外，为了和上面说的单词(word)做个区分，还有一种移动的单元：词组(WORD)。 你可以通过<code>W</code>移动到下一个词组的开始，通过<code>E</code>移动到下一个词组的结尾，通过<code>B</code>移动到前一个词组的开头，通过<code>gE</code>移动到前一个词组的结尾。 为了方便记忆，所以我们选择了词组和单词这两个词，相似但有些区分。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">w		移动到下一个单词的开头</span><br><span class="line">W		移动到下一个词组的开头</span><br><span class="line">e		移动到下一个单词的结尾</span><br><span class="line">E		移动到下一个词组的结尾</span><br><span class="line">b		移动到前一个单词的开头</span><br><span class="line">B		移动到前一个词组的开头</span><br><span class="line">ge	移动到前一个单词的结尾</span><br><span class="line">gE	移动到前一个词组的结尾</span><br></pre></td></tr></table></figure>


<p>词组和单词到底有什么相同和不同呢？单词和词组都按照非空字符被分割，一个单词指的是一个只包含<code>a-zA-Z0-9</code>字符串，一个词组指的是一个包含除了空字符(包括空格，tab，EOL)以外的字符的字符串。 你可以通过<code>:h word</code>和<code>:h WORD</code>了解更多。</p>
<p>例如，假如你有下面这段内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const hello = &quot;world&quot;;</span><br></pre></td></tr></table></figure>


<p>当你光标位于这行的开头时，你可以通过<code>l</code>走到行尾，但是你需要按21下，使用<code>w</code>，你需要6下，使用<code>W</code>只需要4下。 单词和词组都是短距离移动的很好的选择。</p>
<p>然而，之后你可以通过当前行导航只按一次从<code>c</code>移动到<code>;</code>。</p>
<h2 id="当前行导航"><a href="#当前行导航" class="headerlink" title="当前行导航"></a>当前行导航</h2><p>当你在进行编辑的时候，你经常需要水平地在一行中移动，你可以通过<code>0</code>跳到本行第一个字符，通过<code>$</code>跳到本行最后一个字符。 另外，你可以使用<code>^</code>跳到本行第一个非空字符，通过<code>g_</code>跳到本行最后一个非空字符。 如果你想去当前行的第n列，你可以使用<code>n|</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0		跳到本行第一个字符</span><br><span class="line">^		跳到本行第一个非空字符</span><br><span class="line">g_  跳到本行最后一个非空字符</span><br><span class="line">$		跳到本行最后一个字符</span><br><span class="line">n|  跳到本行第n列</span><br></pre></td></tr></table></figure>


<p>你也可以在本行通过<code>f</code>和<code>t</code>进行行内搜索，<code>f</code>和<code>t</code>的区别在于<code>f</code>会停在第一个匹配的字母上，<code>t</code>会停在第一个匹配的字母前。 因此如果你想要搜索并停留在”h”上，使用<code>fh</code>。 如果你想搜索第一个”h”并停留在它的前一个字母上，可以使用<code>th</code>。 如果你想去下一个行内匹配的位置，使用<code>;</code>，如果你想去前一个行内匹配的位置，使用<code>,</code>。</p>
<p>如果想向前搜索”h”，可以使用<code>Fh</code>，使用<code>;</code>，保持相同的搜索方向搜索下一个匹配的字母。 注意，<code>;</code>不是总是向后搜索，<code>;</code>表示的是上一次搜索的方向，因此如果你使用的<code>F</code>，那么使用<code>;</code>时将会向前搜索使用<code>,</code>时向后搜索。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f   在同一行向后搜索第一个匹配</span><br><span class="line">F   在同一行向前搜索第一个匹配</span><br><span class="line">t   在同一行向后搜索第一个匹配，并停在匹配前</span><br><span class="line">T   在同一行向前搜索第一个匹配，并停在匹配前</span><br><span class="line">;   在同一行重复最近一次搜索</span><br><span class="line">,   在同一行向相反方向重复最近一次搜索</span><br></pre></td></tr></table></figure>


<p>回到上一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const hello = &quot;world&quot;;</span><br></pre></td></tr></table></figure>


<p>当你的光标位于行的开头时，你可以通过按一次键<code>$</code>去往行尾的最后一个字符”;”。 如果想去往”world”中的”w”，你可以使用<code>fw</code>。 一个建议是，在行内目标附近通过寻找重复出现最少的字母例如”j”，”x”，”z”来前往行中的该位置更快。</p>
<h2 id="句子和段落导航"><a href="#句子和段落导航" class="headerlink" title="句子和段落导航"></a>句子和段落导航</h2><p>接下来两个移动的单元是句子和段落。</p>
<p>首先我们来聊聊句子。 一个句子的定义是以<code>.!?</code>和跟着的一个换行符或空格，tab结尾的。 你可以通过<code>)</code>和<code>(</code>跳到下一个和上一个句子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(   跳到前一个句子</span><br><span class="line">)   跳到下一个句子</span><br></pre></td></tr></table></figure>


<p>让我们来看一些例子，你觉得哪些字段是句子哪些不是? 可以尝试在Vim中用<code>(</code>和<code>)</code>感受一下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I am a sentence. I am another sentence because I end with a period. I am still a sentence when ending with an exclamation point! What about question mark? I am not quite a sentence because of the hyphen - and neither semicolon ; nor colon :</span><br><span class="line"></span><br><span class="line">There is an empty line above me.</span><br></pre></td></tr></table></figure>


<p>另外，如果你的Vim中遇到了无法将一个以<code>.</code>结尾的字段并且后面跟着一个空行的这种情况判断为一个句子的问题，你可能处于<code>compatible</code>的模式。 运行<code>:set nocompatible</code>可以修复。 在Vi中，一个句子是以<strong>两个</strong>空格结尾的，你应该总是保持的<code>nocompatible</code>的设置。</p>
<p>接下来，我们将讨论什么是段落。 一个段落可以从一个空行之后开始，也可以从段落选项中字符对所指定的段落宏的每个集合开始。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;   跳转到上一个段落</span><br><span class="line">&#125;   跳转到下一个段落</span><br></pre></td></tr></table></figure>


<p>如果你不知道什么是段落宏，不用担心，重要的是一个段落总是以一个空行开始和结尾， 在大多数时候总是对的。</p>
<p>我们来看这个例子。 你可以尝试着使用<code>&#125;</code>和<code>&#123;</code>进行导航，也可以试一试<code>()</code>这样的句子导航。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello. How are you? I am great, thanks!</span><br><span class="line">Vim is awesome.</span><br><span class="line">It may not easy to learn it at first...- but we are in this together. Good luck!</span><br><span class="line"></span><br><span class="line">Hello again.</span><br><span class="line"></span><br><span class="line">Try to move around with ), (, &#125;, and &#123;. Feel how they work.</span><br><span class="line">You got this.</span><br></pre></td></tr></table></figure>


<p>你可以通过<code>:h setence</code>和<code>:h paragraph</code>了解更多。</p>
<h2 id="匹配导航"><a href="#匹配导航" class="headerlink" title="匹配导航"></a>匹配导航</h2><p>程序员经常编辑含有代码的文件，这种文件内容会包含大量的小括号，中括号和大括号，并且可能会把你搞迷糊你当前到底在哪对括号里。 许多编程语言都用到了小括号，中括号和大括号，你可能会迷失于其中。 如果你在它们中的某一对括号中，你可以通过<code>%</code>跳到其中一个括号或另一个上(如果存在)。 你也可以通过这种方法弄清你是否各个括号都成对匹配了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%    Navigate to another match, usually works for (), [], &#123;&#125;</span><br></pre></td></tr></table></figure>


<p>我们来看一段Scheme代码示例因为它用了大量的小括号。 你可以在括号中用<code>%</code>移动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(define (fib n)</span><br><span class="line">  (cond ((= n 0) 0)</span><br><span class="line">        ((= n 1) 1)</span><br><span class="line">        (else</span><br><span class="line">          (+ (fib (- n 1)) (fib (- n 2)))</span><br><span class="line">        )))</span><br></pre></td></tr></table></figure>


<p>我个人喜欢使用类似<a href="https://github.com/frazrepo/vim-rainbow">vim-rainbow</a>这样的可视化指示插件来作为<code>%</code>的补充。 通过<code>:h %</code>了解更多。</p>
<h2 id="行号导航"><a href="#行号导航" class="headerlink" title="行号导航"></a>行号导航</h2><p>你可以通过<code>nG</code>调到行号为<code>n</code>的行，例如如果你想跳到第7行，你可以使用<code>7G</code>，跳到第一行使用<code>gg</code>或<code>1G</code>，跳到最后一行使用<code>G</code>。</p>
<p>有时你不知道你想去的位置的具体行号，但是知道它大概在整个文件的70%左右的位置，你可以使用<code>70%</code>跳过去，可以使用<code>50%</code>跳到文件的中间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gg      跳转到第一行</span><br><span class="line">G       跳转到最后一行</span><br><span class="line">nG      跳转到第n行</span><br><span class="line">n%      跳到文件的n%</span><br></pre></td></tr></table></figure>


<p>另外，如果你想看文件总行数，可以用<code>CTRL-g</code>查看。</p>
<h2 id="窗格导航"><a href="#窗格导航" class="headerlink" title="窗格导航"></a>窗格导航</h2><p>为了移动到当前窗格的顶部，中间，底部，你可以使用<code>H</code>，<code>M</code>和<code>L</code>。</p>
<p>你也可以给<code>H</code>和<code>L</code>传一个数字前缀。 如果你输入<code>10H</code>你会跳转到窗格顶部往下数10行的位置，如果你输入<code>3L</code>，你会跳转到距离当前窗格的底部一行向上数3行的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">H   跳转到屏幕的顶部</span><br><span class="line">M   跳转到屏幕的中间</span><br><span class="line">L   跳转到屏幕的底部</span><br><span class="line">nH  跳转到距离顶部n行的位置</span><br><span class="line">nL  跳转到距离底部n行的位置</span><br></pre></td></tr></table></figure>


<h2 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h2><p>在文件中滚动，你有三种速度可以选择： 滚动一整页(<code>CTRL-F</code>/<code>CTRL-B</code>)，滚动半页(<code>CTRL-D</code>/<code>CTRL-U</code>)，滚动一行<code>CTRL-E</code>/<code>CTRL-Y</code>)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ctrl-e    向下滚动一行</span><br><span class="line">Ctrl-d    向下滚动半屏</span><br><span class="line">Ctrl-f    向下滚动一屏</span><br><span class="line">Ctrl-y    向上滚动一行</span><br><span class="line">Ctrl-u    向上滚动半屏</span><br><span class="line">Ctrl-b    向上滚动一屏</span><br></pre></td></tr></table></figure>


<p>你也可以相对当前行进行滚动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zt    将当前行置于屏幕顶部附近</span><br><span class="line">zz    将当前行置于屏幕中央</span><br><span class="line">zb    将当前行置于屏幕底部</span><br></pre></td></tr></table></figure>


<h2 id="搜索导航"><a href="#搜索导航" class="headerlink" title="搜索导航"></a>搜索导航</h2><p>通常，你已经知道这个文件中有一个字段，你可以通过搜索导航非常快速的定位你的目标。 你可以通过<code>/</code>向下搜索，也可以通过<code>?</code>向上搜索一个字段。 你可以通过<code>n</code>重复最近一次搜索，<code>N</code>向反方向重复最近一次搜索。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/   向后搜索一个匹配</span><br><span class="line">?   向前搜素一个匹配</span><br><span class="line">n   重复上一次搜索(和上一次方向相同)</span><br><span class="line">N   重复上一次搜索(和上一次方向相反)</span><br></pre></td></tr></table></figure>


<p>假设你有一下文本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let one = 1;</span><br><span class="line">let two = 2;</span><br><span class="line">one = &quot;01&quot;;</span><br><span class="line">one = &quot;one&quot;;</span><br><span class="line">let onetwo = 12;</span><br></pre></td></tr></table></figure>


<p>你可以通过<code>/let</code>搜索”let”，然后通过<code>n</code>快速的重复搜索下一个”let”，如果需要向相反方向搜索，可以使用<code>N</code>。 如果你用<code>?let</code>搜索，会得到一个向前的搜索，这时你使用<code>n</code>，它会继续向前搜索，就和<code>?</code>的方向一致。(<code>N</code>将会向后搜索”let”)。</p>
<p>你可以通过<code>:set hlsearch</code>设置搜索高亮。 这样，当你搜索<code>/let</code>，它将高亮文件中所有匹配的字段。 另外，如果你通过<code>:set incsearch</code>设置了增量搜索，它将在你输入时不断匹配的输入的内容。 默认情况下，匹配的字段会一直高亮到你搜索另一个字段，这有时候很烦人，如果你希望取消高亮，可以使用<code>:nohlsearch</code>。 因为我经常使用这个功能，所以我会设置一个映射：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nnoremap &lt;esc&gt;&lt;esc&gt; :noh&lt;return&gt;&lt;esc&gt;</span><br></pre></td></tr></table></figure>


<p>你可以通过<code>*</code>快速的向下搜索光标下的文本，通过<code>#</code>快速向前搜索光标下的文本。 如果你的光标位于一个字符串”one”上，按下<code>*</code>相当于<code>/\&lt;one\&gt;</code>。<br><code>/\&lt;one\&gt;</code>中的<code>\&lt;</code>和<code>\&gt;</code>表示整词匹配，使得一个更长的包含”one”的单词不会被匹配上，也就是说它会匹配”one”，但不会匹配”onetwo”。 如果你的光标在”one”上并且你想向后搜索完全或部分匹配的单词，例如”one”和”onetwo”，你可以用<code>g*</code>替代<code>*</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*   向后查找光标所在的完整单词</span><br><span class="line">#   向前查找光标所在的完整单词</span><br><span class="line">g*  向后搜索光标所在的单词</span><br><span class="line">g#  向前搜索光标所在的单词</span><br></pre></td></tr></table></figure>


<h2 id="位置标记"><a href="#位置标记" class="headerlink" title="位置标记"></a>位置标记</h2><p>你可以通过标记保存当前位置并在之后回到这个位置，就像文本编辑中的书签。 你可以通过<code>mx</code>设置一个标记，其中<code>x</code>可以是<code>a-zA-Z</code>。 有两种办法能回到标记的位置： 用``x<code>精确回到(行和列)，或者用</code>‘x`回到行级位置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ma    用a标签标记一个位置</span><br><span class="line">`a    精确回到a标签的位置(行和列)</span><br><span class="line">&#x27;a    跳转到a标签的行</span><br></pre></td></tr></table></figure>


<p><code>a-z</code>的标签和<code>A-Z</code>的标签存在一个区别，小写字母是局部标签，大写字母是全局标签(也称文件标记)。</p>
<p>我们首先说说局部标记。 每个buffer可以有自己的一套局部标记，如果打开了两个文件，我可以在第一个文件中设置标记”a”(<code>ma</code>)，然后在另一个文件中设置另一个标记”a”(<code>ma</code>)。</p>
<p>不像你可以在每个buffer中设置一套局部标签，你只能设置一套全局标签。 如果你在<code>myFile.txt</code>中设置了标签<code>mA</code>，下一次你在另一个文件中设置<code>mA</code>时，A标签的位置会被覆盖。 全局标签有一个好处就是，即使你在不同的项目红，你也可以跳转到任何一个全局标签上，全局标签可以帮助你在文件间切换。</p>
<p>使用<code>:marks</code>查看所有标签，你也许会注意到除了<code>a-zA-Z</code>以外还有别的标签，其中有一些例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;   在当前buffer中跳转回到上一次跳转前的最后一行</span><br><span class="line">``  在当前buffer中跳转回到上一次跳转前的最后一个位置</span><br><span class="line">`[  跳转到上一次修改或拷贝的文本的开头</span><br><span class="line">`]  跳转到上一次修改或拷贝的文本的结尾</span><br><span class="line">`&lt;  跳转到最近一次可视模式下选择的部分的开头</span><br><span class="line">`&gt;  跳转到最近一次可视模式下选择的部分的结尾</span><br><span class="line">`0  跳转到退出Vim前编辑的最后一个文件</span><br></pre></td></tr></table></figure>


<p>除了上面列举的，还有更多标记，我不会在这一一列举因为我觉得它们很少用到，不过如果你很好奇，你可以通过<code>: marks</code>查看。</p>
<h2 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h2><p>最后，我们聊聊Vim中的跳转你通过任意的移动可以在不同文件中或者同一个的文件的不同部分间跳转。 然而并不是所有的移动都被认为是一个跳转。 使用<code>j</code>向下移动一行就不被看做一个跳转，即使你使用<code>10j</code>向下移动10行，也不是一个跳转。 但是你通过<code>10G</code>去往第10行被算作一个跳转。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;   跳转到标记的行</span><br><span class="line">`   跳转到标记的位置(行和列)</span><br><span class="line">G   跳转到行</span><br><span class="line">/   向后搜索</span><br><span class="line">?   向前搜索</span><br><span class="line">n   重复上一次搜索，相同方向</span><br><span class="line">N   重复上一次搜索，相反方向</span><br><span class="line">%   查找匹配</span><br><span class="line">(   跳转上一个句子</span><br><span class="line">)   跳转下一个句子</span><br><span class="line">&#123;   跳转上一个段落</span><br><span class="line">&#125;   跳转下一个段落</span><br><span class="line">L   跳转到当前屏幕的最后一行</span><br><span class="line">M   跳转到当前屏幕的中间</span><br><span class="line">H   跳转到当前屏幕的第一行</span><br><span class="line">[[  跳转到上一个小节</span><br><span class="line">]]  跳转到下一个小节</span><br><span class="line">:s  替换</span><br><span class="line">:tag  跳转到tag定义</span><br></pre></td></tr></table></figure>


<p>我不建议你把上面这个列表记下来，一个大致的规则是，任何大于一个单词或超过当前行导航的移动都可能是一个跳转。 Vim保留了你移动前位置的记录，你可以通过<code>:jumps</code>查看这个列表，如果想了解更多，可以查看<code>:h jump-motions</code>。</p>
<p>为什么跳转有用呢? 因为你可以在跳转列表中通过<code>Ctrl-o</code>和<code>Ctrl-i</code>在记录之间向上或向下跳转到对应位置。 你可以在不同文件中进行跳转，这将是我之后会讲的部分。</p>
<h2 id="聪明地学习导航"><a href="#聪明地学习导航" class="headerlink" title="聪明地学习导航"></a>聪明地学习导航</h2><p>如果你是Vim的新手，这有很多值得你学，我不期望任何人能够立刻记住每样知识点，做到不用思考就能执行这需要一些时间。</p>
<p>我想，最好的开始的办法就是从一些少量的必要的移动开始记。 我推荐你从<code>h,j,k,l,w,b,G,/,?,n</code>开始，学习10个移动并且很达到很舒服使用它们的状态花不了很多时间。</p>
<p>为了让你更擅长导航，我有两个建议：</p>
<ol>
<li>注意重复的动作。 如果你发现你自己在重复的使用<code>l</code>，你可以去找一个方法让你前进的更快，然后你会发现你可以用<code>w</code>在单词间移动。 如果你发现你自己的重复的使用<code>w</code>，你可以看看是否有一种方法能让你直接到行尾，然后你会想到可以用<code>$</code>。 如果你可以口语化的表达你的需求，Vim中大概就会有一种方法去完成它。</li>
<li>当你学习任何一个新的移动时，多需要花一定的时间直到你可以不经过思考直接完成它。</li>
</ol>
<p>最后，为了提高效率你不需要知道所有的Vim的命令，大多数Vim用户也都不知道，你只需要学习当下能够帮助你完成任务的命令。</p>
<p>慢慢来，导航技巧是Vim中很重要的技巧，每天学一点并且把它学好。</p>
<h1 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h1><p>输入模式是大部分文本编辑器的默认模式，在这个模式下，所敲即所得。</p>
<p>在这一章节中，你将能够学到如何利用Vim输入模式中的特性来提升你的输入效率。</p>
<h2 id="进入输入模式的方法"><a href="#进入输入模式的方法" class="headerlink" title="进入输入模式的方法"></a>进入输入模式的方法</h2><p>我们有很多方式从普通模式进入输入模式，下面列举出了其中的一些方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i    从光标之前的位置开始输入文本</span><br><span class="line">I    从当前行第一个非空字符之前的位置之前开始输入文本</span><br><span class="line">a    在光标之后的位置追加文本</span><br><span class="line">A    在当前行的末尾追加文本</span><br><span class="line">o    在光标位置下方新起一行并开始输入文本</span><br><span class="line">O    在光标位置的上方新起一行并开始输入文本</span><br><span class="line">s    删除当前光标位置的字符并开始输入文本</span><br><span class="line">S    删除当前行并开始输入文本</span><br><span class="line">gi   从当前缓冲区上次结束输入模式的地方开始输入文本</span><br><span class="line">gI   在当前行的第一列的位置开始输入文本</span><br></pre></td></tr></table></figure>


<p>值得注意的是这些命令的小写/大写模式，每一个小写命令都有一个与之对应的大写命令。如果你是初学者，不用担心记不住以上整个命令列表，可以从 <code>i</code> 和 <code>a</code>两条命令开始，这两条命令足够在入门阶段使用了，之后再逐渐地掌握更多其他的命令。</p>
<h2 id="退出输入模式的方法"><a href="#退出输入模式的方法" class="headerlink" title="退出输入模式的方法"></a>退出输入模式的方法</h2><p>下面列出了一些从输入模式退出到普通模式的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;esc&gt;     退出输入模式进入普通模式</span><br><span class="line">Ctrl-[    退出输入模式进入普通模式</span><br><span class="line">Ctrl-c    与 Ctrl-[ 和 &lt;esc&gt;功能相同, 但是不检查缩写</span><br></pre></td></tr></table></figure>


<p>我发现<code>esc</code>键在键盘上太远了，很难够到，所以我在我的机器上将<code>caps lock</code> 映射成了<code>esc</code>键。 如果你搜索Bill Joy（Vi的作者）的ADM-3A 键盘， 你会发现<code>esc</code>键并不是像现在流行的键盘布局一样在键盘的最左上方，而是在<code>q</code>键的左边，所以我认为将<code>caps lock</code> 映射成<code>esc</code>键是合理的。</p>
<p>另一个Vim用户中常见的习惯是用以下的配置方法在输入模式中把<code>esc</code>映射到<code>jj</code>或者<code>jk</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inoremap jj &lt;esc&gt;</span><br><span class="line">inoremap jk &lt;esc&gt;</span><br></pre></td></tr></table></figure>


<h2 id="重复输入模式"><a href="#重复输入模式" class="headerlink" title="重复输入模式"></a>重复输入模式</h2><p>你可以在进入输入模式之前传递一个计数参数. 比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10i</span><br></pre></td></tr></table></figure>


<p>如果你输入“hello world!”然后退出输入模式， Vim将重复这段文本10次。这个方法对任意一种进入输入模式的方式都有效（如：<code>10I</code>, <code>11a</code>, <code>12o</code>）</p>
<h2 id="在输入模式中删除大块文本"><a href="#在输入模式中删除大块文本" class="headerlink" title="在输入模式中删除大块文本"></a>在输入模式中删除大块文本</h2><p>当你输入过程中出现一些输入错误时，一直重复地用<code>backspace</code>来删除的话会非常地繁琐。更为合理的做法是切换到普通模式并使用<code>d</code>来删除错误。或者，你能用以下命令在输入模式下就删除一个或者多个字符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ctrl-h    删除一个字符</span><br><span class="line">Ctrl-w    删除一个单词</span><br><span class="line">Ctrl-u    删除一整行</span><br></pre></td></tr></table></figure>


<p>此外，这些快捷键也支持在 命令行模式 和 Ex模式 中使用（命令行模式和Ex模式将会在之后的章节中介绍）</p>
<h1 id="用寄存器进行输入"><a href="#用寄存器进行输入" class="headerlink" title="用寄存器进行输入"></a>用寄存器进行输入</h1><p>寄存器就像是内存里的暂存器一样，可供存储和取出文本。在输入模式下，可以使用快捷键<code>Ctrl-r</code>加上寄存器的标识来从任何有标识的寄存器输入文本。有很多标识可供使用，但是在这一章节中你只需要知道以（a-z)命名的寄存器是可以使用的就足够了。</p>
<p>让我们在一个具体的例子中展示寄存器的用法，首先你需要复制一个单词到寄存器a中，这一步可以用以下这条命令来完成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;ayiw</span><br></pre></td></tr></table></figure>


<ul>
<li><code>&quot;a</code> 告诉Vim你下一个动作的目标地址是寄存器a</li>
<li><code>yiw</code> 复制一个内词（inner word），可以回顾Vim语法章节查看具体语法。</li>
</ul>
<p>现在寄存器a存放着你刚复制的单词。在输入模式中，使用以下的快捷键来粘贴存放在寄存器a中文本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ctrl-r a</span><br></pre></td></tr></table></figure>


<p>Vim中存在很多种类型的寄存器，我会在后面的章节中介绍更多他们的细节。</p>
<h2 id="页面滚动"><a href="#页面滚动" class="headerlink" title="页面滚动"></a>页面滚动</h2><p>你知道在输入模式中也是可以进行页面滚动的吗？在输入模式下，如果你使用快捷键<code>Ctrl-x</code>进入<code>Ctrl-x</code>子模式，你可以进行一些额外操作，页面滚动正是其中之一。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ctrl-x Ctrl-y    向上滚动页面</span><br><span class="line">Ctrl-x Ctrl-e    向下滚动页面</span><br></pre></td></tr></table></figure>


<h2 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h2><p>Vim在进入<code>Ctrl-x</code>子模式后（和页面滚动一样），有一个自带的自动补全功能。尽管它不如intellisense或者其他的语言服务器协议（LSP）一样好用，但是也算是一个锦上添花的内置功能了。</p>
<p>下面列出了一些适合入门时学习的自动补全命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ctrl-x Ctrl-l	   补全一整行</span><br><span class="line">Ctrl-x Ctrl-n	   从当前文件中补全文本</span><br><span class="line">Ctrl-x Ctrl-i	   从引用（include）的文件中补全文本</span><br><span class="line">Ctrl-x Ctrl-f	   补全一个文件名</span><br></pre></td></tr></table></figure>


<p>当你出发自动补全时，Vim会显示一个选项弹窗，可以使用<code>Ctrl-n</code>和<code>Ctrl-p</code>来分别向上和向下浏览选项。</p>
<p>Vim也提供了两条不需要进入<code>Ctrl-x</code>模式就能使用的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ctrl-n             使用下一个匹配的单词进行补全</span><br><span class="line">Ctrl-p             使用上一个匹配的单词进行补全</span><br></pre></td></tr></table></figure>


<p>通常Vim会关注所有缓冲区（buffer）中的文本作为自动补全的文本来源。如果你打开了一个缓冲区，其中一行是”Chocolate donuts are the best”：</p>
<ul>
<li>当你输入”Choco”然后使用快捷键<code>Ctrl-x Ctrl-l</code>， Vim会进行匹配并输出这一整行的文本。</li>
<li>当你输入”Choco”然后使用快捷键<code>Ctrl-p</code>，Vim会进行匹配并输出”Chocolate”这个单词。</li>
</ul>
<p>Vim的自动补全是一个相当大的话题，以上只是冰山一角，想要进一步学习的话可以使用<code>:h ins-completion</code>命令进行查看。</p>
<h2 id="执行普通模式下的命令"><a href="#执行普通模式下的命令" class="headerlink" title="执行普通模式下的命令"></a>执行普通模式下的命令</h2><p>你知道Vim可以在输入模式下执行普通模式的命令吗？</p>
<p>在输入模式下， 如果你按下<code>Ctrl-o</code>，你就会进入到<code>insert-normal</code>（输入-普通）子模式。如果你关注一下左下角的模式指示器，通常你将看到<code>-- INSERT --</code> ，但是按下<code>Ctrl-o</code>后就会变为<code>-- (insert) --</code>。 在这一模式下，你可以执行一条普通模式的命令，比如你可以做以下这些事：</p>
<p><strong>设置居中以及跳转</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ctrl-o zz       居中窗口</span><br><span class="line">Ctrl-o H/M/L    跳转到窗口的顶部/中部/底部</span><br><span class="line">Ctrl-o &#x27;a       跳转到标志&#x27;a处</span><br></pre></td></tr></table></figure>


<p><strong>重复文本</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ctrl-o 100ihello    输入 &quot;hello&quot; 100 次</span><br></pre></td></tr></table></figure>


<p><strong>执行终端命令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ctrl-o !! curl https://google.com    运行curl命令</span><br><span class="line">Ctrl-o !! pwd                        运行pwd命令</span><br></pre></td></tr></table></figure>


<p><strong>快速删除</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ctrl-o dtz    从当前位置开始删除文本，直到遇到字母&quot;z&quot;</span><br><span class="line">Ctrl-o D      从当前位置开始删除文本，直到行末</span><br></pre></td></tr></table></figure>


<h2 id="聪明地学习输入模式"><a href="#聪明地学习输入模式" class="headerlink" title="聪明地学习输入模式"></a>聪明地学习输入模式</h2><p>如果你和我一样是从其他文本编辑器转到Vim的，你或许也会觉得一直待在输入模式下很有诱惑力，但是我强烈反对你在没有输入文本时，却仍然待在输入模式下。应该养成当你的双手没有在输入时，就退出到普通模式的好习惯。</p>
<p>当你需要进行输入时，先问问自己将要输入的文本是否已经存在。如果存在的话，试着复制或者移动这段文本而不是手动输入它。再问问自己是不是非得进入输入模式，试试能不能尽可能地使用自动补全来进行输入。尽量避免重复输入同一个单词。</p>
<h1 id="点命令"><a href="#点命令" class="headerlink" title="点命令"></a>点命令</h1><p>在编辑文本时，我们应该尽可能地避免重复的动作。在这一章节中，你将会学习如何使用点命令来重放上一个修改操作。点命令是最简单的命令，然而又是减少重复操作最为有用的命令。</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>正如这个命令的名字一样，你可以通过按下<code>.</code>键来使用点命令。</p>
<p>比如，如果你想将下面文本中的所有”let“替换为”const”：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let one = &quot;1&quot;;</span><br><span class="line">let two = &quot;2&quot;;</span><br><span class="line">let three = &quot;3&quot;;</span><br></pre></td></tr></table></figure>


<p>首先，使用<code>/let</code>来进行匹配。接着，使用<code>cwconst&lt;esc&gt;</code>来将”let”替换成”const”。第三步，使用<code>n</code>来找到下一个匹配的位置。最后，使用点命令(<code>.</code>)来重复之前的操作。持续地使用<code>n . n .</code>直到每一个匹配的词都被替换。</p>
<p>在这个例子里面，点命令重复的是<code>cwconst&lt;esc&gt;</code>这一串命令，它能够帮你将需要8次输入的命令简化到只需要敲击一次键盘。</p>
<h2 id="什么才算是修改操作？"><a href="#什么才算是修改操作？" class="headerlink" title="什么才算是修改操作？"></a>什么才算是修改操作？</h2><p>如果你查看点命令的定义的话(<code>:h .</code>),文档中说点命令会重复上一个修改操作，那么什么才算是一个修改操作呢？</p>
<p>当你使用普通模式下的命令来更新（添加，修改或者删除）当前缓冲区中的内容时，你就是在执行一个修改操作了。其中的例外是使用命令行命令进行的修改（以<code>：</code>开头的命令），这些命令不算作修改操作。</p>
<p>在第一个例子中，你看到的<code>cwconst&lt;esc&gt;</code>就是一个修改操作。现在假设你有以下这么一个句子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pancake, potatoes, fruit-juice,</span><br></pre></td></tr></table></figure>


<p>我们来删除从这行开始的位置到第一个逗号出现的位置。你可以使用<code>df,</code>来完成这个操作,使用<code>.</code>来重复两次直到你将整个句子删除。</p>
<p>让我们再来试试另一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pancake, potatoes, fruit-juice,</span><br></pre></td></tr></table></figure>


<p>这一次你只需要删除所有的逗号，不包括逗号前面的词。我们可以使用<code>f,</code>来找到第一个逗号，再使用<code>x</code>来删除光标下的字符。然后使用用<code>.</code>来重复两次，很简单对不对？等等！这样做行不通(只会重复删除光标下的一个字符，而不是删除逗号)！为什么会这样呢？</p>
<p>在Vim里，修改操作是不包括移动操作（motions）的，因为动作不会更新缓冲区的内容。当你运行<code>f,x</code>，你实际上是在执行两个独立的操作：<code>f,</code>命令只移动光标，而<code>x</code>更新缓冲区的内容，只有后者算作修改动作。和之前例子中的<code>df,</code>进行一下对比的话，你会发现<code>df,</code>中的<code>f,</code>告诉删除操作<code>d</code>哪里需要删除，是整个删除命令<code>df,</code>的一部分。</p>
<p>让我们想想办法完成这个任务。在你运行<code>f,</code>并执行<code>x</code>来删除第一个逗号后，使用<code>;</code>来继续匹配<code>f</code>的下一个目标（下一个逗号）。之后再使用<code>.</code>来重复修改操作，删除光标下的字符。重复<code>; . ; .</code>直到所有的逗号都被删除。完整的命令即为<code>f,x;.;.</code>。</p>
<p>再来试试下一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pancake</span><br><span class="line">potatoes</span><br><span class="line">fruit-juice</span><br></pre></td></tr></table></figure>


<p>我们的目标是给每一行的结尾加上逗号。从第一行开始，我们执行命令<code>A,&lt;esc&gt;j</code>来给结尾加上逗号并移动到下一行。现在我们知道了<code>j</code>是不算作修改操作的，只有<code>A,</code>算作修改操作。你可以使用<code>j . j .</code>来移动并重复修改操作。完整的命令是<code>A,&lt;esc&gt;j</code>。</p>
<p>从你按下输入命令（A）开始到你退出输入模式（）之间的所有输入都算作是一整个修改操作。Vim不仅允许你控制需要添加的文本的内容，还允许你控制在什么位置添加文本。你可以在选择在这些位置进行输入：光标位置前（<code>i</code>）,光标位置之后（<code>a</code>）,在下方插入一行（<code>o</code>），在上方插入一行（<code>O</code>），在当前行的末尾(<code>A</code>),或者在当前行的开始位置(<code>I</code>)。如果你想复习一下相关内容的话，可以看看输入模式（Insert Mode）这一章节。</p>
<h2 id="重复多行修改操作"><a href="#重复多行修改操作" class="headerlink" title="重复多行修改操作"></a>重复多行修改操作</h2><p>假设你有如下的文本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let one = &quot;1&quot;;</span><br><span class="line">let two = &quot;2&quot;;</span><br><span class="line">let three = &quot;3&quot;;</span><br><span class="line">const foo = &quot;bar&quot;;</span><br><span class="line">let four = &quot;4&quot;;</span><br><span class="line">let five = &quot;5&quot;;</span><br><span class="line">let six = &quot;6&quot;;</span><br><span class="line">let seven = &quot;7&quot;;</span><br><span class="line">let eight = &quot;8&quot;;</span><br><span class="line">let nine = &quot;9&quot;;</span><br></pre></td></tr></table></figure>


<p>你的目标是删除除了含有”foo”那一行以外的所有行。首先，使用<code>d2j</code>删除前三行。之后跳过”foo”这一行，在其下一行使用点命令两次来删除剩下的六行。完整的命令是<code>d2jj..</code>。</p>
<p>这里的修改操作是<code>d2j</code>，<code>2j</code>不是一个移动操作，而是整个删除命令的一部分。</p>
<p>我们再来看看下一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zlet zzone = &quot;1&quot;;</span><br><span class="line">zlet zztwo = &quot;2&quot;;</span><br><span class="line">zlet zzthree = &quot;3&quot;;</span><br><span class="line">let four = &quot;4&quot;;</span><br></pre></td></tr></table></figure>


<p>我们的目标是删除所有的’z’。首先，在块可视化模式下使用<code>Ctrl-vjj</code>来选中前三行的第一个’z’字母。如果你对块可视化模式不熟悉的话也不用担心，我会在下一章节中进行介绍。在选中前三行的第一个’z’后，使用<code>d</code>来删除它们。接着用<code>w</code>移动到下一个z字母上，使用<code>..</code>重复两次之前选中加删除的动作。完整的命令为<code>Ctrl-vjjdw..</code>。</p>
<p>你删除一列上的三个’z‘的操作(<code>Ctrl-vjjd</code>)被看做一整个修改操作。可视化模式中的选择操作可以用来选中多行，作为修改动作的一部分。</p>
<h2 id="在修改中包含移动操作"><a href="#在修改中包含移动操作" class="headerlink" title="在修改中包含移动操作"></a>在修改中包含移动操作</h2><p>让我们来重新回顾一下本章中的第一个例子。这个例子中我们使用了<code>/letcwconst&lt;esc&gt;</code>紧接着<code>n . n .</code>将下面的文本中的’let’都替换成了’const’。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let one = &quot;1&quot;;</span><br><span class="line">let two = &quot;2&quot;;</span><br><span class="line">let three = &quot;3&quot;;</span><br></pre></td></tr></table></figure>


<p>其实还有更快的方法来完成整个操作。在删除的时候，并不使用<code>w</code>,而是使用<code>gn</code>。</p>
<p><code>gn</code>是向前搜索和上一个搜索的模式（本例中为<code>/let</code>）匹配的位置，并且自动对匹配的文本进行可视化模式下的选取的移动操作。想要对下一个匹配的位置进行替换的话，你不再需要先移动在重复修改操作（<code>n . n .</code>），而是简单地使用<code>. .</code>就能完成。你不需要再进行移动操作了，因为找到下一个匹配的位置并进行选中成为了修改操作的一部分了。完整的命令为<code>/letdgn..</code></p>
<p>当你在编辑文本时，应该时刻关注像<code>gn</code>命令这种能一下子做好几件事的移动操作。</p>
<h2 id="聪明地学习点命令"><a href="#聪明地学习点命令" class="headerlink" title="聪明地学习点命令"></a>聪明地学习点命令</h2><p>点命令的强大之处在于使用仅仅1次键盘敲击代替好几次敲击。对于<code>x</code>这种只需一次敲击键盘就能完成的修改操作来说，点命令或许不会带来什么收益。但是如果你的上一个修改操作是像<code>cgnconst&lt;esc&gt;</code>这种复杂命令的话，使用点命令来替代就有非常可观的收益了。</p>
<p>在进行编辑时，思考一下你正将进行的操作是否是可以重复的。举个例子，如果我需要删除接下来的三个单词，是使用<code>d3w</code>更划算，还是<code>dw</code>再使用<code>.</code>两次更划算？之后还会不会再进行删除操作？如果是这样的话，使用<code>dw</code>好几次确实比<code>d3w</code>更加合理，因为<code>dw</code>更加有复用性。在编辑时应该养成“修改操作驱动”的观念。</p>
<p>点命令非常简单但又功能强大，帮助你开始自动化处理简单的任务。在后续的章节中，你将会学习到如何使用Vim的宏命令来自动化处理更多复杂的操作。但是首先，还是让我们来学习一下如何使用寄存器来存取文本吧。</p>
<h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p>学习Vim中的寄存器就像第一次学习线性代数一样，除非你学习了他们，否则你会觉得自己根本不需要它们。</p>
<p>你可能已经在复制或删除文本并用<code>p</code>或<code>P</code>粘贴它们到别处的时候使用过Vim的寄存器了。但是，你知道Vim总共有10种不同类型的寄存器吗？</p>
<p>在这一章节中，我会介绍Vim的所有寄存器类型，以及如何有效地使用它们。</p>
<h2 id="寄存器的10种类型"><a href="#寄存器的10种类型" class="headerlink" title="寄存器的10种类型"></a>寄存器的10种类型</h2><p>下面是Vim所拥有的10种寄存器类型：</p>
<ol>
<li>匿名寄存器（<code>&quot;&quot;</code>）</li>
<li>编号寄存器(<code>&quot;0-9</code>).</li>
<li>小删除寄存器 (<code>&quot;-</code>).</li>
<li>命名寄存器 (<code>&quot;a-z</code>).</li>
<li>只读寄存器 (<code>&quot;:</code>, <code>&quot;.</code>,and <code>&quot;%</code>).</li>
<li>Buffer交替文件寄存器 (<code>&quot;#</code>).</li>
<li>表达式寄存器 (<code>&quot;=</code>).</li>
<li>选取和拖放寄存器(<code>&quot;*</code> and <code>&quot;+</code>).</li>
<li>黑洞寄存器 (<code>&quot;_</code>).</li>
<li>搜索模式寄存器 (<code>&quot;/</code>).</li>
</ol>
<h2 id="寄存器命令"><a href="#寄存器命令" class="headerlink" title="寄存器命令"></a>寄存器命令</h2><p>以下是一些存值到寄存器中操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">y    复制</span><br><span class="line">c    删除文本并进入输入模式</span><br><span class="line">d    删除文本</span><br></pre></td></tr></table></figure>


<p>其实还有更多的寄存器写入操作（比如<code>s</code>或<code>x</code>），但是上面列出的是最常用的一些。根据经验看来，如果一个操作删除了文本，那么很有可能这个操作将移除的文本存入寄存器中了。</p>
<p>To put (paste) texts from registers, you can use:</p>
<p>想要从寄存器中取出（粘贴）文本，你可以用以下的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p    在光标位置之后粘贴文本</span><br><span class="line">P    在光标位置之前粘贴文本</span><br></pre></td></tr></table></figure>


<p><code>p</code>和<code>P</code>都可以接受计数和一个寄存器标志作为参数。比如，想要把最近复制的文本粘贴10次的话可以用<code>10p</code>。想粘贴寄存器”a”中的文本，可以用<code>&quot;ap</code>。想将寄存器“a”中的文本粘贴10次的话，可以使用<code>10&quot;ap</code>。</p>
<p>从某个特定寄存器中读取文本的通用语法是<code>&quot;x</code>，其中<code>x</code>是这个寄存器的标识。</p>
<h2 id="在输入模式中使用寄存器"><a href="#在输入模式中使用寄存器" class="headerlink" title="在输入模式中使用寄存器"></a>在输入模式中使用寄存器</h2><p>在这一章节中你学到的东西在输入模式中也同样适用。想要获取寄存器”a”中的文本，通常可以使用<code>&quot;ap</code>来进行。不过当你在输入模式下时，你需要运行<code>Ctrl-r a</code>。在输入模式下使用寄存器的语法是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ctrl-r x</span><br></pre></td></tr></table></figure>


<p>其中<code>x</code>是寄存器标识。既然你现在已经知道如何存储和访问寄存器了，让我们学点更深入的吧。</p>
<h2 id="匿名寄存器-quot-quot"><a href="#匿名寄存器-quot-quot" class="headerlink" title="匿名寄存器(&quot;&quot;)"></a>匿名寄存器(<code>&quot;&quot;</code>)</h2><p>想从匿名寄存器中获取文本，可以使用<code>&quot;&quot;p</code>。 匿名寄存器默认存储着你最近一次复制，修改或删除的文本。如果再进行另一次复制，修改或删除，Vim会自动替换匿名寄存器中的文本。匿名寄存器和电脑上粘贴板的功能很接近。</p>
<p>默认情况下，<code>p</code>(或者<code>P</code>)是和匿名寄存器相关联的（从现在起我将使用<code>p</code>而不是<code>&quot;&quot;p</code>来指代匿名寄存器）。</p>
<h2 id="编号寄存器-quot-0-9"><a href="#编号寄存器-quot-0-9" class="headerlink" title="编号寄存器(&quot;0-9)"></a>编号寄存器(<code>&quot;0-9</code>)</h2><p>编号寄存器会自动以升序来进行填充。一共有两种不同的编号寄存器：复制寄存器(<code>0</code>)和其他编号寄存器(<code>1-9</code>)。让我们先来讨论复制寄存器。</p>
<h3 id="复制寄存器-quot-0"><a href="#复制寄存器-quot-0" class="headerlink" title="复制寄存器 (&quot;0)"></a>复制寄存器 (<code>&quot;0</code>)</h3><p>如果你使用<code>yy</code>来复制一整行文本，事实上Vim会将文本存放两个寄存器中：</p>
<ol>
<li>匿名寄存器 (<code>p</code>).</li>
<li>复制寄存器 (<code>&quot;0p</code>).</li>
</ol>
<p>在你又复制其他不同的文本后，Vim会自动替换匿名寄存器和复制寄存器中的内容。其他的任何操作都不会被存放在<code>0</code>号寄存器中。这可以为你提供方便，因为除非你再进行另一次复制，否则你已经复制的内容会一直在寄存器中，无论你进行多少次修改和删除。</p>
<p>比如，如果你：</p>
<ol>
<li>复制一整行 (<code>yy</code>)</li>
<li>删除一整行(<code>dd</code>)</li>
<li>再删除另一行 (<code>dd</code>)</li>
</ol>
<p>复制寄存器中的文本仍然是第一步中复制的文本。</p>
<p>如果你:</p>
<ol>
<li>复制一整行 (<code>yy</code>)</li>
<li>删除一整行 (<code>dd</code>)</li>
<li>复制另一行 (<code>yy</code>)</li>
</ol>
<p>复制寄存器中的内容则是第三步中复制的内容。</p>
<p>还有一个小技巧，在输入模式下，你可以使用<code>Ctrl-r 0</code>快速地粘贴你刚才复制的内容。</p>
<h3 id="编号寄存器-quot-1-9"><a href="#编号寄存器-quot-1-9" class="headerlink" title="编号寄存器 (&quot;1-9)"></a>编号寄存器 (<code>&quot;1-9</code>)</h3><p>当你修改或者删除至少一整行的文本时，这部分文本会按时间顺序被存储在1-9号编号寄存器中。（编号越小时间距离越近）</p>
<p>比如，你有以下这些文本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">line three</span><br><span class="line">line two</span><br><span class="line">line one</span><br></pre></td></tr></table></figure>


<p>当你的光标在文本“line three”上时,使用<code>dd</code>来一行一行地删除这些文本。在所有文本都已经删除后，1号寄存器中的内容应该是”line one”（时间上最近的文本）， 2号寄存器则包含”line two”(时间上第二近的文本)，3号寄存器中则包含”line three”（最早删除的文本）。普通模式下可以使用<code>&quot;1p</code>来获取1号寄存器中的内容。</p>
<p>编号寄存器的编号在使用点命令时会自动增加。比如，如果你的1号编号寄存器（<code>&quot;1</code>）中的内容为”line one”， 2号寄存器（<code>&quot;2</code>）为”line two”, 三号寄存器（<code>&quot;3</code>）,你可以使用以下的技巧来连续地粘贴他们：</p>
<ul>
<li>使用<code>&quot;1p</code>来粘贴1号寄存器中的内容。</li>
<li>使用<code>.</code> (点命令)来粘贴2号寄存器（<code>&quot;2</code>）中的内容。</li>
<li>使用<code>.</code> (点命令)来粘贴3号寄存器（<code>&quot;3</code>）中的内容。</li>
</ul>
<p>在连续地使用点命令时，Vim会自动的增加编号寄存器的编号。这个技巧对于所有的编号寄存器都适用。如果你从5号寄存器开始(<code>&quot;5P</code>), 点命令<code>.</code>会执行<code>&quot;6P</code>,再次使用<code>.</code>则会执行<code>&quot;7P</code>,等等。</p>
<p>小型的删除比如单词删除（<code>dw</code>)或者单词修改(<code>cw</code>)不会被存储在编号寄存器中，它们被存储在小删除寄存器(<code>&quot;-</code>)中，我将在接下来的一小节讨论小删除寄存器。</p>
<h2 id="小删除寄存器-quot"><a href="#小删除寄存器-quot" class="headerlink" title="小删除寄存器(&quot;-)"></a>小删除寄存器(<code>&quot;-</code>)</h2><p>不足一行的修改或者删除都不会被存储在0-9号编号寄存器中，而是会被存储在小删除寄存器 (<code>&quot;-</code>)中。</p>
<p>比如:</p>
<ol>
<li>删除一个单词 (<code>diw</code>)</li>
<li>删除一行文本 (<code>dd</code>)</li>
<li>删除一行文本 (<code>dd</code>)</li>
</ol>
<p><code>&quot;-p</code> 会给你第一步中删除的单词。</p>
<p>另一个例子:</p>
<ol>
<li>删除一个单词(<code>diw</code>)</li>
<li>删除一行文本 (<code>dd</code>)</li>
<li>删除一个单词 (<code>diw</code>)</li>
</ol>
<p><code>&quot;-p</code> 会给出第三步中删除的单词。类似地, <code>&quot;1p</code> 会给出第二步中删除的一整行文本。不幸的是我们没有办法获取第一步中删除的单词，因为小删除寄存器只能存储一个文本。然而，如果你想保存第一步中删除的文本，你可以使用命名寄存器来完成。</p>
<h2 id="命名寄存器-quot-a-z"><a href="#命名寄存器-quot-a-z" class="headerlink" title="命名寄存器 (&quot;a-z)"></a>命名寄存器 (<code>&quot;a-z</code>)</h2><p>命名寄存器是Vim中用法最丰富的寄存器。a-z命名寄存器可以存储复制的，修改的和被删除的文本。不像之前介绍的3种寄存器一样，它们会自动将文本存储到寄存器中，你需要显式地告诉Vim你要使用命名寄存器，你拥有完整的控制权。</p>
<p>为了复制一个单词到寄存器”a”中，你可以使用命令<code>&quot;ayiw</code>。</p>
<ul>
<li><code>&quot;a</code>告诉Vim下一个动作（删除/修改/复制）会被存储在寄存器”a”中</li>
<li><code>yiw</code>复制这个单词</li>
</ul>
<p>为了从寄存器”a”中获取文本，可以使用命令<code>&quot;ap</code>。你可以使用以26个字母命名的寄存器来存储26个不同的文本。</p>
<p>有时你可能会想要往已有内容的命名寄存器中继续添加内容，这种情况下，你可以追加文本而不是全部重来。你可以使用大写版本的命名寄存器来进行文本的追加。比如，假设你的”a”寄存器中已经存有文本”Hello”，如果你想继续添加”world”到寄存器”a”中，你可以先找到文本”world”然后使用<code>&quot;Aiw</code>来进行复制,即可完成追加。</p>
<h2 id="只读寄存器-quot-quot-quot"><a href="#只读寄存器-quot-quot-quot" class="headerlink" title="只读寄存器(&quot;:, &quot;., &quot;%)"></a>只读寄存器(<code>&quot;:</code>, <code>&quot;.</code>, <code>&quot;%</code>)</h2><p>Vim有三个只读寄存器：<code>.</code>,<code>:</code>和<code>%</code>，它们的用法非常简单：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.    存储上一个输入的文本</span><br><span class="line">:    存储上一次执行的命令</span><br><span class="line">%    存储当前文件的文件名</span><br></pre></td></tr></table></figure>


<p>如果你写入”Hello Vim”,之后再运行<code>&quot;.p</code>就会打印出文本”Hello Vim”。如果你想要获得当前文件的文件名，可以运行命令<code>&quot;%p</code>。如果你运行命令<code>:s/foo/bar/g</code>，再运行<code>&quot;:p</code>的话则会打印出文本”s/foo/bar/g”。</p>
<h2 id="Buffer交替文件寄存器-quot"><a href="#Buffer交替文件寄存器-quot" class="headerlink" title="Buffer交替文件寄存器 (&quot;#)"></a>Buffer交替文件寄存器 (<code>&quot;#</code>)</h2><p>在Vim中，<code>#</code>通常代表交替文件。交替文件指的是你上一个打开的文件，想要插入交替文件的名字的话，可以使用命令<code>&quot;#p</code>。</p>
<h2 id="表达式寄存器-quot"><a href="#表达式寄存器-quot" class="headerlink" title="表达式寄存器 (&quot;=)"></a>表达式寄存器 (<code>&quot;=</code>)</h2><p>Vim有一个表达式寄存器，<code>&quot;=</code>,用于计算表达式的结果。表达式是Vim中非常宏大的一个话题，所以我只会在这里介绍一些基础知识，我将会在之后的章节中进一步讲解更多关于表达式的细节。</p>
<p>你可以使用以下命令计算数学表达式<code>1+1</code>的值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;=1+1&lt;Enter&gt;p</span><br></pre></td></tr></table></figure>


<p>在这里，你在告诉Vim你正在使用表达式寄存器<code>&quot;=</code>，你的表达式是（<code>1+1</code>），你还需要输入<code>p</code>来的到结果。正如之前所提到的，你也可以在输入模式中访问寄存器。想要在输入模式中计算数学表达式的值，你可以使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ctrl-r =1+1</span><br></pre></td></tr></table></figure>


<p>你可以使用<code>@</code>来从任何寄存器中获取表达式并用表达式寄存器计算其值。如果你希望从寄存器”a”中获取文本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;=@a</span><br></pre></td></tr></table></figure>


<p>之后输入<code>&lt;enter&gt;</code>，再输入<code>p</code>。类似地，想在输入模式中得到寄存器”a”中的值可以使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ctrl-r =@a</span><br></pre></td></tr></table></figure>


<p>你也能使用表达式寄存器来计算Vim脚本的值。如果你使用<code>:let i = 1</code>定义一个变量<code>i</code>,你可以用<code>&quot;=i</code>获取到它的值，按下回车，再按下<code>p</code>。想在输入模式中获取到这个值的话可以运行命令<code>Ctrl-r=i</code>。</p>
<p>假设你有一个方程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function! HelloFunc()</span><br><span class="line">	return &quot;Hello Vim Script!&quot;</span><br><span class="line">endfunction</span><br></pre></td></tr></table></figure>


<p>你可以通过调用这个方程获取它的值。想要在普通模式中调用这个方程，你可以使用：<code>&quot;=HelloFunc()</code>, 按下回车再按下<code>p</code>。而在输入模式下可以使用<code>Ctrl-r =HelloFunc()</code>。</p>
<h2 id="选取和拖放寄存器-quot-quot"><a href="#选取和拖放寄存器-quot-quot" class="headerlink" title="选取和拖放寄存器 (&quot;*, &quot;+)"></a>选取和拖放寄存器 (<code>&quot;*</code>, <code>&quot;+</code>)</h2><p>你难道不觉得有些时候你需要从某些外部的程序中复制一些文本并粘贴到Vim中吗，或者反过来操作？有了Vim的选取和拖放寄存器你就能办到。Vim有两个选取寄存器：<code>quotestar</code> (<code>&quot;*</code>) 和 <code>quoteplus</code> (<code>&quot;+</code>)。你可以用它们来访问从外部程序中复制的文本。</p>
<p>如果你在运行一个外部程序（比如Chrome浏览器），然后你使用<code>Ctrl-c</code>(或者<code>Cmd-c</code>,取决于你的操作系统)复制了一部分文本，通常你是没有办法在Vim里使用<code>p</code>来粘贴这部分文本的。但是，Vim的两个寄存器<code>&quot;+</code>和<code>&quot;*</code>都是和你系统的粘贴板相连接的，所以你可以使用<code>&quot;+p</code>和<code>&quot;*p</code>来粘贴这些文本。反过来，如果你使用<code>&quot;+yiw</code>或者<code>&quot;*yiw</code>在Vim中复制了一些文本，你可以使用<code>Ctrl-v</code>（或者<code>Cmd-v</code>）。值得注意的是这个方法只在你的Vim开启了<code>+clipboard</code>选项时才有用，可以在命令行中运行<code>vim --version</code>查看这一选项。如果你看见<code>-clipboard</code>的话，则需要安装一下支持Vim粘贴板的配置。</p>
<p>你也许会想如果<code>&quot;*</code>和<code>&quot;+</code>能办到的事完全相同，那为什么Vim需要两个不同的寄存器呢？一些机器使用的是X11窗口系统，这一系统有3个类型的选项：首选，次选和粘贴板。如果你的机器使用的是X11的话,Vim使用的是<code>quotestar</code> (<code>&quot;*</code>)寄存器作为X11的首选选项，并使用 <code>quoteplus</code> (<code>&quot;+</code>)作为粘贴板选项。这只在你的Vim配置里开启了<code>xterm_clipboard</code> 选项时才有效（<code>vim --version</code>中的<code>+xterm_clipboard</code>）。如果你的的Vim配置中没有 <code>xterm_clipboard</code>也不是什么大问题。这只是意味着<code>quotestar</code> 和<code>quoteplus</code>两个寄存器是可以互相替代的。</p>
<p>我发觉使用<code>=*p</code>或者<code>=+p</code>的话比较麻烦，为了使Vim仅使用<code>p</code>就能粘贴从外部程序复制的文本，你可以在你的<code>vimrc</code>配置文件中加入下面一行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set clipboard=unnamed</span><br></pre></td></tr></table></figure>


<p>现在当我从外部程序中复制文本时，我可以使用匿名寄存器<code>p</code>来进行粘贴。我也可以在Vim中复制文本后在外部程序中使用<code>Ctrl-v</code>来粘贴。如果你的Vim开启了 <code>+xterm_clipboard</code>设置，你或许会想同时也使用<code>unnamed</code>和<code>unnamedplus</code>的粘贴板选项。</p>
<h2 id="黑洞寄存器-quot"><a href="#黑洞寄存器-quot" class="headerlink" title="黑洞寄存器 (&quot;_)"></a>黑洞寄存器 (<code>&quot;_</code>)</h2><p>你每次删除或修改文本的时候，这部分文本都会自动保存在Vim的寄存器中。有些时候你并不希望把什么东西都往寄存器里存，这该怎么办到呢？</p>
<p>你可以使用黑洞寄存器（<code>&quot;_</code>）。想要删除一行并且不将其存储在任何寄存器中时，可以使用<code>&quot;_dd</code>命令，它是和 <code>/dev/null</code> 类似的寄存器。</p>
<h2 id="搜索模式寄存器-quot"><a href="#搜索模式寄存器-quot" class="headerlink" title="搜索模式寄存器 (&quot;/)"></a>搜索模式寄存器 (<code>&quot;/</code>)</h2><p>为了粘贴你的上一个搜索询问（<code>/</code> 或 <code>?</code>），你可以使用搜索模式寄存器(<code>&quot;/</code>)。使用命令 <code>&quot;/p</code>就能粘贴上一个搜索的条目。</p>
<h2 id="查看所有的寄存器"><a href="#查看所有的寄存器" class="headerlink" title="查看所有的寄存器"></a>查看所有的寄存器</h2><p>你可以使用<code>:register</code>命令来查看你的所有寄存器。如果你只想查看”a”,”1”和”-“寄存器的内容的话则可以使用命令<code>:register a 1 -</code>。</p>
<p>有一个Vim的插件叫做 <a href="https://github.com/junegunn/vim-peekaboo">vim-peekaboo</a> ,可以让你查看到寄存器的内容，在普通模式下输入<code>&quot;</code>或<code>@</code> 即可，或者在输入模式中输入<code>Ctrl-r</code>。我发现这个插件相当的有用，因为大多数时候我是记不住我的寄存器中的内容的。值得一试！</p>
<h2 id="执行寄存器"><a href="#执行寄存器" class="headerlink" title="执行寄存器"></a>执行寄存器</h2><p>命名寄存器不只可以用来存放文本，你还可以借助<code>@</code>来执行宏命令。我会在下一章节中介绍宏命令。如果你将文本”Hello Vim”存放在寄存器”a”中，并且之后你在同一个寄存器里记录了一个宏命令 (<code>qa&#123;macro-commands&#125;q</code>),那么这个宏命令将会覆盖之前存储的文本”Hello Vim”（你可以使用<code>@a</code>来执行寄存器中存储的宏命令）。</p>
<h2 id="清除寄存器"><a href="#清除寄存器" class="headerlink" title="清除寄存器"></a>清除寄存器</h2><p>从技术上来说，我们没有必要来清除任何寄存器，因为你下一个使用来存储文本的寄存器会自动覆盖该寄存器中之前的内容。然而，你可以通过记录一个空的宏命令来快速地清除任何命名寄存器。比如，如果你运行<code>qaq</code>，Vim就会在寄存器”a”中记录一个空的宏命令。还有一种方法就是运行命令<code>:call setreg(&#39;a&#39;,&#39;&#39;)</code>,其中’a’代表的就是寄存器”a”。还有一种清除寄存器的方法就是使用表达式<code>:let @a = &#39;&#39;</code>来将寄存器的值设为空的字符串。</p>
<h2 id="获取寄存器中的内容"><a href="#获取寄存器中的内容" class="headerlink" title="获取寄存器中的内容"></a>获取寄存器中的内容</h2><p>你可以使用<code>:put</code>命令来粘贴任何寄存器的内容。比如，如果你运行命令<code>:put a</code>,Vim就会打印出寄存器”a”的内容，这和<code>&quot;ap</code>非常像，唯一的区别在于在普通模式下命令<code>p</code>在当前光标位置之后打印寄存器的内容，而<code>:put</code>新起一行来打印寄存器的内容。</p>
<h2 id="聪明地学习寄存器"><a href="#聪明地学习寄存器" class="headerlink" title="聪明地学习寄存器"></a>聪明地学习寄存器</h2><p>恭喜你成功地坚持到了最后！这一章有非常多的内容需要消化。如果你感觉被新的知识淹没，你要知道你并不孤单，当我最初开始学习Vim寄存器时也有这种感觉。</p>
<p>我并不认为你必须现在就记得所有的知识点。为了提高我们的生产效率，你可以从使用以下三类寄存器开始：</p>
<ol>
<li>匿名寄存器(<code>&quot;&quot;</code>).</li>
<li>命名寄存器 (<code>&quot;a-z</code>).</li>
<li>编号寄存器 (<code>&quot;0-9</code>).</li>
</ol>
<p>既然匿名寄存器是默认和<code>p</code>或<code>P</code>，你只需要学习两个寄存器：命名寄存器和编号寄存器。之后如果你需要用到其他的寄存器时你再逐渐地学习其他寄存器的用法，不用急，慢慢来。</p>
<p>普通人的短期记忆都是有极限的，大概每次只能记住7个信息。这就是为什么在我的日常编辑中，我只用3到7个命名寄存器的原因，我没有办法记住整整26个寄存器的内容。我通常从寄存器”a”开始用，之后用寄存器”b”,以字母表升序的顺序来使用。尝试一下各种方法，看看哪种最适合你。</p>
<p>Vim寄存器非常强大，合理使用的话能够避免你输入数不清的重复文本。但是现在，是时候学习一下宏命令了。</p>
<h1 id="宏命令"><a href="#宏命令" class="headerlink" title="宏命令"></a>宏命令</h1><p>在编辑文件的时候，你会发现有时候你在反复地做一些相同的动作。如果你仅做一次，并在需要的时候调用这些动作岂不是会更好吗。通过 Vim 的宏命令，你可以将一些动作记录到 Vim 寄存器。</p>
<p>在本章中，你将会学习到如何通过宏命令自动完成一些普通的任务（另外，看你的文件在自动编辑是一件很酷的事情）。</p>
<h2 id="基本宏命令"><a href="#基本宏命令" class="headerlink" title="基本宏命令"></a>基本宏命令</h2><p>宏命令的基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qa                     开始记录动作到寄存器 a</span><br><span class="line">q (while recording)    停止记录</span><br></pre></td></tr></table></figure>


<p>你可以使用小写字母 （a-z）去存储宏命令。并通过如下的命令去调用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@a    Execute macro from register a</span><br><span class="line">@@    Execute the last executed macros</span><br></pre></td></tr></table></figure>


<p>假设你有如下的文本，你打算将每一行中的所有字母都变为大写。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello</span><br><span class="line">vim</span><br><span class="line">macros</span><br><span class="line">are</span><br><span class="line">awesome</span><br></pre></td></tr></table></figure>


<p>将你的光标移动到 “hello” 栏的行首，并执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qa0gU$jq</span><br></pre></td></tr></table></figure>


<p>上面命令的分解如下：</p>
<ul>
<li><code>qa</code> 开始记录一个宏定义并存储在 a 寄存器。</li>
<li><code>0</code> 移动到行首。</li>
<li><code>gU$</code> 将从光标到行尾的字母变为大写。</li>
<li><code>j</code> 移动到下一行。</li>
<li><code>q</code> 停止记录。</li>
</ul>
<p>调用 <code>@a</code> 去执行该宏命令。就像其他的宏命令一样，你也可以为该命令加一个计数。例如，你可以通过 <code>3@a</code> 去执行 <code>a</code> 命令3次。你也可以执行 <code>3@@</code> 去执行上一次执行过的宏命令3次。</p>
<h2 id="安全保护"><a href="#安全保护" class="headerlink" title="安全保护"></a>安全保护</h2><p>在执行遇到错误的时候，宏命令会自动停止。假如你有如下文本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a. chocolate donut</span><br><span class="line">b. mochi donut</span><br><span class="line">c. powdered sugar donut</span><br><span class="line">d. plain donut</span><br></pre></td></tr></table></figure>


<p>你想将每一行的第一个词变为大写，你可以使用如下的宏命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qa0W~jq</span><br></pre></td></tr></table></figure>


<p>上面命令的分解如下：</p>
<ul>
<li><code>qa</code> 开始记录一个宏定义并存储在 a 寄存器。</li>
<li><code>0</code> 移动到行首。</li>
<li><code>W</code> 移动到下一个单词。</li>
<li><code>~</code> 将光标选中的单词变为大写。</li>
<li><code>j</code> 移动到下一行。</li>
<li><code>q</code> 停止记录。</li>
</ul>
<p>我喜欢对宏命令进行很多次的调用，所以我通常使用 <code>99@a</code> 命令去执行该宏命令99次。当 Vim 在最后一行执行 <code>j</code> 命令的时候，会发现已经没有下一行可以继续，遇到执行的错误，因此宏命令会停止。</p>
<p>实际上，遇到错误自动停止运行是一个很好的特性。否则，Vim 会继续执行该命令99次，尽管它已经执行到最后一行了。</p>
<h2 id="命令行执行宏"><a href="#命令行执行宏" class="headerlink" title="命令行执行宏"></a>命令行执行宏</h2><p>在正常模式执行 <code>@a</code> 并不是宏命令调用的唯一方式。你也可以在命令行执行 <code>：normal @a</code> 。<code>：normal</code> 会将任何用户添加的参数作为命令去执行。例如添加 <code>@a</code>，和在 normal mode 执行 <code>@a</code> 的效果是一样的。</p>
<p><code>:normal</code> 命令也支持范围参数。你可以在选择的范围内去执行宏命令。如果你只想在第二行和第三行执行宏命令，你可以执行 <code>：2,3 normal @a</code>。我会在后续的章节中介绍更多关于在命令行中执行的命令。</p>
<h2 id="在多个文件中执行宏命令"><a href="#在多个文件中执行宏命令" class="headerlink" title="在多个文件中执行宏命令"></a>在多个文件中执行宏命令</h2><p>假如你有很多的 <code>.txt</code> 文件，每一个文件包含不同的内容。并且你只想将包含有 “donut” 单词的行的第一个单词变为大写。那么，该如何在很多文件中特定的行执行执行变该操作呢？</p>
<p>第一个文件:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># savory.txt</span><br><span class="line">a. cheddar jalapeno donut</span><br><span class="line">b. mac n cheese donut</span><br><span class="line">c. fried dumpling</span><br></pre></td></tr></table></figure>


<p>第二个文件:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># sweet.txt</span><br><span class="line">a. chocolate donut</span><br><span class="line">b. chocolate pancake</span><br><span class="line">c. powdered sugar donut</span><br></pre></td></tr></table></figure>


<p>第三个文件:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># plain.txt</span><br><span class="line">a. wheat bread</span><br><span class="line">b. plain donut</span><br></pre></td></tr></table></figure>


<p>你可以这么做:</p>
<ul>
<li><code>:args *.txt</code> 查找当前目录下的所有 <code>.txt</code> 文件。</li>
<li><code>:argdo g/donut/normal @a</code> 在所有 <code>:args</code> 中包含的文件里执行一个全局命令 <code>g/donut/normal @a</code>。</li>
<li><code>:argdo update</code> 在所有 <code>:args</code> 中包含的文件里执行 <code>update</code> 命令会将修改后的内容保存下来。</li>
</ul>
<p>如果你对全局命令 <code>:g/donut/normal @a</code> 不是很了解的话，该命令会在包含有 <code>/donut/</code> 中的所有行执行<code>normal @a</code> 命令。我会在后面的章节中介绍全局命令。</p>
<h2 id="递归执行宏命令"><a href="#递归执行宏命令" class="headerlink" title="递归执行宏命令"></a>递归执行宏命令</h2><p>你可以递归地执行宏命令，通过在记录宏命令时调用相同的宏来实现。假如你有如下文本，你希望改变第一个单词的大小写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a. chocolate donut</span><br><span class="line">b. mochi donut</span><br><span class="line">c. powdered sugar donut</span><br><span class="line">d. plain donut</span><br></pre></td></tr></table></figure>


<p>如下命令会递归地执行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qaqqa0W~j@aq</span><br></pre></td></tr></table></figure>


<p>上面命令的分解如下：</p>
<ul>
<li><code>qaq</code> 记录一个空白的宏命令到 “a” 。把宏命令记录在一个空白的命令中是必须的，因为你不会想将该命令包含有任何其他的东西。</li>
<li><code>qa</code> 开始录入宏命令到寄存器 “a”。</li>
<li><code>0</code> 移动到行首。</li>
<li><code>W</code> 移动到下一个单词。</li>
<li><code>~</code> 改变光标选中的单词的大小写。</li>
<li><code>j</code> 移动到下一行。</li>
<li><code>@a</code> 执行宏命令 “a”。当你记录该宏命令时，<code>@a</code> 应该是空白的，因为你刚刚调用了 <code>qaq</code>。</li>
<li><code>q</code> 停止记录。</li>
</ul>
<p>现在，让我们调用 <code>@a</code> 来查看 Vim 如何递归的调用该宏命令。</p>
<p>宏命令是如何知道何时停止呢？当宏执行到最后一行并尝试 <code>j</code> 命令时，发现已经没有下一行了，就会停止执行。</p>
<h2 id="增添一个已知宏"><a href="#增添一个已知宏" class="headerlink" title="增添一个已知宏"></a>增添一个已知宏</h2><p>如果你想在一个已经录制好的宏定义中添加更多的操作，与其重新录入它，不如选择修改它。在寄存器一章中，你学习了如何使用一个已知寄存器的大写字母来添加一个新的寄存器。为了在寄存器“a”中添加更多的操作，你可以使用“A”。假设你不仅希望将第一个单词变为大写，也希望在每一行末尾添加一个句点。</p>
<p>假设当前寄存器“a”中有如下的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0W~</span><br></pre></td></tr></table></figure>


<p>你可以这样做:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qAA.&lt;esc&gt;q</span><br></pre></td></tr></table></figure>


<p>分解如下:</p>
<ul>
<li><code>qA</code> 开始在寄存器 “A” 中记录宏命令。</li>
<li><code>A.&lt;esc&gt;</code> 在行的末尾（<code>A</code>）假如一个句点，并且退出插入模式。</li>
<li><code>q</code> 停止记录宏命令。</li>
</ul>
<p>现在，当你执行 <code>@a</code> 时，它会跳到行的第一个字符（<code>0</code>），跳到下一个单词（<code>W</code>），改变光标选中的字母的大小写（<code>~</code>），移动到最后一行并且转到插入模式（<code>A</code>），写入一个句点（<code>.</code>），退出插入模式（<code>&lt;esc&gt;</code>）。</p>
<h2 id="修改一个已知宏"><a href="#修改一个已知宏" class="headerlink" title="修改一个已知宏"></a>修改一个已知宏</h2><p>在已存在的宏定义的末尾添加新的动作是一个很好的功能，但假如你希望在一个宏命令的中间添加动作该怎么做呢？本节，我会向你展示如何修改一个宏。</p>
<p>假设，在改变第一个单词的大小写和在末尾加入一个句点之间，你想要在单词 “donut” 之前加入 “deep fried”（因为唯一比甜甜圈好的东西就是炸甜甜圈）。</p>
<p>我会重新使用上一节使用过的文本:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a. chocolate donut</span><br><span class="line">b. mochi donut</span><br><span class="line">c. powdered sugar donut</span><br><span class="line">d. plain donut</span><br></pre></td></tr></table></figure>


<p>首先，让我们通过 <code>:put a</code> 调用一个已经录制好的宏命令（假设你已经有了上一节中使用过的宏命令）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0W~A.^[</span><br></pre></td></tr></table></figure>


<p><code>^[</code> 是什么意思呢？不记得了吗，你之前执行过 <code>0W~A.&lt;esc&gt;</code>。 <code>^[</code> 是 Vim 的内部指令，表示 <code>&lt;esc&gt;</code>。通过这些指定的键值组合，Vim 知道这些是内部代码的一些替代。一些常见的内部指令具有类似的替代，例如 <code>&lt;esc&gt;</code>，<code>&lt;backspace&gt;</code>，<code>&lt;enter&gt;</code>。还有一些其他的键值组合，但这不是本章的内容。</p>
<p>回到宏命令，在改变大小写之后的键后面（<code>~</code>），让我们添加（<code>$</code>）来移动光标到行末，回退一个单词（<code>b</code>），进入插入模式（<code>i</code>），输入“deep fried ”（别忽略“fried ” 后面的这个空格），之后退出插入模式（<code>&lt;esc&gt;</code>）。</p>
<p>完整的命令如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0W~$bideep fried &lt;esc&gt;A.^[</span><br></pre></td></tr></table></figure>


<p>这里有一个问题，Vim 不能理解 <code>&lt;esc&gt;</code>。所以你需要将其替换为内部代码的形式。在插入模式，在按下<code>&lt;esc&gt;</code>后按下 <code>Ctrl-v</code>，Vim 会打印 <code>^[</code>。 <code>Ctrl-v</code> 是一个插入模式的操作符，可以逐字地插入一个非数字字符。你的宏命令应该如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0W~$bideep fried ^[A.^[</span><br></pre></td></tr></table></figure>


<p>为了在寄存器“a”中添加修改后的指令，你可以通过在一个已知寄存器中添加一个新入口的方式来实现。在一行的行首，执行 <code>&quot;ay$</code>。这将会告诉 Vim 你打算使用寄存器 “a” （<code>&quot;a</code>） 来存储从当前位置到行末的文本（<code>y$</code>）。</p>
<p>现在，但你执行 <code>@a</code> 时，你的宏命令会自动改变第一个单词的大小写，在“donut”前面添加“deep fried”，之后在行末添加“.”。</p>
<p>另一个修改宏命令的方式是通过命令行解析。执行 <code>:let @a=&quot;</code>，之后执行 <code>Ctrl-r Ctrl-r a</code>，这会将寄存器“a”的命令逐字打印出来。最后，别忘记在闭合的引号（<code>&quot;</code>）。如果你希望在编辑命令行表达式时插入内部码来使用特定的字符，你可以使用 <code>Ctrl-v</code>。</p>
<h2 id="拷贝宏"><a href="#拷贝宏" class="headerlink" title="拷贝宏"></a>拷贝宏</h2><p>你可以很轻松的将一个寄存器的内容拷贝到另一个寄存器。例如，你可以使用 <code>:let @z = @a</code> 将寄存器“a” 中的命令拷贝到寄存器“z”。 <code>@a</code> 表示寄存器“a”中存储的内容，你现在执行 <code>@z</code>，将会执行和 <code>@a</code> 一样的指令。</p>
<p>我发现对常用的宏命令创建冗余是很有用的。在我的工作流程中，我通常在前7个字母（a-g）上创建宏命令，并且我经常不加思索地把它们替换了。因此，如果我将很有用的宏命令移动到了字母表的末尾，就不用担心我在无意间把他们替换了。</p>
<h2 id="连续执行宏命令"><a href="#连续执行宏命令" class="headerlink" title="连续执行宏命令"></a>连续执行宏命令</h2><p>Vim 可以连续和同时运行宏命令，假设你有如下的文本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; FUNC1 &#125; from &quot;library1&quot;;</span><br><span class="line">import &#123; FUNC2 &#125; from &quot;library2&quot;;</span><br><span class="line">import &#123; FUNC3 &#125; from &quot;library3&quot;;</span><br><span class="line">import &#123; FUNC4 &#125; from &quot;library4&quot;;</span><br><span class="line">import &#123; FUNC5 &#125; from &quot;library5&quot;;</span><br></pre></td></tr></table></figure>


<p>假如你希望把所有的 “FUNC” 字符变为小写，那么宏命令为如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qa0f&#123;gui&#123;jq</span><br></pre></td></tr></table></figure>


<p>分解如下：</p>
<ul>
<li><code>qa</code> 开始记录宏命令到 “a” 寄存器。</li>
<li><code>0</code>移动到第一行。</li>
<li><code>f&#123;</code> 查找第一个 “{” 字符。</li>
<li><code>gui&#123;</code> 把括号内的文本（<code>i&#123;</code>）变为小写（<code>gu</code>）。</li>
<li><code>j</code> 移动到下一行。</li>
<li><code>q</code> 停止记录宏命令。</li>
</ul>
<p>现在，执行 <code>99@a</code> 在剩余的行修改。然而，假如在你的文本里有如下 import 语句会怎么样呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; FUNC1 &#125; from &quot;library1&quot;;</span><br><span class="line">import &#123; FUNC2 &#125; from &quot;library2&quot;;</span><br><span class="line">import &#123; FUNC3 &#125; from &quot;library3&quot;;</span><br><span class="line">import foo from &quot;bar&quot;;</span><br><span class="line">import &#123; FUNC4 &#125; from &quot;library4&quot;;</span><br><span class="line">import &#123; FUNC5 &#125; from &quot;library5&quot;;</span><br></pre></td></tr></table></figure>


<p>执行 <code>99@a</code>，会只在前三行执行。而最后两行不会被执行，因为在执行第四行（包含“foo”）时会遇到错误而停止。然而这种情况你希望继续向下执行。你可以移动到包含（“FUNC4”）的一行，并重新调用该命令。但是假如你希望仅调用一次命令就完成所有操作呢？你可以并行地执行宏命令。</p>
<p>如本章前面所说，可以使用 <code>:normal</code> 去执行宏命令，（例如： <code>:3,5 normal @a</code> 会在 3-5行执行 a 寄存器中的宏命令）。如果执行 <code>:1,$ normal @a</code>，会在所有除了包含有 “foo” 的行执行，而且它不会出错。</p>
<p>尽管本质上来说，Vim 并不是在并行地执行宏命令，但表面上看，它是并行运行的。 Vim 会独立地在从第一行开始（<code>1,$</code>）每一行执行 <code>@a</code> 。由于 Vim 独立地在每一行执行命令，每一行都不会知道有一行（包含“foo”）会遇到执行错误。</p>
<h2 id="聪明地学习宏命令"><a href="#聪明地学习宏命令" class="headerlink" title="聪明地学习宏命令"></a>聪明地学习宏命令</h2><p>你在编辑器里做的很多事都是重复的。为了更好地编辑文件，请乐于发现这些重复性的行为。执行宏命令或者点命令，而不是做相同的动作两次。几乎所有你在 Vim 所作的事情都可以变为宏命令。</p>
<p>刚开始的时候，我发现宏命令时很棘手的，但是请不要放弃。有了足够的练习，你可以找到这种文本自动编辑的快乐。</p>
<p>使用某种助记符去帮助你记住宏命令是很有帮助的。如果你有一个创建函数（function）的宏命令，你可以使用 “f” 寄存器去录制它。如果你有一个宏命令去操作数字，那么使用寄存器 “n” 去记住它是很好的。用你想执行的操作时想起的第一个字符给你的宏命令命名。另外，我发现 “q” 是一个很好的宏命令的寄存器，因为执行 “qq” 去调用宏命令是很快速而简单的。最后，我喜欢按照字母表的顺序去添加我的宏命令，例如从 <code>qa</code> 到 <code>qb</code> 再到 <code>qc</code>。去寻找最适合你的方法吧。</p>
<h1 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h1><p>对于任何一个现代的软件来说，撤销都是一个很基本的特性。 Vim 的撤销系统不仅支持撤销和取消撤销任何修改，而且支持改动时间线功能。 在本章中，你将会学会如何执行撤销和 取消撤销文本，浏览撤销分支，反复撤销, 以及浏览改动时间线。</p>
<h2 id="Undo，Redo，和-UNDO"><a href="#Undo，Redo，和-UNDO" class="headerlink" title="Undo，Redo，和 UNDO"></a>Undo，Redo，和 UNDO</h2><p>对于一个基本的 undo 操作，你可以执行 <code>u</code> 或者 <code>:undo</code>。<br>假设你有如下文本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">one</span><br></pre></td></tr></table></figure>


<p>以及另一个文本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br></pre></td></tr></table></figure>


<p>如果你执行 <code>u</code>，Vim 会删除 “two”。<br>Vim 是如何知道应该恢复多少修改呢？ 答案是，Vim每次仅恢复一次修改，这有点类似于点命令的操作（和 点命令不同之处在于，命令行命令也会被算作一次修改）。</p>
<p>为了取消上一次的撤销，执行 <code>Ctrl-R</code> 或者 <code>:redo</code>。例如上面的例子中，当你执行撤销来删除 “two” 以后，你可以执行 <code>Ctrl-R</code> 来恢复被删除掉的文本。</p>
<p>Vim 也有另一个命令 <code>U</code> 可以实现 UNDO 的功能，执行这个命令会撤销所有最新的修改。<br>那么，<code>U</code> 和 <code>u</code> 的区别是什么呢？首先，<code>U</code> 会删除 <em>所有的</em> 最新的修改，而 <code>u</code> 一次仅删除一次修改。 其次，执行<code>u</code> 不会被算作一次修改，而执行 <code>U</code> 则会被算作一次修改。</p>
<p>让我们会的之前的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br></pre></td></tr></table></figure>


<p>修改第二行的内容为 “three” (<code>ciwthree&lt;esc&gt;</code>):</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">one</span><br><span class="line">three</span><br></pre></td></tr></table></figure>


<p>再次修改第二行的例子为 “four” (<code>ciwfour&lt;esc&gt;</code>):</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">one</span><br><span class="line">four</span><br></pre></td></tr></table></figure>


<p>此时，如果你按下 <code>u</code>，你会看到 “three”。如果你再次按下 <code>u</code>，你会看到 “two”。然而，在第二行任为 “four” 的时候，如果你按下 <code>U</code>，你会看到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">one</span><br></pre></td></tr></table></figure>


<p>执行 <code>U</code> 会跳过中间所有修改，直接恢复到文件最初的状态（第二行为空）。另外，由于 UNO 实际上是执行了一个新的修改，因此你可以 UNDO 执行过的 UNDO。 执行 <code>U</code> 后 再次执行 <code>U</code> 会撤销 自己。假如你连续执行 <code>U</code>，那么你将看到第二行的文本不停地出现和消失。</p>
<p>就我个人而言，我几乎不会使用 <code>U</code>，因为很难记住文本最初的样子。如果非说在什么场景下使用 <code>U</code>，那就是在我意外地执行了 <code>Shift-u</code>。</p>
<p>Vim 可以通过变量 <code>undolevels</code> 来选择最多可执行 undo 的次数。你可以通过 <code>:echo &amp;undolevels</code> 来查看当前的配置。我一般设置为 1000。如果你也想设置为 1000 的话，你可以执行 <code>:set undolevels=1000</code>。不用担心，你可以设置它为任何一个你想设置的值。</p>
<h2 id="断点插入操作"><a href="#断点插入操作" class="headerlink" title="断点插入操作"></a>断点插入操作</h2><p>在上文中我提到，<code>u</code> 每次恢复一个修改，类似于点命令。在每次进入 插入模式和退出插入模式之间的任何修改都被定义为一次修改。</p>
<p>如果你执行 <code>ione two three&lt;esc&gt;</code> 之后，按下 <code>u</code>，Vim 会同时删除 “one two three”，因为这是一笔修改。如果你每次只输入较短的文本，那这是可接受的；可假设你在一次插入模式中输入了大量的文本，而后退出了插入模式，可很快你意识到这中间有部分错误。此时，如果你按下 <code>u</code>，你会丢失上一次输入的所有内容。 因此，假设你按下 <code>u</code> 只删除你上一次输入的一部分文本岂不是会更好。</p>
<p>幸运的是，你可以拆分它。当你在插入模式时，按下 <code>Ctrl-G u</code> 会生成一个断点。例如，如果你执行 <code>ione &lt;Ctrl-G u&gt;two &lt;Ctrl-G u&gt;three&lt;esc&gt;</code>，之后你按下<code>u</code>，你仅会失去文本 “three”，再次执行 <code>u</code>，会删除 “two”。当你想要输入一长段内容时，应该有选择性地执行断点插入操作。在每一句话的末尾，两个段落的中间，或者每一行代码结束时插入断点是一个很好的选择，这可以帮助你快速从错误中恢复出来。</p>
<p>在执行删除操作后插入断点也非常有用，例如通过 <code>Ctrl-W</code> 删除光标前的单词，以及 <code>Ctrl-U</code>删除光标前的所有文本。一个朋友建议我使用如下的映射：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inoremap &lt;c-u&gt; &lt;c-g&gt;u&lt;c-u&gt;</span><br><span class="line">inoremap &lt;c-w&gt; &lt;c-g&gt;u&lt;c-w&gt;</span><br></pre></td></tr></table></figure>


<p>通过上述命令，你可以很轻松地恢复被删除的文本。</p>
<h2 id="撤销树"><a href="#撤销树" class="headerlink" title="撤销树"></a>撤销树</h2><p>Vim 将每一次修改存储在一个撤销树中。如果你打开一个空白文件:</p>
<p>插入一段话：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">one</span><br></pre></td></tr></table></figure>


<p>插入一段话：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br></pre></td></tr></table></figure>


<p>undo:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">one</span><br></pre></td></tr></table></figure>


<p>插入一段不同的话：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">one</span><br><span class="line">three</span><br></pre></td></tr></table></figure>


<p>再次 undo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">one</span><br></pre></td></tr></table></figure>


<p>插入另一段话：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">one</span><br><span class="line">four</span><br></pre></td></tr></table></figure>


<p>现在如果你执行 undo:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">one</span><br></pre></td></tr></table></figure>


<p>如果你再次执行 undo 操作：</p>
<p>文本 “one” 也会丢失。对于大部分编辑器来说，找回文本 “two” 和 “three” 都是不可能的事情，但是对于 Vim 来说却不是这样。执行 <code>g+</code>，你会得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">one</span><br></pre></td></tr></table></figure>


<p>再次执行 <code>g+</code> ，你将会看到一位老朋友:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br></pre></td></tr></table></figure>


<p>让我们继续执行 <code>g+</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">one</span><br><span class="line">three</span><br></pre></td></tr></table></figure>


<p>再一次执行 <code>g+</code> :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">one</span><br><span class="line">four</span><br></pre></td></tr></table></figure>


<p>在 Vim 中，你每一次执行 <code>u</code> 去做一次修改时，Vim都会通过创建一个“撤销分支”来保存下之前的文本内容。在本例中，你先输入“two”, 执行 <code>u</code>，输入“three”，执行 <code>u</code>，然后输入“three”，此时，撤销树已经包含了至少两个叶子节点，主节点包含文本“three”（最新），分支节点包含文本“two”。假如你执行了另一次撤销操作并且输入了“four”，那么此时会生成三个节点，一个主节点包含文本“four”, 以及另外两个节点分别存储了“three”和“two”。</p>
<p>为了在几个不同的节点状态间进行切换，你可以执行 <code>g+</code> 去获取一个较新的状态，以及执行 <code>g-</code> 去获取一个教旧的状态。 <code>u</code>， <code>Ctrl-R</code>， <code>g+</code>， 和 <code>g-</code> 之间的区别是，<code>u</code> and <code>Ctrl-R</code> 只可以在 <em>main</em> 节点之间进行切换，而<code>g+</code> 和 <code>g-</code> 可以在 <em>所有</em> 节点之间进行切换。</p>
<p>Undo 树并不可以很轻松地可视化。我发现一个插件 <a href="https://github.com/simnalamburt/vim-mundo">vim-mundo</a> 对于理解 undo 树很有帮助。花点时间去与它玩耍吧。</p>
<h2 id="保持撤销状态"><a href="#保持撤销状态" class="headerlink" title="保持撤销状态"></a>保持撤销状态</h2><p>当你通过 Vim 打开一个文件，并且立即按下 <code>u</code>，Vim 很可能会显示 “_Already at oldest change_” 的警告。 Vim 可以通过 <code>:wundo</code> 保持一份你的 undo 历史记录。</p>
<p>创建一个文件 <code>mynumbers.txt</code>. 输入:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">one</span><br></pre></td></tr></table></figure>


<p>插入另一行文件 (确保你要么退出并重新进入插入模式，要么创建了断点):</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br></pre></td></tr></table></figure>


<p>插入新的一行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br></pre></td></tr></table></figure>


<p>现在，创建你的撤销记录文件。 语法为 <code>:wundo myundofile</code>。 如果你需要覆盖一个已存在的文件，在 <code>wundo</code> 之后添加 <code>!</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:wundo! mynumbers.undo</span><br></pre></td></tr></table></figure>


<p>退出 Vim。</p>
<p>此时，在目录下，应该有<code>mynumbers.txt</code> 和 <code>mynumbers.undo</code> 两个文件。再次打开 <code>mynumbers.txt</code> 文件并且按下 <code>u</code>，这是没有响应的。因为自打开文件后，你没有执行任何的修改。现在，通过执行 <code>:rundo</code> 来加载 undo 历史。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:rundo mynumbers.undo</span><br></pre></td></tr></table></figure>


<p>此时，如果你按下 <code>u</code>，Vim 会删除 “three”。再次按下 <code>u</code>可以删除 “two”。这就好像你从来没有关闭过 Vim 一样。</p>
<p>如果你想要自动加载 undo 历史文件，你可以通过在你的 <code>.vimrc</code> 文件中添加如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set undodir=~/.vim/undo_dir</span><br><span class="line">set undofile</span><br></pre></td></tr></table></figure>


<p>我认为将所有的 undo 文件集中保存在一个文件夹中最好，例如在 <code>~/.vim</code> 目录下。 <code>undo_dir</code> 是随意的。 <code>set undofile</code> 告诉 Vim 打开 <code>undofile</code> 这个特性，因为该特性默认是关闭的。现在，无论你何时保存，Vim 都会自动创建和保存撤销的历史记录（在使用<code>undo_dir</code>目录前，请确保你已经创建了它）。</p>
<h2 id="时间旅行"><a href="#时间旅行" class="headerlink" title="时间旅行"></a>时间旅行</h2><p>是谁说时间旅行不存在。 Vim 可以通过 <code>:earlier</code> 命令将文本恢复为之前的状态。</p>
<p>假如有如下文本:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">one</span><br></pre></td></tr></table></figure>


<p>之后你输入了另一行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br></pre></td></tr></table></figure>


<p>如果你输入 “two” 的时间少于10秒，那么你可以通过如下命令恢复到 “two” 还没被输入前的状态:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:earlier 10s</span><br></pre></td></tr></table></figure>


<p>你可以使用 <code>:undolist</code> 去查看之前所做的修改。 <code>:earlier</code> 可以加上分钟 (<code>m</code>), 小时 (<code>h</code>), and 天 (<code>d</code>) 作为参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:earlier 10s    恢复到10秒前的状态</span><br><span class="line">:earlier 10m    恢复到10分钟前的状态</span><br><span class="line">:earlier 10h    恢复到10小时前的状态</span><br><span class="line">:earlier 10d    恢复到10天前的状态</span><br></pre></td></tr></table></figure>


<h2 id="聪明地学习撤销操作"><a href="#聪明地学习撤销操作" class="headerlink" title="聪明地学习撤销操作"></a>聪明地学习撤销操作</h2><p><code>u</code> 和 <code>Ctrl-R</code> 是两个不可缺少的 Vim 参数。请先学会它们。在我的工作流中，我并不使用 UNDO，然而我认为承认它存在是很好的。下一步，学会如何使用<code>:earlier</code> 和 <code>:later</code>，以及时间参数。在这之后，请花些时间理解 undo 树。 插件 <a href="https://github.com/simnalamburt/vim-mundo">vim-mundo</a> 对我的帮助很大。单独输入本章中展示的文本，并且查看撤销树的每一次改变。一旦你掌握它，你看待撤销系统的眼光一定不同。</p>
<p>在本章之前，你学习了如何在项目内查找任何文本，配合撤销，你可以在时间维度上查找任何一个文本。你现在可以通过位置和写入时间找到任何一个你想找的文本。你已经对 Vim 无所不能了。</p>
<h1 id="可视模式"><a href="#可视模式" class="headerlink" title="可视模式"></a>可视模式</h1><p>您可能知道您可以高亮显示文本块并对其进行更改。 Vim也可以使用可视模式。 Vim有三种不同的可视模式可供使用。在本章中，您将学习如何使用每种可视模式来有效地处理文本块。</p>
<h2 id="三种可视模式"><a href="#三种可视模式" class="headerlink" title="三种可视模式"></a>三种可视模式</h2><p>这三种模式是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v         角色可视模式</span><br><span class="line">V         逐行可视模式</span><br><span class="line">Ctrl-v    逐块可视模式</span><br></pre></td></tr></table></figure>


<p>如果您有文字：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br></pre></td></tr></table></figure>


<p>逐字符可视模式用于选择单个字符。在第一行的第一个字符上按<code>v</code>。然后使用<code>j</code>跳转至下一行。它高亮显示从”one”到光标位置的所有文本。现在，如果您按<code>gU</code>，Vim将高亮显示的字符转为大写。</p>
<p>逐行可视模式适用于整行。按<code>V</code>并观看Vim选择光标的所在行。就像逐字符可视模式一样，如果您运行<code>gU</code>，Vim将高亮显示的字符转为大写。</p>
<p>逐块可视模式适用于行和列。与其他两种模式相比，它为您提供了更大的移动自由度。按<code>Ctrl-V</code>。 Vim像逐个字符可视模式一样高亮显示光标下的字符，除了可以在下一行之前不高亮显示每个字符直到行的末尾，它可以转到下一行而不高亮显示当前行的整个字符。尝试用<code>h/j/k/l</code>移动，并观察光标的移动。</p>
<p>在Vim窗口的左下方，您会看到显示<code>-- VISUAL --</code>，<code>-- VISUAL LINE --</code>或<code>-- VISUAL BLOCK --</code>以提示您所处的可视模式。</p>
<p>当您处于可视模式时，可以通过按<code>v</code>，<code>V</code>或<code>Ctrl-V</code>键切换到另一种可视模式。例如，如果您处于逐行可视模式，并且想要切换为逐块可视模式，请运行<code>Ctrl-V</code>。试试吧！</p>
<p>有三种退出可视模式的方法：<code>esc</code>，<code>Ctrl-C</code>和与当前可视模式相同的键。</p>
<p>后者的意思是，如果您当前处于逐行可视模式(<code>V</code>)，则可以通过再次按<code>V</code>退出它。如果您处于字符可视模式，则可以通过按<code>v</code>退出它。如果您处于逐块可视模式，请按<code>Ctrl-V</code>。</p>
<p>实际上，还有另一种进入可视模式的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gv    转到上一个可视模式</span><br></pre></td></tr></table></figure>


<p>它将在与上次相同的高亮显示的文本块上启动相同的可视模式。</p>
<h2 id="可视模式导航"><a href="#可视模式导航" class="headerlink" title="可视模式导航"></a>可视模式导航</h2><p>在可视模式下，您可以使用Vim动作扩展高亮显示的文本块。</p>
<p>让我们使用之前使用的相同文本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br></pre></td></tr></table></figure>


<p>这次让我们从”two”行开始。按<code>v</code>进入字符可视模式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">one</span><br><span class="line">[t]wo</span><br><span class="line">three</span><br></pre></td></tr></table></figure>


<p>按<code>j</code>，Vim将高亮显示从”two”行到”three”行的第一个字符的所有文本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">one</span><br><span class="line">[two</span><br><span class="line">t]hree</span><br></pre></td></tr></table></figure>


<p>假设您刚刚意识到还需要高亮显示”one”行，因此按<code>k</code>。令您沮丧的是，它现在排除了”three”。按<code>k</code>实际上会还原高亮，而不是使其高亮。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">one</span><br><span class="line">[t]wo</span><br><span class="line">three</span><br></pre></td></tr></table></figure>


<p>有没有一种方法可以自由地扩展视觉选择范围，以向您想要的任何方向发展？</p>
<p>答案是肯定的。让我们稍微备份一下高亮显示”two”和”three”行的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">one</span><br><span class="line">[two</span><br><span class="line">t]hree    &lt;-- 光标</span><br></pre></td></tr></table></figure>


<p>视觉高光跟随光标移动。如果要将其向上扩展到行”one”，则需要在光标位于字母”two”而不是”three”上时向上移动光标。现在，您的光标在”three”行上。要移动它，用<code>o</code>或<code>O</code>切换光标位置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">one</span><br><span class="line">[two     &lt;-- 光标</span><br><span class="line">t]hree</span><br></pre></td></tr></table></figure>


<p>现在，当您按<code>k</code>时，它不再缩小选择，而是向上扩展。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[one</span><br><span class="line">two</span><br><span class="line">t]hree</span><br></pre></td></tr></table></figure>


<h2 id="可视模式语法"><a href="#可视模式语法" class="headerlink" title="可视模式语法"></a>可视模式语法</h2><p>可视模式是Vim的一种模式。成为一种模式意味着同一键的工作方式可能不同于另一种模式。幸运的是，可视模式与普通模式共享许多常用键。</p>
<p>例如，如果您有以下文字：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br></pre></td></tr></table></figure>


<p>用逐行可视模式(<code>V</code>)高亮显示”one”和”two”行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[one</span><br><span class="line">two]</span><br><span class="line">three</span><br></pre></td></tr></table></figure>


<p>按下<code>d</code>键将删除选择，类似于普通模式。请注意，普通模式的语法规则动词+名词不适用。仍然存在相同的动词(<code>d</code>)，但在可视模式下没有名词。可视模式下的语法规则是名词+动词，其中名词是高亮显示的文本。首先选择文本块，然后进行操作。</p>
<p>在普通模式下，有一些命令不需要移动，例如<code>x</code>删除光标下方的单个字符，<code>rx</code>替换光标下方的字符为<code>x</code>。在可视模式下，这些命令现在将应用于整个高亮显示的文本，而不是单个字符。返回高亮显示的文本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[one</span><br><span class="line">two]</span><br><span class="line">three</span><br></pre></td></tr></table></figure>


<p>运行<code>x</code>会删除所有高亮显示的文本。</p>
<p>您可以使用此行为在markdown文本中快速创建标题。假设您在markdown文件中有一个文本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Chapter One</span><br></pre></td></tr></table></figure>


<p>您需要快速将此标题转换为标题。首先，您使用<code>yy</code>复制文本，然后使用<code>p</code>粘贴文本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Chapter One</span><br><span class="line">Chapter One</span><br></pre></td></tr></table></figure>


<p>现在转到第二行，以逐行可视模式选择它：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Chapter One</span><br><span class="line">[Chapter One]</span><br></pre></td></tr></table></figure>


<p>在markdown中，您可以通过在文本下方添加一系列<code>=</code>来创建标题，因此您可以通过运行<code>r=</code>来替换整个高亮显示的文本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Chapter One</span><br><span class="line">===========</span><br></pre></td></tr></table></figure>


<p>要了解有关可视模式下的运算符的更多信息，请查看<code>:h visual-operators</code>。</p>
<h2 id="可视模式和Ex命令"><a href="#可视模式和Ex命令" class="headerlink" title="可视模式和Ex命令"></a>可视模式和Ex命令</h2><p>您可以有选择地在高亮显示的文本块上应用Ex命令。如果您具有以下表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const one = &quot;one&quot;;</span><br><span class="line">const two = &quot;two&quot;;</span><br><span class="line">const three = &quot;three&quot;;</span><br></pre></td></tr></table></figure>


<p>您只需要用”let”替换”const”的前两行。用_任何_可视模式高亮显示前两行，然后运行替代命令<code>:s/const/let/g</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let one = &quot;one&quot;;</span><br><span class="line">let two = &quot;two&quot;;</span><br><span class="line">const three = &quot;three&quot;;</span><br></pre></td></tr></table></figure>


<p>请注意，我说过您可以使用_任何_可视模式执行此操作。您不必高亮显示整个行即可在该行上运行Ex命令。只要您在每行上至少选择一个字符，就会应用Ex命令。</p>
<h2 id="跨多行编辑"><a href="#跨多行编辑" class="headerlink" title="跨多行编辑"></a>跨多行编辑</h2><p>您可以使用逐块可视模式在Vim中跨多行编辑文本。如果需要在每行末尾添加分号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const one = &quot;one&quot;</span><br><span class="line">const two = &quot;two&quot;</span><br><span class="line">const three = &quot;three&quot;</span><br></pre></td></tr></table></figure>


<p>将光标放在第一行上：<br>-运行逐块可视模式，并向下两行(<code>Ctrl-V jj</code>)。<br>-高亮显示到行尾(<code>$</code>)。<br>-附加(<code>A</code>) ，然后键入”;”。<br>-退出可视模式(<code>esc</code>)。</p>
<p>您应该看到附加的 “;” 在每一行上。顺便说一下，在逐块可视模式下，要进入插入模式，可以使用<code>A</code>在光标后输入文本，也可以使用<code>I</code>在光标前输入文本。请勿将它们与正常模式下的<code>A</code>和<code>I</code>混淆。</p>
<p>另外，您也可以使用<code>:normal</code>命令：</p>
<p>-高亮显示所有3行(<code>vjj</code>)。<br>-输入<code>:normal! A;</code>。</p>
<p>记住，<code>:normal</code>命令执行普通模式命令。您可以指示它运行<code>A;</code>来添加文本”;”在该行的末尾。</p>
<h2 id="递增数字"><a href="#递增数字" class="headerlink" title="递增数字"></a>递增数字</h2><p>Vim有<code>Ctrl-X</code>和<code>Ctrl-A</code>命令来减少和增加数字。与可视模式一起使用时，可以跨多行递增数字。</p>
<p>如果您具有以下HTML元素：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app-1&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-1&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-1&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-1&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-1&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>


<p>有多个具有相同名称的id是一个不好的做法，因此让我们对其进行递增以使其唯一：<br>-将光标移动到_第二个_”1”。<br>-启动逐块可视模式，并向下移动3行(<code>Ctrl-V 3j</code>)。这高亮显示剩余的”1”s。<br>-运行<code>g Ctrl-A</code>。</p>
<p>您应该看到以下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app-1&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-2&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-3&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-4&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-5&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>


<p><code>g Ctrl-A</code>在多行上递增数字。 <code>Ctrl-X/Ctrl-A</code>也可以增加字母。如果您运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:set nrformats+=alpha</span><br></pre></td></tr></table></figure>


<p><code>nrformats</code>选项指示Vim将哪个基数视为<code>Ctrl-A</code>和<code>Ctrl-X</code>递增和递减的“数字”。通过添加<code>alpha</code>，现在将字母字符视为数字。如果您具有以下HTML元素：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app-a&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-a&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-a&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-a&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-a&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>


<p>将光标放在第二个”app-a”上。使用与上述相同的技术(<code>Ctrl-V 3j</code> 然后 <code>g Ctrl-A</code>)增加ID。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app-a&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-b&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-c&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-d&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;app-e&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>


<h2 id="选择最后一个可视模式区域"><a href="#选择最后一个可视模式区域" class="headerlink" title="选择最后一个可视模式区域"></a>选择最后一个可视模式区域</h2><p>您了解到<code>gv</code>可以快速高亮显示上一个可视模式。您还可以使用以下两个特殊标记转到最后一个可视模式的开始和结束位置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`&lt;    转到上一个可视模式高亮显示的最后一个位置</span><br><span class="line">`&gt;    转到上一个可视模式高亮显示的第一位</span><br></pre></td></tr></table></figure>


<p>我要你观察一些东西。之前，我提到过您可以在高亮显示的文本上有选择地执行Ex命令，例如：<code>:s/const/let/g</code>。当您这样做时，您应该看到以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:`&lt;,`&gt;s/const/let/g</span><br></pre></td></tr></table></figure>


<p>您实际上是在使用标记作为范围来执行<code>s/const/let/g</code>命令。您随时可以随时编辑这些标记。相反，如果您需要从高亮显示的文本的开头到文件的末尾进行替换，则只需将命令行更改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:`&lt;,$s/const/let/g</span><br></pre></td></tr></table></figure>


<h2 id="从插入模式进入可视模式"><a href="#从插入模式进入可视模式" class="headerlink" title="从插入模式进入可视模式"></a>从插入模式进入可视模式</h2><p>您也可以从插入模式进入可视模式。在插入模式下进入字符可视模式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ctrl-O v</span><br></pre></td></tr></table></figure>


<p>回想一下，在插入模式下运行<code>Ctrl-O</code>可以使您执行普通模式命令。在正常模式命令挂起模式下，运行<code>v</code>进入逐字可视模式。请注意，在屏幕的左下方，它显示为<code>--(insert) VISUAL--</code>。该技巧适用于任何可视模式运算符：<code>v</code>，<code>V</code>，和<code>Ctrl-V</code>。</p>
<h2 id="选择模式"><a href="#选择模式" class="headerlink" title="选择模式"></a>选择模式</h2><p>Vim具有类似于可视模式的模式，称为_选择模式_。与可视模式一样，它也具有三种不同的模式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gh         逐字符选择模式</span><br><span class="line">gH         逐行选择模式</span><br><span class="line">gCtrl-h    逐块选择模式</span><br></pre></td></tr></table></figure>


<p>选择模式比Vim的可视模式更接近常规编辑器的文本高亮显示行为。</p>
<p>在常规编辑器中，高亮显示文本块并键入字母（例如字母”y”）后，它将删除高亮显示的文本并插入字母”y”。</p>
<p>如果您使用逐行选择模式(<code>gH</code>)高亮显示一行文本并键入”y”，它将删除高亮显示的文本并插入字母”y”，这与常规文本编辑器非常相似。</p>
<p>将此行为与可视模式进行对比：如果您使用逐行可视模式(<code>V</code>)高亮显示一行文本并键入”y”，则高亮显示的文本不会被删除，而是由文字字母”y”代替。仅将其拉动并存储在拉动寄存器<code>&quot;0</code>中。</p>
<p>我个人从未使用过选择模式，但是很高兴知道它的存在。</p>
<h2 id="以聪明的方式学习可视模式"><a href="#以聪明的方式学习可视模式" class="headerlink" title="以聪明的方式学习可视模式"></a>以聪明的方式学习可视模式</h2><p>可视模式是Vim高亮显示文本的过程。</p>
<p>如果发现使用可视模式操作的频率比正常模式操作的频率高得多，请当心。我认为这是一种反模式。运行可视模式操作所需的击键次数要多于普通模式下的击键次数。如果您需要删除一个内部单词，那么为什么只用三个按键(<code>diw</code>)就可以使用四个按键<code>viwd</code>（在视觉上高亮显示一个内部单词然后删除）呢？后者更为直接和简洁。当然，有时会使用适当的可视模式，但总的来说，更倾向于直接的方法。</p>
<h1 id="搜索和替换"><a href="#搜索和替换" class="headerlink" title="搜索和替换"></a>搜索和替换</h1><p>本章涵盖两个独立但相关的概念:搜索和替代。很多时候，您要搜索的文本并不简单，你必须寻找一个共同的模式。通过学习如何在搜索和替换中使用有意义的模式而不是文字，您将能够快速定位任何文本。</p>
<p>附带说明一下，在本章中，当谈论搜索时，我将主要使用<code>/</code>。您可以使用<code>/</code>进行的所有操作也可以使用<code>?</code>完成。</p>
<h2 id="智能区分大小写"><a href="#智能区分大小写" class="headerlink" title="智能区分大小写"></a>智能区分大小写</h2><p>尝试匹配搜索词的大小写可能会很棘手。如果要搜索文本”Learn Vim”，则很容易错误键入一个字母的大小写，并得到错误的搜索结果。如果可以匹配任何情况，会不会更轻松，更安全？这是选项<code>ignorecase</code>闪亮的地方。只需在 vimrc 中添加<code>setignorecase</code>，所有搜索词就不区分大小写。现在，您不必再执行<code>/Learn Vim</code>了。 <code>/learn vim</code>将起作用。</p>
<p>但是，有时您需要搜索特定于案例的短语。一种方法是用 <code>set ignorecase</code> 关闭<code>ignorecase</code>选项，但是每次需要搜索区分大小写的短语时，都要打开和关闭很多工作。</p>
<p>是否有一种设置可以让您在大多数时间进行不区分大小写的搜索，但又知道在需要时进行区分大小写的搜索？原来有办法。</p>
<p>如果搜索模式_至少包含一个大写字符_，Vim 有一个<code>smartcase</code>选项来覆盖<code>ignorecase</code>。当您输入所有小写字符时，您可以将”ignorecase”和”smartcase”结合使用以执行不区分大小写的搜索，而输入一个或多个大写字符时则执行区分大小写的搜索。</p>
<p>在您的 vimrc 中，添加:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set ignorecase smartcase</span><br></pre></td></tr></table></figure>


<p>如果您有这些文字:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello</span><br><span class="line">HELLO</span><br><span class="line">Hello</span><br></pre></td></tr></table></figure>


<p>您可以使用搜索词的大小写来控制不区分大小写:</p>
<ul>
<li><code>/hello</code> 匹配”hello”，”HELLO”和”Hello”。</li>
<li><code>/HELLO</code> 仅匹配”HELLO”。</li>
<li><code>/Hello</code> 仅匹配”Hello”。</li>
</ul>
<p>有一个缺点。 如果只需要搜索小写字符串怎么办？<br>当您执行<code>/hello</code>时，Vim 将始终匹配其大写变体。<br>如果您不想匹配它们怎么办？您可以在搜索词前使用<code>\C</code>模式来告诉 Vim，<br>后续搜索词将区分大小写。如果执行<code>/\Chello</code>，它将严格匹配”hello”，而不是”HELLO”或”Hello”。</p>
<h2 id="一行中的第一个和最后一个字符"><a href="#一行中的第一个和最后一个字符" class="headerlink" title="一行中的第一个和最后一个字符"></a>一行中的第一个和最后一个字符</h2><p>您可以使用<code>^</code>匹配行中的第一个字符，并使用<code>$</code>匹配行中的最后一个字符。</p>
<p>如果您有以下文字:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello hello</span><br></pre></td></tr></table></figure>


<p>您可以使用<code>/^hello</code>来定位第一个”hello”。 ^后面的字符必须是一行中的第一个字符。 要定位最后一个”hello”，请运行<code>/hello$</code>。 $之前的字符必须是一行中的最后一个字符。</p>
<p>如果您有以下文字:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello hello friend</span><br></pre></td></tr></table></figure>


<p>运行<code>/hello$</code>将匹配不到任何内容，因为”friend”是该行的最后一项，而不是”hello”。</p>
<h2 id="重复搜索"><a href="#重复搜索" class="headerlink" title="重复搜索"></a>重复搜索</h2><p>您可以使用”//“重复上一个搜索。如果您只是搜索<code>/hello</code>，则运行<code>//</code>等同于运行<code>/hello</code>。此快捷键可以为您节省一些按键操作，尤其是在您搜索了很长时间的情况下。还记得您还可以使用”n”和”N”分别以相同方向和相反方向重复上一次搜索。</p>
<p>如果您想快速回忆起_n_个最后一个搜索字词怎么办？您可以先遍历<code>/</code>，然后按“向上”/“向下”箭头键（或<code>Ctrl-N</code>/<code>Ctrl-P</code>），快速遍历搜索历史，直到找到所需的搜索词。要查看所有搜索历史，可以运行<code>:history/</code>。</p>
<p>在搜索过程中到达文件末尾时，Vim 会引发错误:<code>&quot;搜索未找到匹配项的底部:&lt;your-search&gt;&quot;</code>(<code>&quot;Search hit the BOTTOM without match for: &lt;your-search&gt;&quot;</code>)。有时，这可以防止过度搜索，但是有时您又想将搜索重新循环到顶部。您可以使用<code>set wrapscan</code>选项使 Vim 在到达文件末尾时在文件顶部进行搜索。要关闭此功能，请执行<code>set nowrapscan</code>。</p>
<h2 id="搜索替代词"><a href="#搜索替代词" class="headerlink" title="搜索替代词"></a>搜索替代词</h2><p>通常一次搜索多个单词。 如果您需要搜索”hello vim”或”hola vim”，而不是”salve vim”或”bonjour vim”，则可以使用||管道替代语法。</p>
<p>给予这样一段文本:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello vim</span><br><span class="line">hola vim</span><br><span class="line">salve vim</span><br><span class="line">bonjour vim</span><br></pre></td></tr></table></figure>


<p>要同时匹配”hello”和”hola”，可以执行<code>/hello\|hola</code>。 您必须转义（<code>\</code>）管道（<code>|</code>）运算符，否则 Vim 将按字面意义搜索字符串”|”。</p>
<p>如果您不想每次都输入<code>\|</code>，则可以在搜索开始时使用<code>魔术</code>语法（<code>\v</code>）:<code>/\vhello|hola</code>。 我不会在本章中介绍“魔术”，但是有了”\v”，您就不必再转义特殊字符了。 要了解有关<code>\v</code>的更多信息，请随时查看<code>:h \v</code>。</p>
<h2 id="设置比赛的开始和结束"><a href="#设置比赛的开始和结束" class="headerlink" title="设置比赛的开始和结束"></a>设置比赛的开始和结束</h2><p>也许您需要搜索作为复合词一部分的文本。 如果您有这些文字:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11vim22</span><br><span class="line">vim22</span><br><span class="line">11vim</span><br><span class="line">vim</span><br></pre></td></tr></table></figure>


<p>如果您需要选择”vim”，但仅当它以”11”开头并以”22”结束时，可以使用<code>\zs</code>（开始匹配）和<code>\ze</code>（结束匹配）运算符。 执行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/11\zsvim\ze22</span><br></pre></td></tr></table></figure>


<p>Vim 仍然必须匹配整个模式”11vim22”，但是仅突出显示介于<code>\zs</code>和<code>\ze</code>之间的模式。 另一个例子:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">foobar</span><br><span class="line">foobaz</span><br></pre></td></tr></table></figure>


<p>如果需要在”foobaz”中搜索”foo”，而不是在”foobar”中搜索，请运行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/foo\zebaz</span><br></pre></td></tr></table></figure>


<h2 id="搜索范围字符"><a href="#搜索范围字符" class="headerlink" title="搜索范围字符"></a>搜索范围字符</h2><p>到目前为止，您所有的搜索字词都是文字搜索。在现实生活中，您可能必须使用通用模式来查找文本。最基本的模式是字符范围”[]”。</p>
<p>如果您需要搜索任何数字，则可能不想输入<code>/0\|1\|2\|3\|4\|5\|6\|7\|8\|9\|0</code>每一次。相反，请使用<code>/[0-9]</code>来匹配一位数字。 “0-9”表达式表示 Vim 尝试匹配的数字范围 0-9，因此，如果要查找 1 到 5 之间的数字，请使用”/[1-5]”。</p>
<p>数字不是 Vim 可以查找的唯一数据类型。您也可以执行<code>/[a-z]</code>来搜索小写字母，而<code>/[A-Z]</code>来搜索大写字母。</p>
<p>您可以将这些范围组合在一起。如果您需要搜索数字 0-9 以及从 a 到 f（十六进制）的小写字母和大写字母，可以执行<code>/[0-9a-fA-F]</code>。</p>
<p>要进行否定搜索，可以在字符范围括号内添加”^”。要搜索非数字，请运行<code>/[^0-9]</code>。 Vim 可以匹配任何字符，只要它不是数字即可。请注意，范围括号内的插入符号（<code>^</code>）与行首插入符号（例如:<code>/^hello</code>）不同。如果插入号在一对方括号之外，并且是搜索词中的第一个字符，则表示“一行中的第一个字符”。如果插入符号在一对方括号内，并且是方括号内的第一个字符，则表示否定搜索运算符。 <code>/^abc</code>匹配行中的第一个”abc”，而<code>/[^abc]</code>匹配除”a”，”b”或”c”以外的任何字符。</p>
<h2 id="搜索重复字符"><a href="#搜索重复字符" class="headerlink" title="搜索重复字符"></a>搜索重复字符</h2><p>如果需要在此文本中搜索两位数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1aa</span><br><span class="line">11a</span><br><span class="line">111</span><br></pre></td></tr></table></figure>


<p>您可以使用<code>/[0-9][0-9]</code>来匹配两位数字字符，但是该方法不可缩放。 如果您需要匹配二十个数字怎么办？ 打字 20 次[[0-9]]并不是一种有趣的体验。 这就是为什么您需要一个<code>count</code>参数。</p>
<p>您可以将<code>count</code>传递给您的搜索。 它具有以下语法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;n,m&#125;</span><br></pre></td></tr></table></figure>


<p>顺便说一句，当在 Vim 中使用它们时，这些“计数”花括号需要被转义。 count 运算符放在您要递增的单个字符之后。</p>
<p>这是<code>count</code>语法的四种不同变体: -<code>&#123;n&#125;</code>是完全匹配。 <code>/[0-9]\&#123;2\&#125;</code>匹配两个数字:”11”和”111”中的”11”。 -<code>&#123;n,m&#125;</code>是范围匹配。 <code>/[0-9]\&#123;2,3\&#125;</code>匹配 2 到 3 位数字:”11”和”111”。 -<code>&#123;,m&#125;</code>是符合条件的。 <code>/[0-9]\&#123;,3\&#125;</code>最多匹配 3 个数字:”1”，”11”和”111”。 -<code>&#123;n,&#125;</code>是至少匹配项。 <code>/[0-9]\&#123;2,\&#125;</code>至少匹配 2 个或多个数字:”11”和”111”。</p>
<p>计数参数<code>\&#123;0,\&#125;</code>（零或多个）和<code>\&#123;1,\&#125;</code>（一个或多个）是常见的搜索模式，Vim 为它们提供了特殊的运算符:<code>*</code>和<code>+</code>（ <code>+</code>需要被转义，而<code>*</code> 可以正常运行而无需转义）。 如果执行<code>/[0-9]*</code>，则与<code>/[0-9]\&#123;0,\&#125;</code>相同。 它搜索零个或多个数字。 它将匹配“”，”1”，”123”。 顺便说一句，它也将匹配非数字，例如”a”，因为在技术上，字母”a”中的数字为零。 在使用”*”之前，请仔细考虑。 如果执行<code>/[0-9]\+</code>，则与<code>/[0-9]\&#123;1,\&#125;</code>相同。 它搜索一个或多个数字。 它将匹配”1”和”12”。</p>
<h2 id="预定义范围"><a href="#预定义范围" class="headerlink" title="预定义范围"></a>预定义范围</h2><p>Vim 为常见字符（例如数字和字母）提供了预定义范围。 我不会在这里逐一介绍，但可以在<code>:h /character-classes</code>中找到完整列表。 这是有用的:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\d    数字[0-9]</span><br><span class="line">\D    非数字[^ 0-9]</span><br><span class="line">\s    空格字符（空格和制表符）</span><br><span class="line">\S    非空白字符（除空格和制表符外的所有字符）</span><br><span class="line">\w    文字字符[0-9A-Za-z_]</span><br><span class="line">\l    小写字母[a-z]</span><br><span class="line">\u    大写字符[A-Z]</span><br></pre></td></tr></table></figure>


<p>您可以像使用范围字符一样使用它们。 要搜索任何一位数字，可以使用<code>/\d</code>以获得更简洁的语法，而不使用<code>/[0-9]</code>。</p>
<h2 id="更多搜索示例"><a href="#更多搜索示例" class="headerlink" title="更多搜索示例"></a>更多搜索示例</h2><h3 id="在一对相似字符之间捕获文本"><a href="#在一对相似字符之间捕获文本" class="headerlink" title="在一对相似字符之间捕获文本"></a>在一对相似字符之间捕获文本</h3><p>如果要搜索由双引号引起来的短语:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;Vim is awesome!&quot;</span><br></pre></td></tr></table></figure>


<p>运行这个:</p>
<p><code>/&quot;[^&quot;]\+&quot;</code></p>
<p>让我们分解一下:</p>
<ul>
<li><code>&quot;</code> 是字面双引号。它匹配第一个双引号。</li>
<li><code>[^&quot;]</code> 表示除双引号外的任何字符，只要不是双引号，它就与任何字母数字和空格字符匹配。</li>
<li><code>\+</code>表示一个或多个。由于 Vim 的前面是<code>[^&quot;]</code>，因此 Vim 查找一个或多个不是双引号的字符。</li>
<li><code>&quot;</code> 是字面双引号。它与右双引号匹配。</li>
</ul>
<p>当看到第一个<code>“</code>时，它开始模式捕获。Vim 在一行中看到第二个双引号时，它匹配第二个<code>&quot;</code>模式并停止模式捕获。同时，两个“”之间的所有非“”字符都被<code>[^&quot;]\+</code> 模式捕获，在这种情况下，短语”Vim is awesome!”。由一对类似的定界符包围的词组:要捕获由单引号引起来的词组，可以使用<code>/&#39;[^&#39;]\+&#39;</code>。</p>
<h3 id="捕获电话号码"><a href="#捕获电话号码" class="headerlink" title="捕获电话号码"></a>捕获电话号码</h3><p>如果要匹配以连字符(<code>-</code>)分隔的美国电话号码，例如<code>123-456-7890</code>，则可以使用:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/\v\d\&#123;3\&#125;-\d\&#123;3\&#125;-\d\&#123;4\&#125;</span><br></pre></td></tr></table></figure>


<p>美国电话号码由一组三位数字组成，其后是另外三位数字，最后是四位数字。 让我们分解一下:</p>
<ul>
<li><code>\d\&#123;3\&#125;</code>与精确重复三次的数字匹配</li>
<li><code>-</code>是字面的连字符</li>
</ul>
<p>此模式还可用于捕获任何重复的数字，例如 IP 地址和邮政编码。</p>
<p>这涵盖了本章的搜索部分。 现在开始替代。</p>
<h2 id="基本替代"><a href="#基本替代" class="headerlink" title="基本替代"></a>基本替代</h2><p>Vim 的替代命令是一个有用的命令，用于快速查找和替换任何模式。 替换语法为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:s/old-pattern/new-pattern/</span><br></pre></td></tr></table></figure>


<p>让我们从一个基本用法开始。 如果您有以下文字:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim is good</span><br></pre></td></tr></table></figure>


<p>让我们用”awesome”代替”good”，因为 Vim 很棒。 运行<code>:s/good/awesome/.</code>您应该看到:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim is awesome</span><br></pre></td></tr></table></figure>


<h2 id="重复最后一次替换"><a href="#重复最后一次替换" class="headerlink" title="重复最后一次替换"></a>重复最后一次替换</h2><p>您可以使用普通命令<code>&amp;</code>或运行<code>:s</code>来重复最后一个替代命令。 如果您刚刚运行<code>:s/good/awesome/</code>，则运行<code>&amp;</code>或<code>:s</code>都会重复执行。</p>
<p>另外，在本章前面，我提到您可以使用”//“来重复先前的搜索模式。 此技巧可用于替代命令。 如果<code>/good</code>是最近完成的，并且将第一个替换模式参数留为空白，例如在<code>:s//awesome/</code>中，则与运行<code>:s/good/awesome/</code>相同。</p>
<h2 id="替代范围"><a href="#替代范围" class="headerlink" title="替代范围"></a>替代范围</h2><p>就像许多 Ex 命令一样，您可以将 range 参数传递给替代命令。 语法为:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:[range]s/old/new/</span><br></pre></td></tr></table></figure>


<p>如果您具有以下表达式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let one = 1;</span><br><span class="line">let two = 2;</span><br><span class="line">let three = 3;</span><br><span class="line">let four = 4;</span><br><span class="line">let five = 5;</span><br></pre></td></tr></table></figure>


<p>要将第三行到第五行中的”let”替换为”const”，您可以执行以下操作:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:3,5s/let/const/</span><br></pre></td></tr></table></figure>


<p>替代命令的范围语法与搜索（<code>&#123;n,m&#125;</code>）中的计数语法相似，但有细微差别。 这是通过范围的一些变化:</p>
<ul>
<li><code>:,3/let/const/</code> - 如果逗号前没有给出任何内容，则表示当前行。 从当前行替换为第 3 行。</li>
<li><code>:1,s/let/const/</code> - 如果逗号后没有给出任何内容，则它也代表当前行。 从第 1 行替换为当前行。</li>
<li><code>:3s/let/const/</code> - 如果仅给出一个值作为范围（不带逗号），则仅在该行进行替换。</li>
</ul>
<p>在 Vim 中，<code>%</code>通常表示整个文件。 如果运行<code>:%s/let/const/</code>，它将在所有行上进行替换。</p>
<h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p>接下来的几节将介绍基本的正则表达式。 强大的模式知识对于掌握替代命令至关重要。</p>
<p>如果您具有以下表达式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let one = 1;</span><br><span class="line">let two = 2;</span><br><span class="line">let three = 3;</span><br><span class="line">let four = 4;</span><br><span class="line">let five = 5;</span><br></pre></td></tr></table></figure>


<p>要在数字周围添加一对双引号:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:%s/\d/&quot;\0&quot;/</span><br></pre></td></tr></table></figure>


<p>结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let one = &quot;1&quot;;</span><br><span class="line">let two = &quot;2&quot;;</span><br><span class="line">let three = &quot;3&quot;;</span><br><span class="line">let four = &quot;4&quot;;</span><br><span class="line">let five = &quot;5&quot;;</span><br></pre></td></tr></table></figure>


<p>让我们分解一下命令:</p>
<ul>
<li><code>:%s</code> 定位整个文件以执行替换。</li>
<li><code>\d</code> 是 Vim 的数字预定义范围(<code>[0-9]</code>)。</li>
<li><code>&quot;\0&quot;</code> 双引号是文字双引号。 <code>\0</code>是一个特殊字符，代表“整个匹配模式”。 此处匹配的模式是单个数字<code>\d</code>。 在第一行，”\0”的值为”1”。 在第二行，值为”2”。 在第三行，值为”3”，依此类推。</li>
</ul>
<p>另外，<code>&amp;</code>也代表<code>\0</code>之类的“整个匹配模式”。 <code>:s/\d/&quot;&amp;&quot;/</code>也可以。</p>
<p>让我们考虑另一个例子。 给出以下表达式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">one let = &quot;1&quot;;</span><br><span class="line">two let = &quot;2&quot;;</span><br><span class="line">three let = &quot;3&quot;;</span><br><span class="line">four let = &quot;4&quot;;</span><br><span class="line">five let = &quot;5&quot;;</span><br></pre></td></tr></table></figure>


<p>您需要用变量名交换所有的”let”。 为此，请运行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:%s/\(\w\+\) \(\w\+\)/\2 \1/</span><br></pre></td></tr></table></figure>


<p>上面的命令包含太多的反斜杠，很难阅读。 使用<code>\v</code>运算符更方便:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:%s/\v(\w+) (\w+)/\2 \1/</span><br></pre></td></tr></table></figure>


<p>结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let one = &quot;1&quot;;</span><br><span class="line">let two = &quot;2&quot;;</span><br><span class="line">let three = &quot;3&quot;;</span><br><span class="line">let four = &quot;4&quot;;</span><br><span class="line">let five = &quot;5&quot;;</span><br></pre></td></tr></table></figure>


<p>太好了！ 让我们分解该命令:</p>
<ul>
<li><code>:%s</code> 定位文件中的所有行</li>
<li><code>(\w+) (\w+)</code>对模式进行分组。<code>\w</code>是 Vim 预定义的单词字符范围(<code>[0-9A-Za-z_]</code>)之一。 包围在其中的<code>（）</code>捕获一个单词字符匹配。 请注意两个分组之间的空间。 <code>(\w+) (\w+)</code> 分为两组。 在第一行上，第一组捕获“one”，第二组捕获“two”。</li>
<li><code>\2 \1</code> 以相反的顺序返回捕获的组。 <code>\2</code>包含捕获的字符串”let”，而<code>\1</code>包含字符串”one”。 使<code>\2 \1</code>返回字符串”let one”。</li>
</ul>
<p>回想一下<code>\0</code>代表整个匹配的模式。 您可以使用<code>( )</code>将匹配的字符串分成较小的组。 每个组都由<code>\1</code>, <code>\2</code>, <code>\3</code>等表示。</p>
<p>让我们再举一个例子来巩固这一匹配组的概念。 如果您有以下数字:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">123</span><br><span class="line">456</span><br><span class="line">789</span><br></pre></td></tr></table></figure>


<p>要颠倒顺序，请运行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:%s/\v(\d)(\d)(\d)/\3\2\1/</span><br></pre></td></tr></table></figure>


<p>结果是:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">321</span><br><span class="line">654</span><br><span class="line">987</span><br></pre></td></tr></table></figure>


<p>每个<code>(\d)</code>匹配并分组每个数字。 在第一行上，第一个<code>(\d)</code>的值为”1”，第二个<code>(\d)</code>的值为”2”，第三个<code>(\d)</code>的值为”3”。 它们存储在变量<code>\1</code>，<code>\2</code>和<code>\3</code>中。 在替换的后半部分，新模式<code>\3\2\1</code>在第一行上产生”321”值。</p>
<p>如果您运行了它，则:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:%s/\v(\d\d)(\d)/\2\1/</span><br></pre></td></tr></table></figure>


<p>您将获得不同的结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">312</span><br><span class="line">645</span><br><span class="line">978</span><br></pre></td></tr></table></figure>


<p>这是因为您现在只有两个组。 被<code>(\d\d)</code>捕获的第一组存储在<code>\1</code>内，其值为”12”。 由<code>(\d)</code>捕获的第二组存储在<code>\2</code>内部，其值为”3”。 然后，<code>\2\1</code>返回”312”。</p>
<h2 id="替代标志"><a href="#替代标志" class="headerlink" title="替代标志"></a>替代标志</h2><p>如果您有以下句子:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chocolate pancake, strawberry pancake, blueberry pancake</span><br></pre></td></tr></table></figure>


<p>要将所有 pancakes 替换为 donut，您不能只运行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:s/pancake/donut</span><br></pre></td></tr></table></figure>


<p>上面的命令将仅替换第一个匹配项，从而为您提供:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chocolate donut, strawberry pancake, blueberry pancake</span><br></pre></td></tr></table></figure>


<p>有两种解决方法。 首先，您可以运行两次替代命令。 其次，您可以向其传递全局(<code>g</code>)标志来替换一行中的所有匹配项。</p>
<p>让我们谈谈全局标志。 运行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:s/pancake/donut/g</span><br></pre></td></tr></table></figure>


<p>Vim 迅速执行命令，将所有煎饼替换为甜甜圈。 全局命令是替代命令接受的几个标志之一。 您在替代命令的末尾传递标志。 这是有用的标志的列表:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;    重用上一个替代命令中的标志。 必须作为第一个标志传递。</span><br><span class="line">g    替换行中的所有匹配项。</span><br><span class="line">c    要求替代确认。</span><br><span class="line">e    防止替换失败时显示错误消息。</span><br><span class="line">i    执行不区分大小写的替换</span><br><span class="line">I    执行区分大小写的替换</span><br></pre></td></tr></table></figure>


<p>我上面没有列出更多标志。 要了解所有标志，请查看<code>:h s_flags</code>。</p>
<p>顺便说一句，重复替换命令（<code>&amp;</code>和<code>:s</code>）不保留标志。 运行<code>&amp;</code>只会重复<code>:s/pancake/donut/</code>而没有<code>g</code>。 要使用所有标志快速重复最后一个替代命令，请运行<code>:&amp;&amp;</code>。</p>
<h2 id="更改定界符"><a href="#更改定界符" class="headerlink" title="更改定界符"></a>更改定界符</h2><p>如果您需要用长路径替换 URL:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://mysite.com/a/b/c/d/e</span><br></pre></td></tr></table></figure>


<p>要用单词”hello”代替它，请运行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:s/https:\/\/mysite.com\/a\/b\/c\/d\/e/hello/</span><br></pre></td></tr></table></figure>


<p>但是，很难说出哪些正斜杠（<code>/</code>）是替换模式的一部分，哪些是分隔符。 您可以使用任何单字节字符（除字母，数字或<code>“</code>，<code>|</code>和<code>\</code>之外的字符）来更改定界符。让我们将它们替换为<code>+</code>。上面的替换命令可以重写为 :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:s+https:\/\/mysite.com\/a\/b\/c\/d\/e+hello+</span><br></pre></td></tr></table></figure>


<p>现在，更容易看到分隔符在哪里。</p>
<h2 id="特殊替换"><a href="#特殊替换" class="headerlink" title="特殊替换"></a>特殊替换</h2><p>您还可以修改要替换的文本的大小写。 给出以下表达式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let one = &quot;1&quot;;</span><br><span class="line">let two = &quot;2&quot;;</span><br><span class="line">let three = &quot;3&quot;;</span><br><span class="line">let four = &quot;4&quot;;</span><br><span class="line">let five = &quot;5&quot;;</span><br></pre></td></tr></table></figure>


<p>要大写变量“one”，“two”，“three”等，请运行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%s/\v(\w+) (\w+)/\1 \U\2/</span><br></pre></td></tr></table></figure>


<p>你会得到:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let ONE = &quot;1&quot;;</span><br><span class="line">let TWO = &quot;2&quot;;</span><br><span class="line">let THREE = &quot;3&quot;;</span><br><span class="line">let FOUR = &quot;4&quot;;</span><br><span class="line">let FIVE = &quot;5&quot;;</span><br></pre></td></tr></table></figure>


<p>这是该命令的细分:</p>
<ul>
<li><code>(\w+) (\w+)</code>捕获前两个匹配的组，例如”let”和”one”。</li>
<li><code>\1</code>返回第一个组的值”let”</li>
<li><code>\U\2</code>大写(<code>\U</code>)第二组(<code>\2</code>)。</li>
</ul>
<p>该命令的窍门是表达式<code>\U\2</code>。<code>\U</code>指示以下字符大写。</p>
<p>让我们再举一个例子。 假设您正在编写 Vim 书籍，并且需要将一行中每个单词的首字母大写。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim is the greatest text editor in the whole galaxy</span><br></pre></td></tr></table></figure>


<p>您可以运行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:s/\&lt;./\u&amp;/g</span><br></pre></td></tr></table></figure>


<p>结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vim Is The Greatest Text Editor In The Whole Galaxy</span><br></pre></td></tr></table></figure>


<p>细目如下:</p>
<ul>
<li><code>:s</code> 替换当前行</li>
<li><code>\&lt;.</code> 由两部分组成:<code>\&lt;</code>匹配单词的开头和<code>.</code>匹配任何字符。 “&lt;”运算符使以下字符成为单词的第一个字符。 由于<code>.</code>是下一个字符，因此它将匹配任何单词的第一个字符。</li>
<li><code>\u&amp;</code> 将后续符号<code>&amp;</code>大写。 回想一下，<code>&amp;</code>（或<code>\0</code>）代表整个比赛。 它与拒绝单词的第一个字符匹配。</li>
<li><code>g</code>全局标志。 没有它，此命令将仅替换第一个匹配项。 您需要替换此行上的每个匹配项。</li>
</ul>
<p>要了解替换的特殊替换符号（如<code>\u</code>和<code>\U</code>）的更多信息，请查看<code>:h sub-replace-special</code>。</p>
<h2 id="替代模式"><a href="#替代模式" class="headerlink" title="替代模式"></a>替代模式</h2><p>有时您需要同时匹配多个模式。 如果您有以下问候:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello vim</span><br><span class="line">hola vim</span><br><span class="line">salve vim</span><br><span class="line">bonjour vim</span><br></pre></td></tr></table></figure>


<p>您仅需在包含单词”hello”或”hola”的行上用”friend”代替”vim”。 执行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:%s/\v(hello|hola) vim)/\1 friend/g</span><br></pre></td></tr></table></figure>


<p>结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello friend</span><br><span class="line">hola friend</span><br><span class="line">salve vim</span><br><span class="line">bonjour vim</span><br></pre></td></tr></table></figure>


<p>这是细分:</p>
<ul>
<li><code>%s</code> 在文件的每一行上运行替代命令。</li>
<li><code>(hello|hola)</code> 匹配*”hello”或”hola”并将其视为一个组。</li>
<li><code>vim</code> 是字面意思”vim”。</li>
<li><code>\1</code> 是第一个匹配组，它是文本”hello”或”hola”。</li>
<li><code>friend</code> 是字面的“朋友”。</li>
</ul>
<h2 id="跨多个文件替换"><a href="#跨多个文件替换" class="headerlink" title="跨多个文件替换"></a>跨多个文件替换</h2><p>最后，让我们学习如何在多个文件中替换短语。对于本节，假设您有两个文件: <code>food.txt</code> 和 <code>animal.txt</code>.</p>
<p><code>food.txt</code>内:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">corn dog</span><br><span class="line">hot dog</span><br><span class="line">chili dog</span><br></pre></td></tr></table></figure>


<p><code>animal.txt</code>内:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">large dog</span><br><span class="line">medium dog</span><br><span class="line">small dog</span><br></pre></td></tr></table></figure>


<p>假设您的目录结构如下所示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── food.txt</span><br><span class="line">├── animal.txt</span><br></pre></td></tr></table></figure>


<p>首先，在<code>:args</code>内同时捕获”food.txt”和”animal.txt”。回顾前面的章节，<code>:args</code>可用于创建文件名列表。在 Vim 内部有几种方法可以做到这一点:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:args *.txt                  捕获当前位置的所有txt文件</span><br><span class="line">:args food.txt animal.txt    仅捕获索引和服务器js文件</span><br><span class="line">:args **/*.txt               捕获每个txt文件</span><br><span class="line">:args **                     捕获一切</span><br></pre></td></tr></table></figure>


<p>您也可以在 Vim 外部运行上述命令，将文件作为 Vim 的_ arguments _传递（因此称为”args”命令）。 从终端运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim food.txt animal.txt</span><br></pre></td></tr></table></figure>


<p>当 Vim 启动时，您将在<code>:args</code>中找到<code>food.txt</code>和<code>animal.txt</code>。</p>
<p>无论哪种方式，当您运行<code>:args</code>时，您都应该看到:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[food.txt] animal.txt</span><br></pre></td></tr></table></figure>


<p>要转到列表中的下一个或上一个参数，请输入<code>:next</code>或<code>:previous</code>。 现在所有相关文件都存储在参数列表中，您可以使用<code>:argdo</code>命令执行多文件替换。 执行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:argdo %s/dog/chicken/</span><br></pre></td></tr></table></figure>


<p>这将对<code>:args</code>列表中的所有文件进行替换。 最后，使用以下命令保存更改的文件:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:argdo update</span><br></pre></td></tr></table></figure>


<p><code>:args</code>和<code>:argdo</code>是在多个文件之间应用命令行命令的有用工具。 与其他命令一起尝试！</p>
<h2 id="用宏替换多个文件"><a href="#用宏替换多个文件" class="headerlink" title="用宏替换多个文件"></a>用宏替换多个文件</h2><p>另外，您也可以跨多个带有宏的文件运行替代命令。 让我们从将相关文件放入 args 列表开始。 执行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:args animal.txt food.txt</span><br><span class="line">qq</span><br><span class="line">:%s/dog/chicken/g</span><br><span class="line">:wnext</span><br><span class="line">q</span><br><span class="line">99@q</span><br></pre></td></tr></table></figure>


<p>以下是步骤的细分:</p>
<ul>
<li><code>:args animal.txt food.txt</code> 会将相关文件列出到<code>:args</code>列表中。</li>
<li><code>qq</code> 启动”q”寄存器中的宏。</li>
<li><code>:%s/dog/chicken/g</code>在当前文件的所有行上用”chicken”替换”dog”。</li>
<li><code>:wnext</code> 写入（保存）文件，然后转到<code>args</code>列表中的下一个文件。就像同时运行<code>:w</code>和<code>:next</code>一样。</li>
<li><code>q</code> 停止宏录制。</li>
<li><code>99@q</code> 执行宏九十九次。 Vim 遇到第一个错误后，它将停止执行宏，因此 Vim 实际上不会执行该宏九十九次。</li>
</ul>
<h2 id="以聪明的方式学习搜索和替换"><a href="#以聪明的方式学习搜索和替换" class="headerlink" title="以聪明的方式学习搜索和替换"></a>以聪明的方式学习搜索和替换</h2><p>做好搜索的能力是编辑的必要技能。掌握搜索功能使您可以利用正则表达式的灵活性来搜索文件中的任何模式。花些时间学习这些。实际上，您可以自己完成本章中的搜索和替换。我曾经读过一本关于正则表达式的书，却没有真正去做，后来我几乎忘了读的所有东西。主动编码是掌握任何技能的最佳方法。</p>
<p>一种提高模式匹配技能的好方法是，每当您需要搜索模式时（例如”hello 123”），而不是查询文字搜索字词(<code>/hello 123</code>)，都可以尝试为它(<code>/\v(\l+) (\d+)</code>)。这些正则表达式概念中的许多不仅在使用 Vim 时，也适用于常规编程。</p>
<p>既然您已经了解了 Vim 中的高级搜索和替换，现在让我们学习功能最丰富的命令之一，即全局命令。</p>
<h1 id="许可和版权"><a href="#许可和版权" class="headerlink" title="许可和版权"></a>许可和版权</h1><p>这些材料全部归 ©2020 Igor Irianto 所有。</p>
<p><img src="https://licensebuttons.net/l/by-nc-sa/4.0/88x31.png#id=ldrA8&originHeight=31&originWidth=88&originalType=binary&status=done&style=none"></p>
<p>这项作品已获得<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">&lt;&lt;知识共享署名-非商业性-相同方式共享 4.0 版&gt;&gt;</a>的许可。</p>
]]></content>
      <categories>
        <category>工具篇</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>VCS在虚拟机中的安装和使用</title>
    <url>/2020/05/15/VCS%E5%9C%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="软件列表"><a href="#软件列表" class="headerlink" title="软件列表"></a>软件列表</h2><p><strong>需要自己准备</strong></p>
<ul>
<li>vmware15.05：</li>
</ul>
<p>链接：<a href="https://pan.baidu.com/s/1It1q_xRejsTHk-G8XZvuog">https://pan.baidu.com/s/1It1q_xRejsTHk-G8XZvuog</a>  提取码：ekg6</p>
<ul>
<li>centos 7：</li>
</ul>
<p>链接：<a href="https://pan.baidu.com/s/1rQ8Y-wtNBBdrzK5kO_PQYA">https://pan.baidu.com/s/1rQ8Y-wtNBBdrzK5kO_PQYA</a>  提取码：4scd</p>
<ul>
<li>Synopsys tools集合（需要自己安装）：</li>
</ul>
<p>链接：<a href="https://pan.baidu.com/s/1hfljQJgT4PsIEGgSSA37OA">https://pan.baidu.com/s/1hfljQJgT4PsIEGgSSA37OA</a>  提取码：cpy5</p>
<p><strong>安装好的EDA环境，解压可以直接使用</strong><br>解压后，使用vmware打开启动，选择“我已移动”，有问题可以联系我。<br>链接：<a href="https://pan.baidu.com/s/1enBg_oE8qw9EhU1G9M1qdQ">https://pan.baidu.com/s/1enBg_oE8qw9EhU1G9M1qdQ</a>  提取码：8bhi </p>
<ul>
<li>账户密码:2020</li>
<li>root密码:2020</li>
</ul>
<p><strong>License到2030年</strong></p>
<h2 id="Makefile文件的使用"><a href="#Makefile文件的使用" class="headerlink" title="Makefile文件的使用"></a>Makefile文件的使用</h2><p>因为VCS是使用命令行操作的，每次运行如果都挂那么多参数的话，调试起来十分不方便，于是便有了makefile，简单来说像是一个脚本，将常用的命令进行宏定义，可以简化很长的命令，在每次执行make命令的时候，都能够调用到相应的命令，在modlsim中也有相应的do文件编写，下面是使用vcs时候的一个makefile小例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.PHONY: com sim clean debug dve</span><br><span class="line"></span><br><span class="line">OUTPUT = NF</span><br><span class="line"></span><br><span class="line">VCS= vcs  -f filelist.f               \</span><br><span class="line">          -full64                     \</span><br><span class="line">          -sverilog +v2k              \</span><br><span class="line">          -debug_pp                   \</span><br><span class="line">          +vcd+vcdplus                \</span><br><span class="line">          +plusarg_save               \</span><br><span class="line">          -timescale=10ns/10ns        \</span><br><span class="line">          -o  $&#123;OUTPUT&#125;               \</span><br><span class="line">          -l compile.log             </span><br><span class="line"></span><br><span class="line">SIM = ./$&#123;OUTPUT&#125; +ntb_random_seed_automatic </span><br><span class="line"></span><br><span class="line">com:    </span><br><span class="line">	$&#123;VCS&#125; </span><br><span class="line"></span><br><span class="line">sim:   </span><br><span class="line">	$&#123;SIM&#125; &amp;</span><br><span class="line"></span><br><span class="line">dve:</span><br><span class="line">	dve -vpd inter.vpd</span><br><span class="line">	</span><br><span class="line">clean:</span><br><span class="line">	rm -rf ./csrc *.daidir *.log $&#123;OUTPUT&#125;* *.key *.h *.vpd ./DVEfiles ./stack.info.* *.vdb nocas.* simv* *.log *.tar.gz </span><br><span class="line"></span><br><span class="line">debug:	clean com </span><br></pre></td></tr></table></figure>
<p>其中filelist文件是需要编译的文件路径集合</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./router.v</span><br><span class="line">./lab_01/test.sv</span><br><span class="line">./lab_01/router_test_top.sv</span><br><span class="line"></span><br><span class="line">//如果有被include的文件，千万不要写在这里面，因为会报错重复编译</span><br></pre></td></tr></table></figure>


<h2 id="使用VCS遇到的问题"><a href="#使用VCS遇到的问题" class="headerlink" title="使用VCS遇到的问题"></a>使用VCS遇到的问题</h2><ul>
<li>文件提前声明<blockquote>
<p>在编辑filelist.f时，如果文件中已经include 某个文件，就不需要再在列表中编译了，否则就会报错</p>
</blockquote>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1618217054638-56300755-7ce5-4693-9c41-33ba9addd966.png#align=left&display=inline&height=334&id=RG3D0&margin=%5Bobject%20Object%5D&name=1fbcfa7f117cfdf4538bba6933ce477.png&originHeight=530&originWidth=853&size=52063&status=done&style=none&width=538" alt="1fbcfa7f117cfdf4538bba6933ce477.png"></p>
<ul>
<li>动态类型的函数，静态结构体无法用于非阻塞赋值的左侧<blockquote>
<p>将引用结构体的函数去掉automatic 即可</p>
</blockquote>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1618220555087-bdd85a0d-1b3c-40c1-a4fe-b0b86f646198.png#align=left&display=inline&height=156&id=g7S9r&margin=%5Bobject%20Object%5D&name=image.png&originHeight=156&originWidth=871&size=23357&status=done&style=none&width=871" alt="image.png"></p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzU1ODkwNzY1OQ==&mid=2247484040&idx=1&sn=23ad6d832513f592735e4f83fae94396&scene=19#wechat_redirect">搭建属于自己的数字IC EDA环境（一）：安装VMware15.5和centos7</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzU1ODkwNzY1OQ==&mid=2247484053&idx=1&sn=888a68d91aed7ffe0d295957b5ba20c4&scene=19#wechat_redirect">搭建属于自己的数字IC EDA环境（二）：搭建基本使用环境和工具</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzU1ODkwNzY1OQ==&mid=2247484123&idx=1&sn=9bdf844446eac83504190f41a910a5b8&scene=19#wechat_redirect">搭建属于自己的数字IC EDA环境（三）：安装EDA工具（vcs2018、verdi2018等）IC工具以及运行第1个工程</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzU1ODkwNzY1OQ==&mid=2247484150&idx=1&sn=b72091a46618058acd5ae5b5d7a6bf0a&scene=19#wechat_redirect">搭建属于自己的数字IC EDA环境（四）：EDA环境的补充说明以及解决一些小bug</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzU1ODkwNzY1OQ==&mid=2247484257&idx=1&sn=aeec6af6d728325552b52cbba20177a1&scene=19#wechat_redirect">搭建属于自己的数字IC EDA环境（五）：搭建FPGA环境（vivado Tcl脚本自动化开发），业余IC设计流程与通路</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/127335447">VCS入门教程(一)</a><br><a href="https://zhuanlan.zhihu.com/p/129034106">VCS入门教程(二)</a><br><a href="https://zhuanlan.zhihu.com/p/143164198">VCS入门教程(三)</a><br><a href="https://zhuanlan.zhihu.com/p/148111752">VCS入门教程(四)</a></p>
]]></content>
      <categories>
        <category>工具篇</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>虚拟机</tag>
        <tag>VCS</tag>
      </tags>
  </entry>
  <entry>
    <title>AGV智能搬运机器人</title>
    <url>/2020/04/11/AGV%E6%99%BA%E8%83%BD%E6%90%AC%E8%BF%90%E6%9C%BA%E5%99%A8%E4%BA%BA/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>第六届全国大学生工程训练竞赛已经过去一年多的时间了，最近两天没啥事，就把自己的整个参赛过程总结出来，也算是给自己留个念想以后能回忆回忆，这个比赛周期很长，也是这个比赛让我学会了不少东西，把自己学的理论付诸到实践中去。当时参加这个比赛的时候，我还啥项目都没有接触过，摸爬滚打慢慢学会了不少东西，总之这个比赛的综合性很强，我也和队友学会了许多其他专业的东西。虽然成绩一般般，但是我感觉这次比赛经历应该是最重要的经历之一了。<br>以下的文案部分很差劲，大部分是当时写的报告里截取的，当时报告得分着实是一般，时间也匆忙，我记得是第二天早上要上车去石家庄，头天晚上还在实验室修改报告。也是从那时开始注意提升一下自己写报告的能力，整个报告当时都是我写的，由于机械部分和程序部分不是我的专业领域因此写的很外行，凑活着看看就行了。</p>
<h2 id="比赛要求"><a href="#比赛要求" class="headerlink" title="比赛要求"></a>比赛要求</h2><p>简单来说，就是AGV小车从出发到二维码地方扫到搬运顺序的信息，然后回到原料区，将带有颜色的物料夹起来放到指定位置。具体的细则可以去官网找，或者看这老哥的<a href="http://www.cxyzjd.com/article/weixin_41534481/90759233">博客</a>。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619088385042-9e385ea2-7547-40f2-bbcf-5e788cea18db.png#clientId=uc1ff3965-433a-4&from=paste&height=711&id=ucd0a0edd&margin=%5Bobject%20Object%5D&originHeight=711&originWidth=819&originalType=url&status=done&style=none&taskId=u29c19301-7717-4695-aad1-e4b59432157&width=819"></p>
<h2 id="电路设计方案"><a href="#电路设计方案" class="headerlink" title="电路设计方案"></a>电路设计方案</h2><h3 id="检测及控制设计思路"><a href="#检测及控制设计思路" class="headerlink" title="检测及控制设计思路"></a>检测及控制设计思路</h3><p>电路采用分离式模块，其中主控板上包括显示模块、电机驱动、舵机连接口、显示部分、红外探测部分，另外还有稳压模块，舵机驱动模块单独坐一块电路板，这样做是由于舵机在夹持过程中电流较大，会对其他电路造成影响，另外这种模块分离的结构更加容易检测错误，且由于电路板上的保护措施，可以保护其他的模块，减少损失。<br>由于分离式的电路板，检测方面也很方便快捷，只要用万用表测量输入输出引脚，检测电压电流是否处于正常工作状态即可。</p>
<h3 id="器件选择及实施方案"><a href="#器件选择及实施方案" class="headerlink" title="器件选择及实施方案"></a>器件选择及实施方案</h3><p>电路上器件基本为贴片式电子元件，封装多数为0603，尽可能小的封装，可以大大的减小电路板的面积，驱动芯片为a4950、996、1117、LM2596等大功率输出器件，可以加大的减少错误的出现，同时也可以更好更稳定的输出电平信号。电路板的排布尽可能的遵循电路设计规则，将将高频信号尽量减小布线长度。</p>
<h3 id="AGV物流车循迹流程"><a href="#AGV物流车循迹流程" class="headerlink" title="AGV物流车循迹流程"></a>AGV物流车循迹流程</h3><p>首先，开启电源后，自动进行电路和各模块的初始化，方便工作，然后有红外传感器接受信号，做到无接触启动，小车斜着出去，然后找到黑线，由红外对管检测黑线并沿着黑线前行，在过程中，红外对管还起着纠偏的作用，不时地纠正前进的方向，然后走到二维码区，识别二维码上面的数字信息，然后寻迹回到物料抓取区，有摄像头识别物料抓取区的物料颜色信息，按照二维码的数字信息判别抓取的信息，并按照顺序依次抓取，并后退到物料存放区，识别物料存放区的圆环颜色，并进行放置，接着回到物料抓取区，抓取第二个物料，回到物料存放区放置，然后再循环往复，直到物料放置完成之后，直接寻迹回到起点，结束。</p>
<h3 id="AGV电控部分原理图"><a href="#AGV电控部分原理图" class="headerlink" title="AGV电控部分原理图"></a><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619088898578-086a3490-6c5c-4fe3-8ec8-d1e993005884.png#clientId=uc1ff3965-433a-4&from=drop&id=u14441329&margin=%5Bobject%20Object%5D&name=%E6%99%BA%E8%83%BD%E7%94%B5%E6%8E%A7%E7%89%A9%E6%B5%81%E8%BD%A6%E5%BE%AA%E8%BF%B9%E6%B5%81%E7%A8%8B%E5%9B%BE.png&originHeight=1122&originWidth=794&originalType=binary&size=29002&status=done&style=none&taskId=ue6c02516-ceca-4a6e-b310-a03a81c6a84" alt="智能电控物流车循迹流程图.png">AGV电控部分原理图</h3><ul>
<li>由于本系统需要直流电源供电，我们首先选取锂电池作为能源，锂电池的电量比较足，并且可以充电反复利用，在小车的调试过程中发挥很重要的作用，电源输出后，一部分输给直流电机作为电机的驱动电源，另一部分经过LM2596进行5V的稳压输出供给电路中的液晶屏等元件、LM2596是降压型电源管理单片集成电路的开关电压调节器，能够输出3A的驱动电流，同时具有很好的线性和负载调节特性。还有一部分经过AMS1117输出3.3V的稳压，其输出送给单片机，作为其供电电源。AMS1117系列稳压器有可调版与多种固定电压版，设计用于提供1A输出电流且工作压差可低至1V。在最大输出电流时，AMS1117器件的最小压差保证不超过1.3V，并随负载电流的减小而逐渐降低。</li>
<li>电机驱动采用a4950作为直流电机的驱动芯片，a4950是一款全桥式DMOS PWM电机驱动器，具有RDS保护输出、过电流保护输出（OCP）、低功耗待机模式、可调PWM电流限制、同步整流、内部欠压锁定、交叉电流等特性，选取该芯片作为电机的驱动，操作方便、稳定性好性能优良。</li>
<li>本设计采用普通直流电机，直流电机的操作简便，运作平稳，精度能有一定保证，虽然直流电机的控制不及步进电机精准，但是对于本设计来说在完全可以满足要求，通过单片机对PWM输出一样可以控制直流电机的旋转速度，实现小车的速度控制要求，由于本设计不需要跑的太快，因此不存在惯性等问题，并且直流电机不仅编程简单，而且相对于其他更加经济实惠寻迹部分采用红外对管光电传感器，红外传感器在测量系统中已经得到了广泛应用，光电对管传感器在寻迹过程中，红外发射管发射光线到路面，红外光遇到白底则被反射，接收管接收到反射光，经施密特触发器整形后输出低电平；当红外光遇到黑线时则被吸收，接收管没有接收到反射光，经施密特触发器整形后输出高电平。红外寻迹传感器使用起来较方便，而且具有价格低廉等优势。</li>
<li>本设计采用STM32F103单片机作为主控制器，STM32F系列属于中低端的32位ARM微控制器，该系列芯片是意法半导体（ST）公司出品，其内核是Cortex-M3。该单片机经常做高性能、低成本、低功耗的嵌入式应用设计，他不仅功能强大，还有很大的内存和处理能力，而且在使用方面也有很方便的固件库，因此使用起来比较便。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619088965495-3ec082f2-5f6d-495c-ac91-c818ffc7213f.png#clientId=uc1ff3965-433a-4&from=drop&id=u4b3e5d02&margin=%5Bobject%20Object%5D&name=%E9%A9%AC%E5%BF%97%E5%BA%B7%E7%BB%84%E5%8E%9F%E7%90%86%E5%9B%BE.png&originHeight=793&originWidth=1123&originalType=binary&size=28980&status=done&style=none&taskId=uc6fb44a6-2eb7-4977-96c1-769bf9ea109" alt="马志康组原理图.png"></p>
<h3 id="AGV电控部分PCB"><a href="#AGV电控部分PCB" class="headerlink" title="AGV电控部分PCB"></a>AGV电控部分PCB</h3><ul>
<li>正面</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619091067382-9a1863d1-3c64-44a2-b56a-a90d145731ea.png#clientId=uc1ff3965-433a-4&from=drop&height=342&id=u73df2840&margin=%5Bobject%20Object%5D&name=123.png&originHeight=531&originWidth=910&originalType=binary&size=77608&status=done&style=none&taskId=ud0898389-f57a-47dd-b893-b4d4dfcfc86&width=586.7604370117188" alt="123.png"></p>
<ul>
<li>反面</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619091080112-716a2335-7811-438c-ba4c-6ddd56b5c7da.png#clientId=uc1ff3965-433a-4&from=drop&height=344&id=ue0f04090&margin=%5Bobject%20Object%5D&name=321.png&originHeight=526&originWidth=908&originalType=binary&size=71377&status=done&style=none&taskId=u74c8773f-e1e8-4cd1-bce2-c614af659de&width=593.7569580078125" alt="321.png"></p>
<h3 id="电路设计方案创新特色说明"><a href="#电路设计方案创新特色说明" class="headerlink" title="电路设计方案创新特色说明"></a>电路设计方案创新特色说明</h3><p>元件排布，采用高频就近、散热元件就远的原则， 电路排布尽量规则，对称美观，创新在于元件分离式电路板，将大功率的舵机驱动单独开板，这样可以防止电路中的电流进行干扰和电流的倒灌，电路板布线也是，根据电流的大小来看。</p>
<h4 id="电源模块设计"><a href="#电源模块设计" class="headerlink" title="电源模块设计"></a>电源模块设计</h4><p>由于本系统需要直流电源供电，我们首先选取串联12V锂电池作为能源，锂电池重量轻、电量充足，并且可以充电反复利用，在小车的调试过程中发挥很重要的作用，电源输出后，一部分直接输入12V直流电机作为电机的驱动电源，另一部分经过LM2596进行5V的降压输出供给电路中的液晶屏、红外模块等元件。LM2596是降压型电源管理单片集成电路的开关电压调节器，能够输出3A的驱动电流，同时具有很好的线性和负载调节特性。还有一部分经AMS1117输出3.3V的稳压，其输出送给单片机，作为其供电电源。AMS1117系列稳压器有可调版与多种固定电压版，设计用于提供1A输出电流且工作压差可低至1V。在最大输出电流时，AMS1117器件的最小压差保证不超过1.3V，并随负载电流的减小而逐渐降低。</p>
<h4 id="电机驱动模块设计"><a href="#电机驱动模块设计" class="headerlink" title="电机驱动模块设计"></a>电机驱动模块设计</h4><p>电机驱动采用a4950作为直流电机的驱动芯片，a4950是一款全桥式DMOS PWM电机驱动器，具有RDS保护输出、过电流保护输出（OCP）、低功耗待机模式、可调PWM电流限制、同步整流、内部欠压锁定、交叉电流等特性，相比于ULN2003、L298N等传统驱动芯片，a4590具有体积小、内阻小、发热量少、外围电路简单、稳定性好的优良性能。</p>
<h3 id="电路部分总结和体会"><a href="#电路部分总结和体会" class="headerlink" title="电路部分总结和体会"></a>电路部分总结和体会</h3><p>电路设计是整个小车的硬件核心部分，只有电路板的元件能够各司其职，传输信息能够正确，就能出色的完成物料搬运任务，即时电路出现故障，也要能够方便快捷的找出错误所在，方便检修人员能够即时修改错误，因此电路的设计，应该包含多个检测点，方便进行检修，在这次电路的设计中，我学到了许多东西，不仅是电路的设计，还有人性化的学习，不紧要能够正常工作，还要好检修。</p>
<h2 id="结构设计方案"><a href="#结构设计方案" class="headerlink" title="结构设计方案"></a>结构设计方案</h2><h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><p>依照竞赛命题和规则，小车的基本功能结构是路径扫描，颜色识别，二维码识别。<br>具体的小车结构设计：</p>
<ol>
<li>为了使小车全方位移动，在小车底盘上装有4个万向轮，垂直错开分布。</li>
<li>为了使小车沿指定路线行走，在小车下地盘上装有8个红外对管扫描黑线。</li>
<li>为了使小车计数和放置稳定，小车在底盘有增加了三个红外对管。</li>
<li>为了平稳的抓取物体，将机械爪采用三自由度平行四边形原理。</li>
</ol>
<h3 id="行走路线方式"><a href="#行走路线方式" class="headerlink" title="行走路线方式"></a>行走路线方式</h3><ul>
<li>小车底盘采用四个万向轮，以十字形错开分布，另外下底盘有10个红外寻迹模块，来规划路线和取放物体，其中8个红外用来寻迹和定位小车中心，另外两个一个用来寻迹一个用来放置物体，机械爪采用杠杆式原理，运用平行四边形使得机械爪一直保持在一个方向，采用舵机驱动。</li>
<li>软件方面采用红外触发中断来调整小车的姿态，用openmv来进行颜色识别，openmv通过io口和单片机通信。</li>
<li>程序运行时，小车向前行走，当2号和4号红外检测到黑线时小车停止行走，同时1、2、3、4号红外通过中断来调整小车使1、2、3、4号红外都检测到黑线，当1、2、3、4号红外都检测到黑线时，小车开始向右行走，行走过程中，通过1、2、3、4号红外来使得小车沿黑线行走，并且通过9号红外来计数，openmv在次过程中扫描物体颜色，等小车到达二维码前方时小车停止，并通过8个红外使得小车在十字中心，扫描完二维码后，小车左行中间那个物体前，通过二维码扫描的数据和物体摆放的顺序计算出该抓那个物体（机械爪可以抓得到三个物体），通过调节机械爪来抓取物体（通过之前测好角度），抓取物体后收回机械爪，根据物体放置的颜色顺序，先通过左右移动走到放置位的前方，然后向前移动，通过5、6、7、8号红外使得小车沿经线行走，当10号红外第三次检测到黑线时，小车停止，放置物体（通过之前测好角度），放置完物体后，机械爪收回，然后小车按原路返回，反复来回三次，小车回到原位。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619090965282-ef273c67-1709-47fd-a501-a997b5b0fed1.png#clientId=uc1ff3965-433a-4&from=paste&height=179&id=udc5e15fd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=179&originWidth=250&originalType=binary&size=2480&status=done&style=none&taskId=u161fd836-4edb-4b4d-9d6b-c51dfe2119e&width=250" alt="image.png"></p>
<h3 id="机械臂设计方案"><a href="#机械臂设计方案" class="headerlink" title="机械臂设计方案"></a>机械臂设计方案</h3><p>为了使机械臂灵活的运动，并且每次抓取都在水平方向上，我们采用平行四边形原理，用4个舵机，两个舵机控制机械臂的上下移动，一个舵机控制机械臂的转动，一个舵机控制机械爪的张合。机械臂转动通过舵机提供扭矩，4个牛眼轴承防止机械臂偏移。</p>
<h3 id="结构设计创新特色说明"><a href="#结构设计创新特色说明" class="headerlink" title="结构设计创新特色说明"></a>结构设计创新特色说明</h3><p>（1）小车通过四个万向轮来方便使小车全方位移动。<br>（2）小车通过下底盘11个红外对管使得小车沿指定路线行走，计数并且平稳的放置物体。<br>（3）机械臂采用有机玻璃板制三自由度平行四边形结构。该结构具有简单、稳定、重量轻、便于维护的优点，广泛用于带有手臂功能的机械设备上。手臂动作的动力由MG996R型数字舵机提供<br>（4）采用异性电路板更好分配空间，单独的电源模块可以通过更大的电流。<br>（5）采用两个openmv摄像头精准的识别物体颜色和扫描二维码。<br>（6）为了满足车体投影小于A4纸的要求并尽可能增大车体可利用空间，该车车身采用双层正方体结构，车身材料为有机玻璃板，加工工艺为激光切割。上层放置主控电路板，电机驱动板及机械臂云台，下层安装红外对管，红外驱动板。上下两层通过螺柱链接，上层承受大部分受力。<br>（7）通过一系列计算，我们最终选择了直径58mm全向轮加30减速比的直流电机，该电机长73mm、直径33mm、空载转速366rpm、额定扭矩1kg•cm，足以提供整车的动力供应。相比于麦克纳姆轮，全向轮对编程更加友好，而切损失的速度少、能提供更快的速度以达到节约时间的目的。<br>（8）为适应不同形状、大小的物体，该车手抓部分采用二指结构，通过杠杆及齿轮传动完成加持动作，加持范围15mm-180mm，弧形手抓可适应方形、圆形、圆柱、三棱柱等多种形状的物体。动力由MG996R型数字舵机提供,承重大于90g。双层手抓在满足重量轻、抓放稳定的同时更易进行线切割加工，符合更新、维护要求。<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12924220/1619090296021-0319b683-02ca-433a-99d8-6e074d15577d.jpeg#from=paste&height=409&id=ETnPt&margin=%5Bobject%20Object%5D&originHeight=3024&originWidth=4032&originalType=url&status=done&style=none&width=544.7604370117188"></p>
<h3 id="结构部分总结和体会"><a href="#结构部分总结和体会" class="headerlink" title="结构部分总结和体会"></a>结构部分总结和体会</h3><p>这次设计和竞赛活动，是对我们以往所学专业课程的总结应用，加深了我们对产品设计制造、工艺和成本分析以及工程管理等方面的认识，检验了我们的设计能力、动手能力和实践能力，也锻炼了我们分析问题、解决问题的能力，培养了我们的创新能力与团队协作能力。</p>
<h3 id="AGV车身装配图"><a href="#AGV车身装配图" class="headerlink" title="AGV车身装配图"></a>AGV车身装配图</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619090782898-78f9d666-e4dc-474d-b886-d8afb47f8fda.png#clientId=uc1ff3965-433a-4&from=drop&id=u38c3124d&margin=%5Bobject%20Object%5D&name=%E8%A3%85%E9%85%8D%E5%9B%BE.png&originHeight=801&originWidth=1130&originalType=binary&size=21915&status=done&style=none&taskId=u6282ca5a-91a5-44dd-aaa0-8dbd2c54604" alt="装配图.png"></p>
<h3 id="AGV车身爆炸图"><a href="#AGV车身爆炸图" class="headerlink" title="AGV车身爆炸图"></a>AGV车身爆炸图</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619090787035-a2908a19-635a-4efb-a6e3-254de5ee9c6a.png#clientId=uc1ff3965-433a-4&from=drop&id=u57a2472e&margin=%5Bobject%20Object%5D&name=%E7%88%86%E7%82%B8%E5%9B%BE.png&originHeight=818&originWidth=1380&originalType=binary&size=134567&status=done&style=none&taskId=ue0bbaa94-5b33-4af9-a257-8a9af6c5eef" alt="爆炸图.png"></p>
<h2 id="作品图片"><a href="#作品图片" class="headerlink" title="作品图片"></a>作品图片</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12924220/1619089759283-2b5861ca-b500-47d7-a1ea-4f6161c375ec.jpeg#clientId=uc1ff3965-433a-4&from=drop&height=301&id=u80d6bee7&margin=%5Bobject%20Object%5D&name=1111.jpg&originHeight=3024&originWidth=4032&originalType=binary&size=2214841&status=done&style=none&taskId=u6df342d8-89f6-4afb-90ef-f2a3277bf7b&width=400.7430725097656" alt="1111.jpg"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12924220/1619089894120-8067888b-7277-4e7b-8e75-0d6336ded0f2.jpeg#clientId=uc1ff3965-433a-4&from=drop&height=550&id=u56332f58&margin=%5Bobject%20Object%5D&name=%E9%A1%B6%E9%A1%B6%E9%A1%B6.jpg&originHeight=4608&originWidth=3456&originalType=binary&size=4157999&status=done&style=none&taskId=u6ccbd990-5893-41f9-892c-9d5e9126960&width=412.7465515136719" alt="顶顶顶.jpg"><br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12924220/1619088792577-81119ca8-dd0d-492d-9b40-39554a752b88.jpeg#clientId=uc1ff3965-433a-4&from=drop&height=260&id=u3f80ce75&margin=%5Bobject%20Object%5D&name=%E6%94%BE%E5%A4%A7.jpg&originHeight=2268&originWidth=4032&originalType=binary&size=3877353&status=done&style=none&taskId=u1b9aadbf-5596-4c0c-b937-5f82629aa4a&width=462.76043701171875" alt="放大.jpg"><br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12924220/1619088792825-b8002eec-e78c-4ffe-bc72-3e6f408974e6.jpeg#clientId=uc1ff3965-433a-4&from=drop&height=258&id=ud4ef11b8&margin=%5Bobject%20Object%5D&name=%E4%BD%86%E6%98%AF.jpg&originHeight=2268&originWidth=4032&originalType=binary&size=3916682&status=done&style=none&taskId=u91cb8ed7-5e86-4d89-8587-cbf5bba05b8&width=458.76043701171875" alt="但是.jpg"></p>
]]></content>
      <categories>
        <category>项目篇</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>C语言</tag>
        <tag>AD</tag>
        <tag>3D打印</tag>
      </tags>
  </entry>
  <entry>
    <title>频率可调的西勒振荡器</title>
    <url>/2020/03/17/%E9%A2%91%E7%8E%87%E5%8F%AF%E8%B0%83%E7%9A%84%E8%A5%BF%E5%8B%92%E6%8C%AF%E8%8D%A1%E5%99%A8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于研究生又回到电路的方向上了，最近在搞一些模电的相关资料，突然在百度云发现了以前的一个实验，想着看看实验报告，顺便整理一下一个振荡器设计，也是一个参考，实验是大三做的应该，过了几年猛一看还有点忘了呢，也提醒了下自己，有啥东西抓紧整理，省的以后都忘了。</p>
<h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><ul>
<li><strong>实验目的及实验内容要求</strong></li>
</ul>
<p>进一步熟悉高频电子线路仿真方法。<br>理解振荡电路的工作原理，熟悉交流分析法。<br>熟悉振荡器满足振荡的三个条件，并在试验中运用。<br>了解西勒振荡器的原理和改进的优势。</p>
<ul>
<li><strong>实验设备或运行软件平台</strong></li>
</ul>
<p>硬件：PC机<br>软件：Multisim</p>
<h2 id="实验内容及过程"><a href="#实验内容及过程" class="headerlink" title="实验内容及过程"></a>实验内容及过程</h2><h3 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h3><p>西勒振荡器为并联改进型电容反馈三点式振荡电路，其采用共基极的三极管，在克拉泼电路的L两端并联一个电容得到，有效的改善了克拉泼电路的可调范围小的缺点，西勒振荡器输出特性平坦，振荡频率较高。西勒振荡器电路简单，易起振，与电容式三点式振荡器比较具有更高的稳定度、更好的振荡频率，改变C调节频率时不影响反馈系数的优点，因此西勒式振荡器更广泛的应用于在宽频段，频率可调的场合。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1618895184639-dd78fbfa-ed00-4b1e-afb9-2e1ffa8ee094.png#clientId=uf2a10ab7-e8ec-4&from=paste&height=265&id=ub75737ea&margin=%5Bobject%20Object%5D&name=image.png&originHeight=265&originWidth=584&originalType=binary&size=84277&status=done&style=none&taskId=u4a58162f-9cdb-4bc8-8974-4a1af4961a9&width=584" alt="image.png"><br>其中电路的特点是振荡频率稳定度高，调整范围大，电路的总电容是<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1618895200907-f1f618f9-53a9-4986-b5d4-72556b4072e8.png#clientId=uf2a10ab7-e8ec-4&from=paste&height=91&id=ua44e513c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=91&originWidth=297&originalType=binary&size=6145&status=done&style=none&taskId=u95ac4e95-655a-4e33-89ba-35045ed7be5&width=297" alt="image.png"><br>因此，振荡频率是<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1618895237683-3550da22-a468-460b-a3fd-e4fb0874ce00.png#clientId=uf2a10ab7-e8ec-4&from=paste&height=60&id=u0b9c058c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=60&originWidth=159&originalType=binary&size=1389&status=done&style=none&taskId=u981b8570-f72c-4f35-8773-43b7ce28eee&width=159" alt="image.png"><br>其中 C3为粗调，C4为细调，两者相互调整使电路的调频范围扩大。</p>
<h3 id="设计电路仿真系统"><a href="#设计电路仿真系统" class="headerlink" title="设计电路仿真系统"></a>设计电路仿真系统</h3><p>根据实验原理，设计西勒振荡器原理图如下图所示，在Multisim中找到相应的器件并连接起来，构成如下的电路图。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1618895269521-a263fe55-bd60-46e2-a51e-7d385bf0b6e8.png#clientId=uf2a10ab7-e8ec-4&from=paste&height=410&id=u05737568&margin=%5Bobject%20Object%5D&name=image.png&originHeight=410&originWidth=652&originalType=binary&size=74644&status=done&style=none&taskId=u07912d72-efe9-4c91-9241-32fdd07f456&width=652" alt="image.png"><br><strong>参数设置</strong></p>
<ul>
<li><strong>静态工作点设置</strong></li>
</ul>
<p>合理的选择振荡器的静态工作点，对振荡器的起振难度，工作的稳定性，波形质量的好坏又十分密切的关系。振荡器的静态工作点选择在靠近截止区的地方。根据此原则，计算参数如下<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1618895278440-31988ab4-92ab-4de2-91b8-d8de42aaea59.png#clientId=uf2a10ab7-e8ec-4&from=paste&height=542&id=u63181e35&margin=%5Bobject%20Object%5D&name=image.png&originHeight=542&originWidth=526&originalType=binary&size=72936&status=done&style=none&taskId=u47438e56-1209-4ccb-af4c-a1cb9d438d7&width=526" alt="image.png"></p>
<ul>
<li><strong>振荡回路的元件参数运算</strong></li>
</ul>
<p>回路中既有电感元件，又有电容元件，因为电感元件占少数，因此，先确定电感元件的数值，取L=10uH，再根据电感元件计算电容元件的参数值，振荡器频率为<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1618895303557-ac7bc965-ace6-4542-bbfe-8177f94ad21e.png#clientId=uf2a10ab7-e8ec-4&from=paste&height=62&id=u66ecc2d9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=62&originWidth=95&originalType=binary&size=794&status=done&style=none&taskId=uf88f4835-2bce-4120-96e0-24f0414f817&width=95" alt="image.png"><br>因为宽频带可调振荡器，可令振荡频率在5Mhz&lt;f&lt;15Mhz区间内振荡<br>由于在本电路中<img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1618895330295-04b7a5f0-6a69-4e54-b7b6-ea2947810b03.png#clientId=uf2a10ab7-e8ec-4&from=paste&height=67&id=uc9a6b899&margin=%5Bobject%20Object%5D&name=image.png&originHeight=67&originWidth=136&originalType=binary&size=1212&status=done&style=none&taskId=uee508417-2306-45b2-b4c0-f5ccf8f4b92&width=136" alt="image.png">根据公式计算得 11pF&lt;C4+C5&lt;101pF<br>因此取可变电容C4=30pF ，C5=100pF同时，在保证总电容近似等于C4+C5那么要求C2、C3&gt;&gt;C4、C5 ，因此取C2=470pF，C3=1000pF。</p>
<h3 id="实验步骤及实验数据记录"><a href="#实验步骤及实验数据记录" class="headerlink" title="实验步骤及实验数据记录"></a>实验步骤及实验数据记录</h3><p>1．按照以上电路连接，开启仿真，调节电容和基级偏置电阻R1，使示波器出现振荡正弦波形，并用频率计测量振荡频率并记录。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1618895424747-d0ccaf70-9833-4024-bf1f-b6d26bad9251.png#clientId=uf2a10ab7-e8ec-4&from=paste&height=420&id=u7e0a37f9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=420&originWidth=557&originalType=binary&size=88641&status=done&style=none&taskId=ufd0dd887-4cb7-4709-9a73-f6c8d513612&width=557" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1618895432911-01ad3f5f-2ea3-46c6-b158-4823116558e0.png#clientId=uf2a10ab7-e8ec-4&from=paste&height=301&id=ub9adbda9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=301&originWidth=438&originalType=binary&size=36544&status=done&style=none&taskId=u72fdcb57-d590-4642-b407-ebf6acccdce&width=438" alt="image.png"><br>2．调节偏置电阻R1观察稳定后波形的变化并记录。<br>R1=70kΩ<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1618895450194-2832246c-bfce-41df-966e-26753f763bf6.png#clientId=uf2a10ab7-e8ec-4&from=paste&height=231&id=u5b67a2ef&margin=%5Bobject%20Object%5D&name=image.png&originHeight=231&originWidth=306&originalType=binary&size=37534&status=done&style=none&taskId=u12ef7a2d-3bef-4c32-a77c-ed50f709820&width=306" alt="image.png"><br>R1=60kΩ<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1618895469753-138f8c0b-6f12-41fa-a6bc-cf87418bc5ce.png#clientId=uf2a10ab7-e8ec-4&from=paste&height=225&id=u131d8e8d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=225&originWidth=298&originalType=binary&size=37524&status=done&style=none&taskId=u9780c22f-9f23-4afc-bc57-05824fc65ef&width=298" alt="image.png"><br>R1=50kΩ<br> <img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1618895474908-28733152-f5de-44d9-8827-0dd3e1821a4f.png#clientId=uf2a10ab7-e8ec-4&from=paste&height=231&id=u3e967b2b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=231&originWidth=306&originalType=binary&size=44402&status=done&style=none&taskId=udd98f3d0-fce6-44ad-88ea-1ce198395d1&width=306" alt="image.png"><br>R1=30kΩ<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1618895480084-f5ab7223-8ebb-4096-b2e3-6bfe93617128.png#clientId=uf2a10ab7-e8ec-4&from=paste&height=230&id=u2528ac2c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=230&originWidth=305&originalType=binary&size=45479&status=done&style=none&taskId=uc0dea257-7fcb-4ae0-acf9-1232fa0610a&width=305" alt="image.png"><br>3．调节电容C4、C5，并记录当频率在5Mhz~15Mhz时C4+C5的数值</p>
<table>
<thead>
<tr>
<th>频率（Mhz）</th>
<th>5</th>
<th>7</th>
<th>9</th>
<th>11</th>
<th>13</th>
<th>15</th>
</tr>
</thead>
<tbody><tr>
<td>C4（pF）</td>
<td>83</td>
<td>36</td>
<td>14</td>
<td>10</td>
<td>10</td>
<td>8</td>
</tr>
<tr>
<td>C5（pF）</td>
<td>26.4</td>
<td>14.7</td>
<td>14.7</td>
<td>8.4</td>
<td>3.9</td>
<td>2.4</td>
</tr>
<tr>
<td>电容值（pF）</td>
<td>109.4</td>
<td>50..7</td>
<td>28.7</td>
<td>18.4</td>
<td>13.9</td>
<td>10.4</td>
</tr>
<tr>
<td>理论值（pF）</td>
<td>101.3</td>
<td>51.7</td>
<td>31.3</td>
<td>20.9</td>
<td>15.0</td>
<td>11.3</td>
</tr>
</tbody></table>
<h3 id="实验数据分析"><a href="#实验数据分析" class="headerlink" title="实验数据分析"></a>实验数据分析</h3><p>在第一步实验中，通过调节基级偏置电阻，电路很容易自激形成高频正弦波，前提是必须满足振荡器震荡的三个条件，即起振条件，平衡条件和稳定条件，这点在设计电路的时候就已经完成，再者就是要满足三点式电路三个极两两之间的关系，对于此电路来说基级集电极中间的应为感性电抗，因此C4和C5的电容和不宜过小，否则，将使得基级和发射极之间的电抗成容性。<br>第二步实验中通过调整R1可以使振荡起来的正弦波幅值发生改变，R1增大，电压幅值减小，其原因是，增大R1基级的偏置电压减小， 从而导致之路负载特性曲线变缓，在交流因此放大后的的幅值也减小。<br>第三步实验，是使振荡器生成不同频率的正弦波，并和理论的值相比较，通过调节C4、C5的数值可以改变谐振网络的电抗阻值，但是始终要保持感性电抗，因此，根据公式<img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1618895556677-70ab6961-0893-43b8-9daf-6e0fa3c4eb01.png#clientId=uf2a10ab7-e8ec-4&from=paste&height=56&id=ue89c4295&margin=%5Bobject%20Object%5D&name=image.png&originHeight=56&originWidth=130&originalType=binary&size=1124&status=done&style=none&taskId=ua258b7c3-0fd4-4a0b-9c5b-eb76206e077&width=130" alt="image.png">算得C4+C5的数值，并在实验中调节两个电容，经过比较，在较低频率下实验值和理论值相差无几，但是随着频率的增高，实验数值小于理论值，分析其原因是因为，在分析交流电路时，因为C2和C3数值较大，在计算总电容时，将其忽略，但是在高频时，由于C2、C3的电抗减小，因此变得不可忽略，将C2、C3的数值考虑进去才使得C4、C5的数值小于理论值，再有就是由于三极管极间电容的影响，但是因为影响较小，因此在此忽略不加考虑。</p>
<h2 id="总结与体会"><a href="#总结与体会" class="headerlink" title="总结与体会"></a>总结与体会</h2><h3 id="实验任务完成情况"><a href="#实验任务完成情况" class="headerlink" title="实验任务完成情况"></a>实验任务完成情况</h3><p>本次实验是自主设计实验，通过以前对三点式振荡电路、克拉泼振荡电路的了解，从而衍生出西勒振荡电路，西勒振荡电路就是在克拉泼的基础上增加一个电容，在本次试验中我将其换成了可变电容以便于探究电容的作用和影响。<br>本次实验可以说是十分成功，西勒振荡器的模型通过查阅资料所得，其中的各元件参数值均是由手算得出，详细的计算过程如上面的原理所示，设计完电路后，在进行仿真的时候稍加修改就成功，虽然有的时候不能直接起振，但是在修改基级偏置之后由于给了个硬激励电路很容易既可以完美的起振，且仿真出的正弦波形基本可以接受，由于谐振不好导致的正弦波顶部的部分失真可以忽略，在探究电容的作用时，理论计算出来的数值，基本和实验得出的数值相似，误差在可接受的范围内，在分析误差时也通过查阅资料将误差产生的原因一五一十的解释清楚。</p>
<h3 id="实验体会、收获、建议回答问题"><a href="#实验体会、收获、建议回答问题" class="headerlink" title="实验体会、收获、建议回答问题"></a>实验体会、收获、建议回答问题</h3><p>本次试验获益匪浅，通过设计LC西勒振荡电路，将所学习的高频知识和以前的低频基础联系起来，并在此基础上，实际出的电容反馈振荡器加深我对振荡电路的理解，在实验过程中，也熟悉三点式振荡电路，克拉泼振荡电路的工作原理，并在实验中将三种振荡电路进行比较。让我对三种电路的优缺点有了更深的认识，三点式振荡电路是基础，后面两者都是在此基础上进行的修改，克拉泼电路的振荡频率较高，但是频率的覆盖率较小，而西勒振荡器在保持高频震荡的基础上，拓宽了频带宽度，使频率的覆盖率增大，且震荡的幅值比较稳定。<br>在本次实验中也让我体验到理论计算的重要性，通过理论的设计然后在进行实验的验证，知行合一，从而得到更加充分的学习和认识，实验中不起振，振幅小的等问题通过理论分析然后在对电路元件的参数值进行修改，来达到一个上下对称尽可能不失真的正弦振荡波形。</p>
]]></content>
      <categories>
        <category>项目篇</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>Multisim</tag>
      </tags>
  </entry>
  <entry>
    <title>二级有源负载差分放大器设计</title>
    <url>/2020/03/15/%E4%BA%8C%E7%BA%A7%E6%9C%89%E6%BA%90%E8%B4%9F%E8%BD%BD%E5%B7%AE%E5%88%86%E6%94%BE%E5%A4%A7%E5%99%A8%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个设计是我在大二的时候学完低频课程的大作业，现在整理出来，顺便也复习一下当时学的内容，温故而知新。</p>
<h2 id="设计指标及设计要求"><a href="#设计指标及设计要求" class="headerlink" title="设计指标及设计要求"></a>设计指标及设计要求</h2><p>设计一个电压增益约500倍的放大器，至少由两级基本放大器(输入级可以是差分放大器)构成根据自已的熟悉程度，可以用晶体管基本放大器设计，也可以用场效应管放大器</p>
<h2 id="系统方案设计分析"><a href="#系统方案设计分析" class="headerlink" title="系统方案设计分析"></a>系统方案设计分析</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619081124668-57b5562a-9769-4c30-836c-1a3a269c42d5.png#clientId=u9a31b5c8-25ac-4&from=paste&height=278&id=ua47a3e4c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=278&originWidth=448&originalType=binary&size=22843&status=done&style=none&taskId=u2b032260-828e-47e2-ac72-4ceb597096d&width=448" alt="image.png"></p>
<h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><h3 id="输入级"><a href="#输入级" class="headerlink" title="输入级"></a>输入级</h3><p>选取差分放大器做<strong>输入级</strong>是因为差分放大器<strong>静态电流小，功耗极低</strong>，另外，差分放大器<strong>稳定性极高</strong>，<strong>温飘现象不明显</strong>，而采取<strong>有源负载是为了提高放大倍数</strong>（因为有源负载一般有恒流源构成，恒流源的<strong>直流等效电阻很小，交流等效电阻却很大</strong>）</p>
<h3 id="缓冲级"><a href="#缓冲级" class="headerlink" title="缓冲级"></a>缓冲级</h3><p>中间的缓冲级采用<strong>共集电路</strong>，共集电极放大电路<strong>输入电阻高</strong>、<strong>输出电阻低</strong>，只放大电流电压增益约为1，在电路中可以提高带负载的能力。</p>
<h3 id="放大级"><a href="#放大级" class="headerlink" title="放大级"></a>放大级</h3><p>一级放大器就是输入的差分放大器，二级放大器采用共发射极电路，有较大的<strong>电流和电压增益</strong>。</p>
<h3 id="耦合信号"><a href="#耦合信号" class="headerlink" title="耦合信号"></a>耦合信号</h3><p>放大器各级间均采用<strong>耦合电容</strong>既能传递交流信号，又能隔离直流信号，防止放大器前后级静态工作点相互影响，让放大器偏置工作处于最佳状态</p>
<h2 id="设计流程"><a href="#设计流程" class="headerlink" title="设计流程"></a>设计流程</h2><p>电路图如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619081440785-a2d98769-eb0a-484d-b76b-3adc55d6602a.png#clientId=u9a31b5c8-25ac-4&from=paste&height=230&id=u7a710172&margin=%5Bobject%20Object%5D&name=image.png&originHeight=230&originWidth=457&originalType=binary&size=21181&status=done&style=none&taskId=u88489a55-4654-4038-a801-ed6225708c2&width=457" alt="image.png"></p>
<ul>
<li>首先确定电路静态工作点，将<strong>信号源短路</strong>，<strong>电容断开</strong>。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619081421904-f79adce1-4f98-42f0-859b-03451e79faec.png#clientId=u9a31b5c8-25ac-4&from=paste&height=554&id=ufe02af15&margin=%5Bobject%20Object%5D&name=image.png&originHeight=554&originWidth=480&originalType=binary&size=123734&status=done&style=none&taskId=ud7fd34e1-8641-49ee-9404-881b6d9aaba&width=480" alt="image.png"></p>
<ul>
<li>然后计算增益，将<strong>信号源接入</strong>，直流<strong>电源接地</strong>，<strong>电容短路</strong>。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619081484082-f9ee0265-054a-4dc2-aa0f-15bd416283b3.png#clientId=u9a31b5c8-25ac-4&from=paste&height=304&id=u9ca2f91e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=304&originWidth=523&originalType=binary&size=64182&status=done&style=none&taskId=ue3831d41-2727-42b9-97a5-d72f899998f&width=523" alt="image.png"></p>
<ul>
<li>电路原理总图</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619081588481-5df41721-85ac-4bb5-8f77-5cffe1ad7a27.png#clientId=u9a31b5c8-25ac-4&from=paste&height=313&id=ud33eef47&margin=%5Bobject%20Object%5D&name=image.png&originHeight=313&originWidth=590&originalType=binary&size=60781&status=done&style=none&taskId=ub6f0aa01-9b8e-41bf-8819-ed66067dd24&width=590" alt="image.png"></p>
<ul>
<li>主要元器件介绍</li>
</ul>
<p>电阻10kΩ                             电阻100kΩ<br>电阻100Ω                             电阻7.5kΩ<br>电阻3.1kΩ                             电阻22.5kΩ<br>电阻80kΩ<br>三极管2N2222（9013） VA=10V<br>三极管2SA733（9012）<br>电解电容10μF<br>电源VCC 10V                      电源VEE -10V<br>信号源</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>本次电路设计比较成功，让我明白了放大电路中偏置电路的重要性，同时，更好的了解到反馈网络能很好地消除失真现象，但同时会使增益下降明显。通过本次实验，我更好的学会了使用差分放大器，对模电的实践理解大大加深。</p>
]]></content>
      <categories>
        <category>项目篇</category>
      </categories>
      <tags>
        <tag>模拟</tag>
        <tag>Multisim</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Python的晨午检自动填报脚本</title>
    <url>/2020/02/15/%E5%9F%BA%E4%BA%8EPython%E7%9A%84%E6%99%A8%E5%8D%88%E4%BF%AD%E8%87%AA%E5%8A%A8%E5%A1%AB%E6%8A%A5%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于疫情爆发，学校要求每次填报定位信息，但是鉴于我也不怎么出去，外加上记忆力比较差，所以只能想个办法替我去完成这些重复性操作了。脚本是原来有的<a href="https://github.com/Apache553/xidian-ncov-report">西电大佬</a>写好的，在这里我只是借用稍加修改了一下（仅适用于广州研究院，因为定位在广州）。脚本可以从<a href="https://github.com/Mr-southerly/xidian-ncov-report">我的GitHub仓库</a>中下载。</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><ul>
<li><p>首先微信的晨午检虽然在微信中，但其实只是一个网页，上面的填的信息都可以认为是一些个表单，只需要一个脚本能够自动把表单存下来，然后代替人去将表单数据提交个后台服务器就行了，唯一难搞的就是需要的定位信息。</p>
</li>
<li><p>那么表单我们怎么生成呢，直接生成有点不利于观看，因此用代码交互填进去。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># -*- coding: UTF-<span class="number">8</span> -*-</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">def AskInteractive(description, options, delta=<span class="number">0</span>):</span><br><span class="line">    print(description)</span><br><span class="line">    <span class="keyword">for</span> index in range(len(options)):</span><br><span class="line">        print(str(index)+<span class="string">&quot;. &quot;</span>+options[index])</span><br><span class="line">    <span class="keyword">while</span> True:</span><br><span class="line">        ret = <span class="keyword">input</span>(<span class="string">&quot;你的选择: &quot;</span>)</span><br><span class="line">        try:</span><br><span class="line">            val = <span class="keyword">int</span>(ret)</span><br><span class="line">            <span class="keyword">if</span> val &gt;= <span class="number">0</span> <span class="keyword">and</span> val &lt; len(options):</span><br><span class="line">                <span class="keyword">return</span> val+delta</span><br><span class="line">        except:</span><br><span class="line">            pass</span><br><span class="line">    </span><br><span class="line">def AskText(description):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">input</span>(description)</span><br><span class="line">    </span><br><span class="line">def AskBoolean(description):</span><br><span class="line">    <span class="keyword">while</span> True:</span><br><span class="line">        ret = <span class="keyword">input</span>(description+&#x27;&lt;Y/N&gt; &#x27;)<span class="variable">.upper</span>()</span><br><span class="line">        <span class="keyword">if</span> ret == <span class="string">&quot;Y&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        elif ret == <span class="string">&quot;N&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Configuration</span><br><span class="line"></span><br><span class="line"># 具体填报项目</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;#####\n温馨提示： 不外出、不聚集、不吃野味， 戴口罩、勤洗手、咳嗽有礼，开窗通风，发热就诊\n#####\n\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">data = &#123;&#125;</span><br><span class="line"></span><br><span class="line"># 统一认证账号密码</span><br><span class="line">data<span class="variable">.update</span>(&#123;<span class="string">&quot;_u&quot;</span>:AskText(<span class="string">&quot;统一认证账号: &quot;</span>)&#125;)</span><br><span class="line">data<span class="variable">.update</span>(&#123;<span class="string">&quot;_p&quot;</span>:AskText(<span class="string">&quot;统一认证密码: &quot;</span>)&#125;)</span><br><span class="line"></span><br><span class="line"># 今日是否在校</span><br><span class="line">data<span class="variable">.update</span>(&#123;<span class="string">&quot;sfzx&quot;</span>:AskBoolean(<span class="string">&quot;今日是否在校:&quot;</span>)&#125;)</span><br><span class="line"></span><br><span class="line"># 定位</span><br><span class="line">data<span class="variable">.update</span>(&#123;<span class="string">&quot;geo_api_info&quot;</span>: &#x27;&#123;<span class="string">&quot;type&quot;</span>:<span class="string">&quot;complete&quot;</span>,<span class="string">&quot;position&quot;</span>:&#123;<span class="string">&quot;Q&quot;</span>:<span class="number">23</span><span class="variable">.285822043836</span>,<span class="string">&quot;R&quot;</span>:<span class="number">113</span><span class="variable">.606406850871</span>,<span class="string">&quot;lng&quot;</span>:<span class="number">113</span><span class="variable">.6064068</span>,<span class="string">&quot;lat&quot;</span>:<span class="number">23</span><span class="variable">.2858220</span>&#125;,<span class="string">&quot;location_type&quot;</span>:<span class="string">&quot;html5&quot;</span>,<span class="string">&quot;message&quot;</span>:<span class="string">&quot;Get ipLocation failed.Get geolocation success.Convert Success.Get address success.&quot;</span>,<span class="string">&quot;accuracy&quot;</span>:<span class="number">65</span>,<span class="string">&quot;isConverted&quot;</span>:true,<span class="string">&quot;status&quot;</span>:<span class="number">1</span>,<span class="string">&quot;addressComponent&quot;</span>:&#123;<span class="string">&quot;citycode&quot;</span>:<span class="string">&quot;020&quot;</span>,<span class="string">&quot;adcode&quot;</span>:<span class="string">&quot;440112&quot;</span>,<span class="string">&quot;businessAreas&quot;</span>:[],<span class="string">&quot;neighborhoodType&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="string">&quot;neighborhood&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="string">&quot;building&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="string">&quot;buildingType&quot;</span>:<span class="string">&quot;&quot;</span>,<span class="string">&quot;street&quot;</span>:<span class="string">&quot;九龙大道&quot;</span>,<span class="string">&quot;streetNumber&quot;</span>:<span class="string">&quot;108号&quot;</span>,<span class="string">&quot;country&quot;</span>:<span class="string">&quot;中国&quot;</span>,<span class="string">&quot;province&quot;</span>:<span class="string">&quot;广东省&quot;</span>,<span class="string">&quot;city&quot;</span>:<span class="string">&quot;广州市&quot;</span>,<span class="string">&quot;district&quot;</span>:<span class="string">&quot;黄埔区&quot;</span>,<span class="string">&quot;township&quot;</span>:<span class="string">&quot;九龙镇&quot;</span>&#125;,<span class="string">&quot;formattedAddress&quot;</span>:<span class="string">&quot;广东省广州市黄埔区九龙镇御禾田公寓广州绿地城&quot;</span>,<span class="string">&quot;roads&quot;</span>:[],<span class="string">&quot;crosses&quot;</span>:[],<span class="string">&quot;pois&quot;</span>:[],<span class="string">&quot;info&quot;</span>:<span class="string">&quot;SUCCESS&quot;</span>&#125;&#x27;&#125;)</span><br><span class="line"></span><br><span class="line">geo = json<span class="variable">.loads</span>(data[<span class="string">&quot;geo_api_info&quot;</span>])</span><br><span class="line">data<span class="variable">.update</span>(&#123;<span class="string">&quot;address&quot;</span>:geo[<span class="string">&quot;formattedAddress&quot;</span>],<span class="string">&quot;area&quot;</span>:geo[<span class="string">&quot;addressComponent&quot;</span>][<span class="string">&quot;province&quot;</span>] + &#x27; &#x27; + geo[<span class="string">&quot;addressComponent&quot;</span>][<span class="string">&quot;city&quot;</span>] + &#x27; &#x27; + geo[<span class="string">&quot;addressComponent&quot;</span>][<span class="string">&quot;district&quot;</span>],<span class="string">&quot;province&quot;</span>:geo[<span class="string">&quot;addressComponent&quot;</span>][<span class="string">&quot;province&quot;</span>],<span class="string">&quot;city&quot;</span>:geo[<span class="string">&quot;addressComponent&quot;</span>][<span class="string">&quot;city&quot;</span>]&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> data[<span class="string">&quot;city&quot;</span>]<span class="variable">.strip</span>() == <span class="string">&quot;&quot;</span> <span class="keyword">and</span> data[<span class="string">&quot;province&quot;</span>] in [<span class="string">&quot;北京市&quot;</span>,<span class="string">&quot;上海市&quot;</span>,<span class="string">&quot;重庆市&quot;</span>,<span class="string">&quot;天津市&quot;</span>]:</span><br><span class="line">    data[<span class="string">&quot;city&quot;</span>] = data[<span class="string">&quot;province&quot;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"># 体温范围</span><br><span class="line">data<span class="variable">.update</span>(&#123;<span class="string">&quot;tw&quot;</span>:AskInteractive(<span class="string">&quot;今日体温范围(℃): &quot;</span>,[<span class="string">&quot;(-inf, 36]&quot;</span>,<span class="string">&quot;(36, 36.5]&quot;</span>,<span class="string">&quot;(36.5, 36.9]&quot;</span>,<span class="string">&quot;(36.9, 37.3]&quot;</span>,<span class="string">&quot;(37.3, 38]&quot;</span>,<span class="string">&quot;(38, 38.5]&quot;</span>,<span class="string">&quot;(38.5, 39]&quot;</span>,<span class="string">&quot;(39, 40]&quot;</span>,<span class="string">&quot;(40, +inf)&quot;</span>],<span class="number">0</span>)&#125;)</span><br><span class="line"></span><br><span class="line"># 今日是否出现发热、乏力、干咳、呼吸困难等症状</span><br><span class="line">data<span class="variable">.update</span>(&#123;<span class="string">&quot;sfyzz&quot;</span>:AskBoolean(<span class="string">&quot;今日是否出现发热、乏力、干咳、呼吸困难等症状: &quot;</span>)&#125;)</span><br><span class="line"></span><br><span class="line"># 是否处于隔离期</span><br><span class="line">data<span class="variable">.update</span>(&#123;<span class="string">&quot;sfcyglq&quot;</span>:AskBoolean(<span class="string">&quot;是否处于隔离期: &quot;</span>)&#125;)</span><br><span class="line"></span><br><span class="line"># 一码通颜色</span><br><span class="line">data<span class="variable">.update</span>(&#123;<span class="string">&quot;ymtys&quot;</span>:AskInteractive(<span class="string">&quot;西安一码通颜色: &quot;</span>,[<span class="string">&quot;绿&quot;</span>,<span class="string">&quot;黄&quot;</span>,<span class="string">&quot;红&quot;</span>])&#125;)</span><br><span class="line"></span><br><span class="line"># 其他信息</span><br><span class="line">data<span class="variable">.update</span>(&#123;<span class="string">&quot;qtqk&quot;</span>:AskText(<span class="string">&quot;其他信息: &quot;</span>)&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&quot;data_3chk.json&quot;</span>,<span class="string">&quot;w&quot;</span>) as fd:</span><br><span class="line">    json<span class="variable">.dump</span>(data,fd)</span><br><span class="line">    print(<span class="string">&quot;保存成功&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>通过上面的配置文件，我们把每天要填写的信息都生成一个json文件，然后就是这个文件可以用我们的脚本提交上去，其中的定位信息是通过浏览器抓取的经纬度信息，手动填上去的，应该有一些api接口可以自动获取，但本人学艺不精，暂时还不会。</p>
</li>
<li><p>然后生成完的数据我们就剩下一个提交了，提交也只是python模拟浏览器进行的动作。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line"># -*- coding: UTF-<span class="number">8</span> -*-</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">time</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> os<span class="variable">.path</span><span class="variable">.exists</span>(<span class="string">&quot;NOSUBMIT&quot;</span>):</span><br><span class="line">    exit()</span><br><span class="line">  </span><br><span class="line">data = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&quot;data_3chk.json&quot;</span>,<span class="string">&quot;r&quot;</span>) as fd:</span><br><span class="line">    data=json<span class="variable">.load</span>(fd)</span><br><span class="line">    </span><br><span class="line">conn = requests<span class="variable">.Session</span>()</span><br><span class="line"></span><br><span class="line"># Login</span><br><span class="line">result = conn<span class="variable">.post</span>(&#x27;https:<span class="comment">//xxcapp.xidian.edu.cn/uc/wap/login/check&#x27;,data=&#123;&#x27;username&#x27;:data[&#x27;_u&#x27;],&#x27;password&#x27;:data[&#x27;_p&#x27;]&#125;)</span></span><br><span class="line"><span class="keyword">if</span> result<span class="variable">.status_code</span> != <span class="number">200</span>:</span><br><span class="line">    print(&#x27;认证大失败&#x27;)</span><br><span class="line">    exit()</span><br><span class="line"></span><br><span class="line"># Submit</span><br><span class="line">del data[&#x27;_u&#x27;]</span><br><span class="line">del data[&#x27;_p&#x27;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result = conn<span class="variable">.post</span>(&#x27;https:<span class="comment">//xxcapp.xidian.edu.cn/xisuncov/wap/open-report/save&#x27;,data=data)</span></span><br><span class="line">print(result<span class="variable">.text</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">time</span><span class="variable">.sleep</span>(<span class="number">5</span>)  <span class="comment">//</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="使用前须知"><a href="#使用前须知" class="headerlink" title="使用前须知"></a>使用前须知</h2><p>为了脚本的更好体验，本程序有两种使用方法，由于程序仅仅具备一键提交的功能，因此在使用时需要配合电脑操作系统的定时任务功能才能实现完全自动化填写（电脑或服务器白天时段必须保证开机）。</p>
<ol>
<li>如拥有云服务器、树莓派、自建服务器（其实用腾讯的云函数理论上也以）等长期保持开机状态的linux设备的兄弟，自然不用我多说，Linux的crontab 定时跑脚本就行了。</li>
<li>在工位或使用自己电脑等windows系统的朋友，因为我的电脑设置的每天早上八点到晚上十一点自动开关机（这个百度好多教程，自动开机需要改bios，自动关机只需要定时执行shutdown命令即可），因此也不用担心漏报。当然懒得搞得话也可以每天手动开关机。</li>
<li>由于原来脚本中的定位api我没看懂，因此改成手动定位了，所以这个脚本可以在任何地方运行，都可以填报，例如家里一直开机的树莓派、阿里腾讯华为甚至国外搬瓦工等服务器。</li>
</ol>
<h2 id="使用方法（windows）"><a href="#使用方法（windows）" class="headerlink" title="使用方法（windows）"></a>使用方法（windows）</h2><h3 id="安装Python环境"><a href="#安装Python环境" class="headerlink" title="安装Python环境"></a>安装Python环境</h3><ul>
<li>打开官网<a href="https://www.python.org/">https://www.python.org/</a>  下载最新版的python即可，建议直接默认安装，在安装的最后一步 勾选 <code>Add Python to PATH</code>  否则的话就要自己百度添加环境变量</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1622780036760-59a74079-b97e-400d-82c3-907dd71dd0db.png#align=left&display=inline&height=284&margin=%5Bobject%20Object%5D&originHeight=737&originWidth=1257&status=done&style=none&width=485"></p>
<h3 id="安装request库"><a href="#安装request库" class="headerlink" title="安装request库"></a>安装request库</h3><ul>
<li>操作：win+R 输入cmd</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1622780037131-be2eea0b-5845-47eb-9d0b-843efbdd033c.png#align=left&display=inline&height=198&margin=%5Bobject%20Object%5D&originHeight=198&originWidth=397&status=done&style=none&width=397"></p>
<ul>
<li>在黑框程序里面输入 pip install requests （因为我已经安装过，所以显示下图）</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1622780037616-d9424312-2095-439c-948c-3d405a2835a7.png#align=left&display=inline&height=204&margin=%5Bobject%20Object%5D&originHeight=480&originWidth=960&status=done&style=none&width=407"></p>
<h3 id="生成表单"><a href="#生成表单" class="headerlink" title="生成表单"></a>生成表单</h3><ul>
<li>先打开表单配置文件，然后点击运行</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1622780038141-4483eb09-e1c3-4a69-be31-701f341213e4.png#align=left&display=inline&height=144&margin=%5Bobject%20Object%5D&originHeight=297&originWidth=1164&status=done&style=none&width=563"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1622780038456-48a165d5-5f08-4be6-84d9-5a9d433527cd.png#align=left&display=inline&height=506&margin=%5Bobject%20Object%5D&originHeight=598&originWidth=591&status=done&style=none&width=500"></p>
<ul>
<li>运行成功后会出现表单填入信息，逐步填入个人信息即可（注意账号密码必须用英文状态下输入否则会失败）</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1622780038764-cd289101-a334-472e-81bf-8851cfdc63dd.png#align=left&display=inline&height=451&margin=%5Bobject%20Object%5D&originHeight=524&originWidth=572&status=done&style=none&width=492"></p>
<ul>
<li>保存成功之后文件夹中会多出一个json文件，这是浏览器需要提交的表单文件</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1622780039187-8e66b4e9-2e1b-44a8-9dcb-a4f9be64be01.png#align=left&display=inline&height=25&margin=%5Bobject%20Object%5D&originHeight=25&originWidth=207&status=done&style=none&width=207"></p>
<h3 id="脚本提交表单"><a href="#脚本提交表单" class="headerlink" title="脚本提交表单"></a>脚本提交表单</h3><ul>
<li>可以使用了，双击submit_3chk.Py,如果档时段未填报则显示，“操作成功”，否则显示“你已上报过”</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1622780039769-2efd9a9d-5ace-4155-ab9b-4bd1f3c38c13.png#align=left&display=inline&height=310&margin=%5Bobject%20Object%5D&originHeight=519&originWidth=993&status=done&style=none&width=594"><br>至此已经实现了一键填报功能，</p>
<h3 id="配置定时提交"><a href="#配置定时提交" class="headerlink" title="配置定时提交"></a>配置定时提交</h3><ul>
<li>文件夹选择电脑的一个位置放下，我是放在了桌面</li>
<li>新建文本文档</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1622780040004-ed214db4-89a8-44aa-8f52-a885c3522c0b.png#align=left&display=inline&height=37&margin=%5Bobject%20Object%5D&originHeight=37&originWidth=259&status=done&style=none&width=259"></p>
<ul>
<li>输入两行命令，（如果你放在了C盘以外的位置（例如D盘）第一条命令要换成<code>cd \d D:\XXX\XXX</code>）</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1622780040339-871d83db-487b-4005-8dd2-05f50df872ae.png#align=left&display=inline&height=108&margin=%5Bobject%20Object%5D&originHeight=108&originWidth=674&status=done&style=none&width=674"></p>
<ul>
<li>写完之后将文本文件的后缀名改成.bat   例如login.bat </li>
<li>双击此文件也可以填报</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1622780040844-eeb14c71-e872-40f3-9795-cbd16aa92ca2.png#align=left&display=inline&height=154&margin=%5Bobject%20Object%5D&originHeight=154&originWidth=564&status=done&style=none&width=564"></p>
<ul>
<li>右键点击此电脑，打开管理，创建基本定时任务</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1622780041494-bed3ac40-b8fa-47ae-87c7-5abff2e87eae.png#align=left&display=inline&height=323&margin=%5Bobject%20Object%5D&originHeight=715&originWidth=1000&status=done&style=none&width=452"></p>
<ul>
<li>输入计划任务的名称和描述——下一步选择每天——设定时间，例如早上八点——操作是启动程序——下一步选择程序或脚本 浏览找到刚才的批处理文件，例如我的——最后保存</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1622780041883-760fe3cc-fea4-4c47-b46b-2b36b24758cb.png#align=left&display=inline&height=67&margin=%5Bobject%20Object%5D&originHeight=67&originWidth=463&status=done&style=none&width=463"></p>
<ul>
<li>在任务列表中找到刚才新建的定时任务，选择触发器，新建几个不同时间的触发任务，即可实现完全自动填报</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1622780042509-21cf2af9-4ed6-4e86-8bb4-d923d1c26c83.png#align=left&display=inline&height=289&margin=%5Bobject%20Object%5D&originHeight=579&originWidth=1037&status=done&style=none&width=518"></p>
]]></content>
      <categories>
        <category>项目篇</category>
      </categories>
      <tags>
        <tag>脚本</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python快速上手</title>
    <url>/2020/02/15/python%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</url>
    <content><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>pip 下载慢</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<p>vcode 配置</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;code-runner.executorMap&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;python&quot;</span><span class="punctuation">:</span> <span class="string">&quot;set PYTHONIOENCODING=utf8 &amp;&amp; python -u&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;python.pythonPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;E:\\Program Files\\Python\\Python38\\python.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;python.linting.pylintEnabled&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;python.linting.enabled&quot;</span><span class="punctuation">:</span> <span class="keyword">true</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;[python]&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;editor.tabSize&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><p>4 个空格缩进</p>
<p>没有常量， 一般约定纯大写的就是常量</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>动态类型</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = <span class="number">123</span></span><br><span class="line">a = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(a-<span class="number">1</span>)  <span class="comment"># 报错</span></span><br></pre></td></tr></table></figure>

<p>数字</p>
<p>由于是动态类型 整数，浮点数区分起来只能靠一些函数<br>对大数字的支持比较好，不用担心溢出</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = <span class="number">123</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(a, <span class="built_in">int</span>), <span class="built_in">isinstance</span>(a, <span class="built_in">float</span>))</span><br><span class="line">a = <span class="number">123.0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(a, <span class="built_in">int</span>), <span class="built_in">isinstance</span>(a, <span class="built_in">float</span>))</span><br></pre></td></tr></table></figure>

<p>字符串</p>
<p>单双引号没区别，有个优点如下</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;I\&#x27;m ok&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;I&#x27;m ok&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>保留换行的字符串</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;&#x27;line1</span></span><br><span class="line"><span class="string">line2&#x27;&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>布尔值</p>
<p>注意是大写，运算符为 and、or 和 not</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = True</span><br><span class="line">a = False</span><br></pre></td></tr></table></figure>

<p>空值</p>
<p>None</p>
<p>运算符注意</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span>/<span class="number">3</span> <span class="comment"># 3.33333</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h2><p>元组，tuple，不可变长，使用 len(arr)获取长度，越界取值报错，无法删除使用 del 释放</p>
<p>z 支持切片操作，元组</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = ()</span><br><span class="line">b = (<span class="number">2</span>,) <span class="comment"># 为防止歧义，只有一个元素必须要加逗号，当然，只有一个元素的数组也没啥意义</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用tuple函数构建</span></span><br><span class="line"><span class="built_in">tuple</span>(<span class="built_in">list</span>)</span><br><span class="line"><span class="built_in">tuple</span>(<span class="built_in">tuple</span>)</span><br><span class="line"><span class="built_in">tuple</span>(<span class="built_in">dict</span>) <span class="comment"># 所有的key</span></span><br></pre></td></tr></table></figure>

<p>列表，list，可变长,，使用 len(arr)获取长度，可用 append，pop，pop(i)，等方法</p>
<p>越界取值报错，空 list 调用 pop 报错</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] + [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>] <span class="comment"># 组合</span></span><br><span class="line">[<span class="string">&#x27;Hi!&#x27;</span>] * <span class="number">4</span> <span class="comment"># 重复</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>字典，dict，其他语言都叫做 map,删除使用 pop(key)</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">m = &#123;<span class="string">&#x27;k1&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;k2&#x27;</span>: <span class="number">2</span>&#125;</span><br><span class="line">m[<span class="string">&#x27;k3&#x27;</span>] = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;k4&#x27;</span> <span class="keyword">in</span> m)</span><br><span class="line"><span class="built_in">print</span>(m.get(<span class="string">&#x27;k4&#x27;</span>))  <span class="comment"># None</span></span><br><span class="line"><span class="built_in">print</span>(m[<span class="string">&#x27;k4&#x27;</span>])  <span class="comment"># KeyError</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过dict方法构建</span></span><br><span class="line">m1 = <span class="built_in">dict</span>(k1=<span class="number">1</span>,k2=<span class="number">2</span>) <span class="comment"># 传入关键字</span></span><br><span class="line"><span class="built_in">print</span>(m1)</span><br><span class="line"></span><br><span class="line">m2 = <span class="built_in">dict</span>(<span class="built_in">zip</span>([<span class="string">&#x27;k1&#x27;</span>,<span class="string">&#x27;k2&#x27;</span>],[<span class="number">1</span>,<span class="number">2</span>])) <span class="comment"># 映射函数方式来构造字典</span></span><br><span class="line"><span class="built_in">print</span>(m2)</span><br><span class="line"></span><br><span class="line">m3 = <span class="built_in">dict</span>([(<span class="string">&#x27;k1&#x27;</span>, <span class="number">1</span>),(<span class="string">&#x27;k2&#x27;</span>, <span class="number">2</span>)]) <span class="comment"># 可迭代对象方式来构造字典</span></span><br><span class="line"><span class="built_in">print</span>(m3)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>集合，set</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以使用set方法构建</span></span><br><span class="line">s2 = <span class="built_in">set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">s3 = <span class="built_in">set</span>((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br></pre></td></tr></table></figure>

<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>只有一种<code>for ... in ...</code>的写法，想要获取下标可以换一种思路</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">arr = (<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> arr:</span><br><span class="line">    <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)):</span><br><span class="line">    <span class="built_in">print</span>(arr[idx])</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">enumerate</span>(arr):</span><br><span class="line">    <span class="built_in">print</span>(i, v)</span><br></pre></td></tr></table></figure>

<h2 id="列表生成"><a href="#列表生成" class="headerlink" title="列表生成"></a>列表生成</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>)))  <span class="comment"># 等价 range(10)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>, <span class="number">2</span>)))  <span class="comment"># 0 2 4 6 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表生成式</span></span><br><span class="line"><span class="built_in">print</span>([x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)])</span><br><span class="line"><span class="built_in">print</span>([x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> x &gt; <span class="number">5</span>])</span><br><span class="line"><span class="built_in">print</span>([m + n <span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">&#x27;ABC&#x27;</span> <span class="keyword">for</span> n <span class="keyword">in</span> <span class="string">&#x27;XYZ&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成器,返回一个函数，每次调用next计算出下个值，最后抛出 StopIteration 异常</span></span><br><span class="line">g = (x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(g))  <span class="comment"># 4</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(g))  <span class="comment"># 9</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>map,reduce,filter，sorted 和 es6 里面的意思差不多</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="built_in">sum</span> = reduce(<span class="keyword">lambda</span> x, y: x+y, <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>)</span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>支持的特性：必选参数，参数默认值，可变参数，关键字参数，命名关键字参数</p>
<p>注意： 默认参数值必须指向不变对象，假如是 list 的话，这个引用会被一直保持着</p>
<p>注意：不能多传，不能少传，传值顺序不能有歧义</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">f1(<span class="number">123</span>) <span class="comment"># takes 0 positional arguments but 1 was given</span></span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>(<span class="params">a, b=<span class="number">99</span>, *c</span>):</span><br><span class="line">    <span class="built_in">print</span>(a, b, c)</span><br><span class="line"></span><br><span class="line">f2(<span class="number">1</span>)             <span class="comment"># 1 99 ()</span></span><br><span class="line">f2(<span class="number">1</span>, <span class="number">2</span>)          <span class="comment"># 1 2 ()</span></span><br><span class="line"><span class="comment"># f2(1, a=2)      # got multiple values for argument &#x27;a&#x27;</span></span><br><span class="line">f2(b=<span class="number">2</span>, a=<span class="number">1</span>)      <span class="comment"># 1 2 ()</span></span><br><span class="line">f2(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>) <span class="comment"># 2 3 (4, 5, 6)</span></span><br></pre></td></tr></table></figure>

<p>强制使用关键词参数，<code>*</code>后面的参数必须通过带参数名的方式传值，不能多传，不能少传</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>(<span class="params">name, *, p1, p2</span>):</span><br><span class="line">    <span class="built_in">print</span>(name, p1, p2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># f2(&#x27;zs&#x27;, 5, 6)</span></span><br><span class="line">f2(<span class="string">&#x27;zs&#x27;</span>, p1=<span class="number">5</span>, p2=<span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<p>接收多余的关键词参数(命名关键字参数)</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>(<span class="params">name, **other</span>):</span><br><span class="line">    <span class="built_in">print</span>(other)</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#123;&#x27;age&#x27;: 18, &#x27;sex&#x27;: 0&#125;</span></span><br><span class="line">f2(name=<span class="string">&#x27;zs&#x27;</span>, age=<span class="number">18</span>, sex=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>总结：一般其他语言为了避免可变参数的歧义，定义可变参数必须为最后一个参数，但是在 python 中有了命名关键字参数后，可变参数后面还可以定义其他关键词参数</p>
<p>在 Python 中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这 5 种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>(<span class="params">name, *p1, p2, p3</span>):</span><br><span class="line">    <span class="built_in">print</span>(name, p1, p2, p3)</span><br><span class="line"></span><br><span class="line">f2(<span class="string">&#x27;zs&#x27;</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, p2=<span class="number">6</span>, p3=<span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<p>当定义一个空函数时，可以使用 pass</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p><code>__xx</code>表示私有变量,其实也不是私有，解释器会把它重命名，变成<code>_ClassName__VarName</code></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    attr = <span class="string">&#x27;haha&#x27;</span> <span class="comment"># 类变量</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.__name = name <span class="comment"># 定义成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;&quot;name&quot;: &quot;%s&quot;&#125;&#x27;</span> %(self.__name))</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialUser</span>(<span class="title class_ inherited__">User</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, weight</span>):</span><br><span class="line">        User.__init__(self, name) <span class="comment"># 调用父类构造方法</span></span><br><span class="line">        <span class="comment"># super(SpecialUser, self).__init__(name)</span></span><br><span class="line">        self.weight = weight</span><br><span class="line"></span><br><span class="line">u = User(<span class="string">&#x27;zs&#x27;</span>)</span><br><span class="line">u.<span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>(u._User__name)</span><br><span class="line"><span class="comment"># 动态添加属性</span></span><br><span class="line">u.extName = <span class="string">&#x27;xxx&#x27;</span></span><br></pre></td></tr></table></figure>

<p>两个函数<code>type()</code>,<code>isinstance()</code></p>
<p>获取类信息<code>dir()</code>,<code>hasattr()</code>,<code>setattr()</code>,<code>getattr()</code></p>
<h2 id="模块管理"><a href="#模块管理" class="headerlink" title="模块管理"></a>模块管理</h2><p>在导入模块的时候，模块会从头到尾执行一遍，然后的变量均可被导出</p>
<p>方便开发运行模块，类似于 main 方法吧，又不希望导入的时候被执行可以可以使用下面的魔法写法</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在直接运行时候成立</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>导入其他 py 文件的几种方式</p>
<p>在 python 2.7 及之前版本中默认是先“相对”后“绝对”的顺序搜索模块，之后是先搜索绝对路径如果有就停止，所以在你的文件名，包名尽量起的不要和常用库的名字一样</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tool</span><br><span class="line"><span class="comment"># 相对导入只能在模块中使用，且无法直接执行运行，需要以模块的方式去跑</span></span><br><span class="line"><span class="comment"># python -m dirname.filename</span></span><br><span class="line"><span class="keyword">import</span> .tool</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> tool</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子目录</span></span><br><span class="line"><span class="keyword">import</span> <span class="built_in">dir</span>.tool</span><br><span class="line"><span class="built_in">dir</span>.tool.say()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重命名</span></span><br><span class="line"><span class="keyword">import</span> <span class="built_in">dir</span>.tool <span class="keyword">as</span> t</span><br><span class="line">t.say()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出单个方法</span></span><br><span class="line"><span class="keyword">from</span> <span class="built_in">dir</span>.tool <span class="keyword">import</span> say,move</span><br><span class="line">say()</span><br><span class="line">move()</span><br></pre></td></tr></table></figure>

<p>实际项目中，一般都是以目录作为模块的划分，直接导入目录，然后在在目录下的<code>__init__.py</code>文件去导入本目录中的文件，然后再暴露出去。系统识别到 init 文件后会把该目录视作一个模块</p>
<p>在如下层级关系中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|-- main.py</span><br><span class="line">|-- m</span><br><span class="line">|   |-- a.py</span><br><span class="line">|   |-- b.py</span><br></pre></td></tr></table></figure>

<p>没使用<code>__init__.py</code>时候一般是这样用的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import m.a as ma</span><br><span class="line">import m.b as mb</span><br><span class="line"></span><br><span class="line">print(ma.name)</span><br><span class="line">print(mb.name)</span><br></pre></td></tr></table></figure>

<p>添加<code>__init__.py</code>后</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> m</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(m.aName)</span><br><span class="line"><span class="built_in">print</span>(m.bName)</span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> a</span><br><span class="line"><span class="keyword">import</span> b</span><br><span class="line"></span><br><span class="line">aName = a.name</span><br><span class="line">bName = b.name</span><br></pre></td></tr></table></figure>

<p>这时会报错，因为<code>python main.py</code>的搜索路径是当前路径+系统模块路径，在解析<code>__init__.py</code>时，在上述路径中搜索不到 a 和 b</p>
<p>可以通过改变搜索路径来解决这问题，但是对 IDE 可能不太好</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">sys.path.append(&#x27;m&#x27;)</span><br><span class="line"></span><br><span class="line">import a</span><br><span class="line">import b</span><br><span class="line"></span><br><span class="line">aName = a.name</span><br><span class="line">bName = b.name</span><br></pre></td></tr></table></figure>

<p>规范的做法是在模块内使用相对路径导入，执行<code>main.py</code>正常。但是由于使用了相对导入<code>__init__.py</code>就无法作为脚本直接执行了,需要到外层<code>python -m m.__init__</code>进行执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from . import a</span><br><span class="line">from . import b</span><br><span class="line"></span><br><span class="line">aName = a.name</span><br><span class="line">bName = b.name</span><br></pre></td></tr></table></figure>

<p>第三方库使用 pip 管理，<a href="https://pypi.org/">官方源</a>，下载慢建议替换成清华的源</p>
<p>pip install –upgrade pip<br>pip install requests</p>
<h2 id="使用-python3-的-typing-模块提高代码健壮性"><a href="#使用-python3-的-typing-模块提高代码健壮性" class="headerlink" title="使用 python3 的 typing 模块提高代码健壮性"></a>使用 python3 的 typing 模块提高代码健壮性</h2><p>Python 在 3.5 版本中引入了 typing 模块，实现了类型提示功能</p>
<p>这里需要注意的一点是，Python typing 本质是一种注释，可以用来帮助 IDE 进行类型检查和自动补全等操作，但是他并不会真的让执行失败。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Tuple</span>, <span class="type">Dict</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int,long,float: 整型,长整形,浮点型;</span><br><span class="line">bool,str: 布尔型，字符串类型；</span><br><span class="line">List, Tuple, Dict, Set:列表，元组，字典, 集合;</span><br><span class="line">Iterable,Iterator:可迭代类型，迭代器类型；</span><br><span class="line">Generator：生成器类型；</span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明新的类型</span></span><br><span class="line">NewType = <span class="type">List</span>[<span class="built_in">str</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义参数类型，定义返回值类型</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">conv</span>(<span class="params"><span class="built_in">list</span>: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; NewType:</span><br><span class="line">    temp: NewType = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">        temp.append(<span class="built_in">hex</span>(item))</span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(conv([<span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>]))</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.python.org/zh-cn/3/library/typing.html">类型标注支持</a></p>
<p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400">Python 教程 - 廖雪峰的官方网站</a></p>
]]></content>
      <categories>
        <category>笔记篇</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令总结</title>
    <url>/2020/01/30/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于最近搭建各种服务的时候，总是用到各种Linux设备，自己对于Linux的命令也不太熟，就想着也应该学习一下Linux常用的命令，以便以后需要的时候可以方便的查阅，因此整理了一些常用的命令。</p>
<h2 id="文件目录操作"><a href="#文件目录操作" class="headerlink" title="文件目录操作"></a>文件目录操作</h2><h3 id="ls-命令"><a href="#ls-命令" class="headerlink" title="ls 命令"></a>ls 命令</h3><p>ls 命令不仅可以查看 linux 文件夹包含的文件而且可以查看文件权限(包括目录、文件夹、文件权限)查看目录信息等等。</p>
<h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><pre><code>ls [参数] [目录名]
</code></pre>
<h4 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h4><ul>
<li><strong>-l</strong> ：列出长数据串，包含文件的属性与权限数据等</li>
<li><strong>-a</strong> ：列出全部的文件，连同隐藏文件（开头为.的文件）一起列出来（常用）</li>
<li>-d ：仅列出目录本身，而不是列出目录的文件数据</li>
<li>-h ：将文件容量以较易读的方式（GB，kB等）列出来</li>
<li>-R ：连同子目录的内容一起列出（递归列出），等于该目录下的所有文件都会显示出来<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -a -l /home      //列出 home 目录下的所有文件和目录的详细资料</span><br><span class="line">ls -al /home        //列出 home 目录下的所有文件和目录的详细资料</span><br><span class="line">ls -l d*            //列出当前目录下所有以&quot;d&quot;开头的文件目录详情内容</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h3><p>最基本的命令语句，其他的命令语句要进行操作，都是建立在使用 cd 命令上的。用于切换当前目录至dirName。</p>
<h4 id="命令格式-1"><a href="#命令格式-1" class="headerlink" title="命令格式"></a>命令格式</h4><pre><code>cd [目录名]
</code></pre>
<h4 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /              //从当前目录进入系统根目录</span><br><span class="line">cd /home/Code     //跳转到 home/Code 目录</span><br></pre></td></tr></table></figure>


<h3 id="pwd-命令"><a href="#pwd-命令" class="headerlink" title="pwd 命令"></a>pwd 命令</h3><p>查看”当前工作目录”的完整路径。</p>
<h4 id="命令格式："><a href="#命令格式：" class="headerlink" title="命令格式："></a>命令格式：</h4><pre><code>pwd [参数]
</code></pre>
<h4 id="常用参数："><a href="#常用参数：" class="headerlink" title="常用参数："></a>常用参数：</h4><ul>
<li>-P :显示实际物理路径，而非使用连接（link）路径</li>
<li>-L :当目录为连接路径时，显示连接路径<h4 id="使用示例-2"><a href="#使用示例-2" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwd           //显示当前所在路径</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="mkdir-命令"><a href="#mkdir-命令" class="headerlink" title="mkdir 命令"></a>mkdir 命令</h3><p>用来创建指定的名称的目录，要求创建目录的用户在当前目录中<strong>具有写权限</strong>，并且指定的目录名不能是当前目录中已有的目录。</p>
<h4 id="命令格式-2"><a href="#命令格式-2" class="headerlink" title="命令格式"></a>命令格式</h4><pre><code>mkdir [参数] 目录
</code></pre>
<h4 id="常用参数-1"><a href="#常用参数-1" class="headerlink" title="常用参数"></a>常用参数</h4><ul>
<li>-m, –mode=模式，设定权限&lt;模式&gt; (类似 chmod)，而不是 rwxrwxrwx 减 umask</li>
<li>-p, –parents 可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后,系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录;</li>
<li>-v, –verbose 每次创建新目录都显示信息</li>
<li>–help 显示此帮助信息并退出</li>
<li>–version 输出版本信息并退出<h4 id="使用示例-3"><a href="#使用示例-3" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir test             //创建一个空目录</span><br><span class="line">mkdir test/test1       //递归创建多个目录</span><br><span class="line">mkdir -m 777 test2     //创建权限为777的目录</span><br><span class="line">mkdir -v test4         //创建目录都显示信息</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="rm-命令"><a href="#rm-命令" class="headerlink" title="rm 命令"></a>rm 命令</h3><p>删除一个目录中的一个或多个文件或目录，如果没有使用- r选项，则rm不会删除目录。如果使用 rm 来删除文件，通常仍可以将该文件恢复原状。</p>
<h4 id="命令格式-3"><a href="#命令格式-3" class="headerlink" title="命令格式"></a>命令格式</h4><pre><code>rm [参数] 文件
</code></pre>
<h4 id="常用参数-2"><a href="#常用参数-2" class="headerlink" title="常用参数"></a>常用参数</h4><ul>
<li><strong>-f, –force 强制删除忽略不存在的文件，从不给出提示</strong>。</li>
<li>-i, –interactive 进行交互式删除</li>
<li><strong>-r, -R, –recursive 指示rm将参数中列出的全部目录和子目录均递归地删除</strong>。</li>
<li>-v, –verbose 详细显示进行的步骤</li>
<li>–help 显示此帮助信息并退出</li>
<li>–version 输出版本信息并退出<h4 id="使用示例-4"><a href="#使用示例-4" class="headerlink" title="使用示例"></a>使用示例</h4></li>
</ul>
<p>1.删除文件 test.txt,系统会提示是否删除。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm test.txt             //删除文件 test.txt,系统会提示是否删除</span><br><span class="line">rm -f test.txt          //强制删除 test.txt，系统不再提示</span><br><span class="line">rm -r test              //将 test 子目录及目录中所有档案删除</span><br></pre></td></tr></table></figure>


<h3 id="rmdir-命令"><a href="#rmdir-命令" class="headerlink" title="rmdir 命令"></a>rmdir 命令</h3><p>该命令从一个目录中删除一个或多个子目录项，<strong>删除某目录时也必须具有对父目录的写权限</strong>。</p>
<h4 id="命令格式-4"><a href="#命令格式-4" class="headerlink" title="命令格式"></a>命令格式</h4><pre><code>rmdir [参数] 目录
</code></pre>
<h4 id="常用参数-3"><a href="#常用参数-3" class="headerlink" title="常用参数"></a>常用参数</h4><ul>
<li>p 递归删除目录dirname，当子目录删除后其父目录为空时，也一同被删除。如果整个路径被删除或者由于某种原因保留部分路径，则系统在标准输出上显示相应的信息。</li>
<li>-v, –verbose 显示指令执行过程<h4 id="使用示例-5"><a href="#使用示例-5" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rmdir test1           //删除空目录 test1，非空目录无法删除</span><br><span class="line">rmdir -p test2        //当子目录被删除后使它也成为空目录的话，则顺便一并删除（test目录下仅有test2）</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="mv-命令"><a href="#mv-命令" class="headerlink" title="mv 命令"></a>mv 命令</h3><p>可以用来移动文件或者将文件改名（move (rename) files）。当第二个参数类型是文件时，mv命令完成文件重命名。当第二个参数是已存在的目录名称时，源文件或目录参数可以有多个，mv命令将各参数指定的源文件均移至目标目录中。</p>
<h4 id="命令格式-5"><a href="#命令格式-5" class="headerlink" title="命令格式"></a>命令格式</h4><pre><code>mv [参数] [源文件或目录] [目标文件或目录]
</code></pre>
<h4 id="常用参数-4"><a href="#常用参数-4" class="headerlink" title="常用参数"></a>常用参数</h4><ul>
<li>-b ：若需覆盖文件，则覆盖前先行备份</li>
<li><strong>-f ：force 强制的意思</strong>，如果目标文件已经存在，不会询问而直接覆盖</li>
<li><strong>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖</strong></li>
<li>-u ：若目标文件已经存在，且 source 比较新，才会更新(update)</li>
<li>-t ： –target-directory=DIRECTORY move all SOURCE arguments into DIRECTORY，即指定mv的目标目录，该选项适用于移动多个源文件到一个目录的情况，此时目标目录在前，源文件在后<h4 id="使用示例-6"><a href="#使用示例-6" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv test1.txt test2.txt                      //将 test1.txt 重命名为 test2.txt</span><br><span class="line">mv test1.txt test2                          //移动文件 test1.txt 到目录 test2</span><br><span class="line">mv test1.txt test2.txt test3.txt test3      //将文件 test1.txt、test2.txt、test3.txt 移动到目录 test3</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="cp-命令"><a href="#cp-命令" class="headerlink" title="cp 命令"></a>cp 命令</h3><p>将源文件复制至目标文件，或将多个源文件复制至目标目录。</p>
<h4 id="命令格式-6"><a href="#命令格式-6" class="headerlink" title="命令格式"></a>命令格式</h4><pre><code>cp [参数] 源文件 目录 或 cp [参数] -t 目录 源文件
</code></pre>
<h4 id="常用参数-5"><a href="#常用参数-5" class="headerlink" title="常用参数"></a>常用参数</h4><ul>
<li>-t –target-directory 指定目标目录</li>
<li>-i –interactive 覆盖前询问（使前面的 -n 选项失效）</li>
<li>-n –no-clobber 不要覆盖已存在的文件（使前面的 -i 选项失效）</li>
<li>-f –force 强行复制文件或目录，不论目的文件或目录是否已经存在</li>
<li>-u –update 使用这项参数之后，只会在源文件的修改时间较目的文件更新时，或是对应的目的文件并不存在，才复制文件<h4 id="使用示例-7"><a href="#使用示例-7" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp test1.txt test1                      //复制文件 test1.txt 到 test1 目录（若文件存在，会提示是否覆盖。若不存在直接完成复制）</span><br><span class="line">cp -a test1 test2                       //复制 test1 整个目录到 test2</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="touch-命令"><a href="#touch-命令" class="headerlink" title="touch 命令"></a>touch 命令</h3><p>touch命令参数可更改文档或目录的日期时间，包括存取时间和更改时间。</p>
<h4 id="命令格式-7"><a href="#命令格式-7" class="headerlink" title="命令格式"></a>命令格式</h4><pre><code>touch [参数] [文件]
</code></pre>
<h4 id="常用参数-6"><a href="#常用参数-6" class="headerlink" title="常用参数"></a>常用参数</h4><ul>
<li>-a 或–time=atime或–time=access或–time=use  只更改存取时间</li>
<li>-c 或–no-create  不建立任何文档</li>
<li>-d  使用指定的日期时间，而非现在的时间</li>
<li>-f  此参数将忽略不予处理，仅负责解决BSD版本touch指令的兼容性问题</li>
<li>-m 或–time=mtime或–time=modify  只更改变动时间</li>
<li>-r  把指定文档或目录的日期时间，统统设成和参考文档或目录的日期时间相同 -t  使用指定的日期时间，而非现在的时间<h4 id="使用示例-8"><a href="#使用示例-8" class="headerlink" title="使用示例"></a>使用示例</h4></li>
</ul>
<p>1.创建不存在的文件test.txt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch test.txt                 //创建不存在的文件test.txt</span><br><span class="line">touch -r test.txt test1.txt    //更新 test.txt 的实践和 test1.txt 时间戳相同</span><br></pre></td></tr></table></figure>


<h3 id="cat-命令"><a href="#cat-命令" class="headerlink" title="cat 命令"></a>cat 命令</h3><p>用来显示文件内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示，它常与重定向符号配合使用。</p>
<h4 id="命令格式-8"><a href="#命令格式-8" class="headerlink" title="命令格式"></a>命令格式</h4><pre><code>cat [参数] [文件]
</code></pre>
<h4 id="常用参数-7"><a href="#常用参数-7" class="headerlink" title="常用参数"></a>常用参数</h4><ul>
<li>-A, –show-all 等价于 -vET</li>
<li>-b, –number-nonblank 对非空输出行编号</li>
<li>-e 等价于 -vE</li>
<li>-E, –show-ends 在每行结束处显示 $</li>
<li>-n, –number 对输出的所有行编号,由1开始对所有输出的行数编号</li>
<li>-s, –squeeze-blank 有连续两行以上的空白行，就代换为一行的空白行</li>
<li>-t 与 -vT 等价</li>
<li>-T, –show-tabs 将跳格字符显示为 ^I</li>
<li>-u (被忽略)</li>
<li>-v, –show-nonprinting 使用 ^ 和 M- 引用，除了 LFD 和 TAB 之外<h4 id="使用示例-9"><a href="#使用示例-9" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat -n test.log  test1.log         //把 test.log 的文件内容加上行号后输入 test1.log 这个文件里</span><br><span class="line">tac  test.log                      //将 test.log 的文件内容反向显示</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="nl-命令"><a href="#nl-命令" class="headerlink" title="nl 命令"></a>nl 命令</h3><p>输出的文件内容自动的加上行号！其默认的结果与 cat -n 有点不太一样， nl 可以将行号做比较多的显示设计，包括位数与是否自动补齐 0 等等的功能。</p>
<h4 id="命令格式-9"><a href="#命令格式-9" class="headerlink" title="命令格式"></a>命令格式</h4><pre><code>nl [参数] [文件]
</code></pre>
<h4 id="常用参数-8"><a href="#常用参数-8" class="headerlink" title="常用参数"></a>常用参数</h4><ul>
<li>-b ：指定行号指定的方式，主要有两种：</li>
<li>-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)</li>
<li>-b t ：如果有空行，空的那一行不要列出行号(默认值)</li>
<li>-n ：列出行号表示的方法，主要有三种：</li>
<li>-n ln ：行号在萤幕的最左方显示</li>
<li>-n rn ：行号在自己栏位的最右方显示，且不加 0</li>
<li>-n rz ：行号在自己栏位的最右方显示，且加 0</li>
<li>-w ：行号栏位的占用的位数<h4 id="使用示例-10"><a href="#使用示例-10" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nl test.log                //用 nl 列出 test.log 的内容</span><br><span class="line">nl -b a test.log           //用 nl 列出 test.log 的内容，空本行也加上行号</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="more-命令"><a href="#more-命令" class="headerlink" title="more 命令"></a>more 命令</h3><p>more 命令和 cat 的功能一样都是查看文件里的内容，但有所不同的是more可以按页来查看文件的内容，还支持直接跳转行等功能。</p>
<h4 id="命令格式-10"><a href="#命令格式-10" class="headerlink" title="命令格式"></a>命令格式</h4><pre><code>more [-dlfpcsu ] [-num ] [+/ pattern] [+ linenum] [file ... ]
</code></pre>
<h4 id="常用参数-9"><a href="#常用参数-9" class="headerlink" title="常用参数"></a>常用参数</h4><ul>
<li><p>+n 从笫n行开始显示</p>
</li>
<li><p>-n 定义屏幕大小为n行</p>
</li>
<li><p>+/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示</p>
</li>
<li><p>-c 从顶部清屏，然后显示</p>
</li>
<li><p>-d 提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能</p>
</li>
<li><p>-l 忽略Ctrl+l（换页）字符</p>
</li>
<li><p>-p 通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似</p>
</li>
<li><p>-s 把连续的多个空行显示为一行</p>
</li>
<li><p>-u 把文件内容中的下画线去掉</p>
<h4 id="操作指令"><a href="#操作指令" class="headerlink" title="操作指令"></a>操作指令</h4></li>
<li><p>Enter：向下n行，需要定义。默认为1行</p>
</li>
<li><p>Ctrl+F：向下滚动一屏</p>
</li>
<li><p>空格键：向下滚动一屏</p>
</li>
<li><p>Ctrl+B：返回上一屏</p>
</li>
<li><p>= ：输出当前行的行号</p>
</li>
<li><p>：f ：输出文件名和当前行的行号</p>
</li>
<li><p>V ：调用vi编辑器</p>
</li>
<li><p>!命令 ：调用Shell，并执行命令</p>
</li>
<li><p>q ：退出more</p>
<h4 id="使用示例-11"><a href="#使用示例-11" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">more +3 test.log                  //显示文件 test.log 第3行起内容</span><br><span class="line">more +/day3 test.log              //从文件 test.log 查找第一个出现“day3”字符串的行，并从该处前2行开始显示输出</span><br><span class="line">more -5 test.log                  //设置每屏显示行数</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="less-命令"><a href="#less-命令" class="headerlink" title="less 命令"></a>less 命令</h3><p>less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。</p>
<h4 id="命令格式-11"><a href="#命令格式-11" class="headerlink" title="命令格式"></a>命令格式</h4><pre><code>less [参数] 文件
</code></pre>
<h4 id="常用参数-10"><a href="#常用参数-10" class="headerlink" title="常用参数"></a>常用参数</h4><ul>
<li><p>-b &lt;缓冲区大小&gt; 设置缓冲区的大小</p>
</li>
<li><p>-e 当文件显示结束后，自动离开</p>
</li>
<li><p>-f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件</p>
</li>
<li><p>-g 只标志最后搜索的关键词</p>
</li>
<li><p>-i 忽略搜索时的大小写</p>
</li>
<li><p>-m 显示类似more命令的百分比</p>
</li>
<li><p>-N 显示每行的行号</p>
</li>
<li><p>-o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来</p>
</li>
<li><p>-Q 不使用警告音</p>
</li>
<li><p>-s 显示连续空行为一行</p>
</li>
<li><p>-S 行过长时间将超出部分舍弃</p>
</li>
<li><p>-x &lt;数字&gt; 将“tab”键显示为规定的数字空格</p>
<h4 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h4></li>
<li><p>/字符串：向下搜索“字符串”的功能</p>
</li>
<li><p>?字符串：向上搜索“字符串”的功能</p>
</li>
<li><p>n：重复前一个搜索（与 / 或 ? 有关）</p>
</li>
<li><p>N：反向重复前一个搜索（与 / 或 ? 有关）</p>
</li>
<li><p>b 向后翻一页</p>
</li>
<li><p>d 向后翻半页</p>
</li>
<li><p>h 显示帮助界面</p>
</li>
<li><p>Q 退出less 命令</p>
</li>
<li><p>u 向前滚动半页</p>
</li>
<li><p>y 向前滚动一行</p>
</li>
<li><p>空格键 滚动一行</p>
</li>
<li><p>回车键 滚动一页</p>
</li>
<li><p>[pagedown]： 向下翻动一页</p>
</li>
<li><p>[pageup]： 向上翻动一页</p>
<h4 id="使用示例-12"><a href="#使用示例-12" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">less test.log              //查看文件 test.log</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="head-命令"><a href="#head-命令" class="headerlink" title="head 命令"></a>head 命令</h3><p>head 用来显示档案的开头至标准输出中，默认 head 命令打印其相应文件的开头 10 行。</p>
<h4 id="命令格式-12"><a href="#命令格式-12" class="headerlink" title="命令格式"></a>命令格式</h4><pre><code>head [参数] [文件]
</code></pre>
<h4 id="常用参数-11"><a href="#常用参数-11" class="headerlink" title="常用参数"></a>常用参数</h4><ul>
<li>-q 隐藏文件名</li>
<li>-v 显示文件名</li>
<li>-c&lt;字节&gt; 显示字节数</li>
<li>-n&lt;行数&gt; 显示的行数<h4 id="使用示例-13"><a href="#使用示例-13" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">head -n 5 test.log               //显示文件 test.log 的前 5 行</span><br><span class="line">head -c 20 test.log              //显示文件 test.log 前 20 个字节</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="tail-命令"><a href="#tail-命令" class="headerlink" title="tail 命令"></a>tail 命令</h3><p>显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。</p>
<h4 id="命令格式-13"><a href="#命令格式-13" class="headerlink" title="命令格式"></a>命令格式</h4><pre><code>tail [必要参数] [选择参数] [文件]
</code></pre>
<h4 id="常用参数-12"><a href="#常用参数-12" class="headerlink" title="常用参数"></a>常用参数</h4><ul>
<li>-f 循环读取</li>
<li>-q 不显示处理信息</li>
<li>-v 显示详细的处理信息</li>
<li>-c&lt;数目&gt; 显示的字节数</li>
<li>-n&lt;行数&gt; 显示行数</li>
<li>–pid=PID 与-f合用,表示在进程ID,PID死掉之后结束.</li>
<li>-q, –quiet, –silent 从不输出给出文件名的首部</li>
<li>-s, –sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒<h4 id="使用示例-14"><a href="#使用示例-14" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tail -n 5 test.log             //显示文件 test.log 最后 5 行内容</span><br><span class="line">tail -f test.log               //循环查看文件内容</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="文件查找"><a href="#文件查找" class="headerlink" title="文件查找"></a>文件查找</h2><h3 id="which-命令"><a href="#which-命令" class="headerlink" title="which 命令"></a>which 命令</h3><p>which指令会在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。</p>
<h4 id="命令格式-14"><a href="#命令格式-14" class="headerlink" title="命令格式"></a>命令格式</h4><pre><code>which 可执行文件名称
</code></pre>
<h4 id="常用参数-13"><a href="#常用参数-13" class="headerlink" title="常用参数"></a>常用参数</h4><ul>
<li>-n  指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名</li>
<li>-p  与-n参数相同，但此处的包括了文件的路径</li>
<li>-w  指定输出时栏位的宽度</li>
<li>-V  显示版本信息<h4 id="使用示例-15"><a href="#使用示例-15" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">which pwd               //查找文件、显示命令路径</span><br><span class="line">which which             //用 which 去找出 which</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="whereis-命令"><a href="#whereis-命令" class="headerlink" title="whereis 命令"></a>whereis 命令</h3><p>whereis命令是定位可执行文件、源代码文件、帮助文件在文件系统中的位置。</p>
<h4 id="命令格式-15"><a href="#命令格式-15" class="headerlink" title="命令格式"></a>命令格式</h4><pre><code>whereis [-bmsu] [BMS 目录名 -f ] 文件名
</code></pre>
<h4 id="常用参数-14"><a href="#常用参数-14" class="headerlink" title="常用参数"></a>常用参数</h4><ul>
<li>-b 定位可执行文件</li>
<li>-m 定位帮助文件</li>
<li>-s 定位源代码文件</li>
<li>-u 搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件</li>
<li>-B 指定搜索可执行文件的路径</li>
<li>-M 指定搜索帮助文件的路径</li>
<li>-S 指定搜索源代码文件的路径<h4 id="使用示例-16"><a href="#使用示例-16" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">whereis svn               //将和 svn 文件相关的文件都查找出来</span><br><span class="line">whereis -b svn            //只将二进制文件查找出来</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="locate-命令"><a href="#locate-命令" class="headerlink" title="locate 命令"></a>locate 命令</h3><p>可以很快速的搜寻档案系统内是否有指定的档案。</p>
<h4 id="命令格式-16"><a href="#命令格式-16" class="headerlink" title="命令格式"></a>命令格式</h4><pre><code>Locate [选择参数] [样式]
</code></pre>
<h4 id="常用参数-15"><a href="#常用参数-15" class="headerlink" title="常用参数"></a>常用参数</h4><ul>
<li>-e 将排除在寻找的范围之外。</li>
<li>-1 如果 是 1．则启动安全模式。在安全模式下，使用者不会看到权限无法看到 的档案。这会始速度减慢，因为 locate 必须至实际的档案系统中取得档案的 权限资料。</li>
<li>-f 将特定的档案系统排除在外，例如我们没有到理要把 proc 档案系统中的档案 放在资料库中。</li>
<li>-q 安静模式，不会显示任何错误讯息。</li>
<li>-n 至多显示 n个输出。</li>
<li>-r 使用正规运算式 做寻找的条件。</li>
<li>-o 指定资料库存的名称。</li>
<li>-d 指定资料库的路径<h4 id="使用示例-17"><a href="#使用示例-17" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">locate pwd                    //查找和 pwd 相关的所有文件</span><br><span class="line">locate /etc/m                 //搜索etc 目录下，所有以 m 开头的文件</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="find-命令"><a href="#find-命令" class="headerlink" title="find 命令"></a>find 命令</h3><p>主要作用是沿着文件层次结构向下遍历，匹配符合条件的文件，并执行相应的操作。</p>
<h4 id="命令格式-17"><a href="#命令格式-17" class="headerlink" title="命令格式"></a>命令格式</h4><pre><code>find [参数] [搜索路径] [表达式]
</code></pre>
<h4 id="常用参数-16"><a href="#常用参数-16" class="headerlink" title="常用参数"></a>常用参数</h4><ul>
<li>-print find 命令将匹配的文件输出到标准输出</li>
<li>-exec find 命令对匹配的文件执行该参数所给出的</li>
<li>shell 命令</li>
<li>-name 按照文件名查找文件</li>
<li>-type 查找某一类型的文件<h4 id="使用示例-18"><a href="#使用示例-18" class="headerlink" title="使用示例"></a>使用示例</h4></li>
</ul>
<p>1.打印当前目录文件目录列表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -print                              //打印当前目录文件目录列表</span><br><span class="line">find . ! -name &quot;*.txt&quot;                     //打印当前目录下所有不以.txt 结尾的文件名</span><br><span class="line">find . -type f -name &quot;*.php&quot; -perm 777     //打印当前目录下所有权限为 777 的 php 文件</span><br><span class="line">find . -name &quot;*.php&quot; -exec ls -l &#123;&#125; \;     //找到当前目录下所有 php 文件，并显示其详细信息</span><br><span class="line">find . -type f -name &quot;*.c&quot; | xargs wc -l   //查找当前目录下所有 c 代码文件，统计总行数</span><br></pre></td></tr></table></figure>


<blockquote>
<p>xargs 命令可以从标准输入接收输入，并把输入转换为一个特定的参数列表。 命令格式: command | xargs [参数] [command] xargs 命令应该紧跟在管道操作符之后，因为它以标准输入作为主要的源数据流。 常用参数</p>
<ul>
<li>-n 指定每行最大的参数数量</li>
<li>-d 指定分隔符</li>
</ul>
</blockquote>
<h2 id="文件打包上传和下载"><a href="#文件打包上传和下载" class="headerlink" title="文件打包上传和下载"></a>文件打包上传和下载</h2><h3 id="tar-命令"><a href="#tar-命令" class="headerlink" title="tar 命令"></a>tar 命令</h3><p>用来压缩和解压文件。tar本身不具有压缩功能。他是调用压缩功能实现的。</p>
<h4 id="命令格式-18"><a href="#命令格式-18" class="headerlink" title="命令格式"></a>命令格式</h4><pre><code>tar [必要参数] [选择参数] [文件]
</code></pre>
<h4 id="常用参数-17"><a href="#常用参数-17" class="headerlink" title="常用参数"></a>常用参数</h4><p>必要参数：</p>
<ul>
<li>-A 新增压缩文件到已存在的压缩</li>
<li>-B 设置区块大小</li>
<li>-c 建立新的压缩文件</li>
<li>-d 记录文件的差别</li>
<li>-r 添加文件到已经压缩的文件</li>
<li>-u 添加改变了和现有的文件到已经存在的压缩文件</li>
<li>-x 从压缩的文件中提取文件</li>
<li>-t 显示压缩文件的内容</li>
<li>-z 支持gzip解压文件</li>
<li>-j 支持bzip2解压文件</li>
<li>-Z 支持compress解压文件</li>
<li>-v 显示操作过程</li>
<li>-l 文件系统边界设置</li>
<li>-k 保留原有文件不覆盖</li>
<li>-m 保留文件不被覆盖</li>
<li>-W 确认压缩文件的正确性</li>
</ul>
<p>可选参数：</p>
<ul>
<li>-b 设置区块数目</li>
<li>-C 切换到指定目录</li>
<li>-f 指定压缩文件</li>
<li>–help 显示帮助信息</li>
<li>–version 显示版本信息<h4 id="使用示例-19"><a href="#使用示例-19" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -cvf test.tar test.log         //仅打包，不压缩！ </span><br><span class="line">tar -zcvf test.tar.gz test.log     //打包后，以 gzip 压缩 </span><br><span class="line">tar -zcvf test.tar.bz2 test.log    //打包后，以 bzip2 压缩</span><br><span class="line">tar -zxvf test.tar.gz              //将 tar 包解压缩</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="gzip-命令"><a href="#gzip-命令" class="headerlink" title="gzip 命令"></a>gzip 命令</h3><p>使用广泛的压缩程序，文件经它压缩过后，其名称后面会多出”.gz”的扩展名。</p>
<h4 id="命令格式-19"><a href="#命令格式-19" class="headerlink" title="命令格式"></a>命令格式</h4><pre><code>gzip [参数] [文件或者目录]
</code></pre>
<h4 id="常用参数-18"><a href="#常用参数-18" class="headerlink" title="常用参数"></a>常用参数</h4><ul>
<li>-a或–ascii  使用ASCII文字模式。</li>
<li>-c或–stdout或–to-stdout  把压缩后的文件输出到标准输出设备，不去更动原始文件。</li>
<li>-d或–decompress或—-uncompress  解开压缩文件。</li>
<li>-f或–force  强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接。</li>
<li>-h或–help  在线帮助。<h4 id="使用示例-20"><a href="#使用示例-20" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test6 $ gzip *            //把 test1 目录下的每个文件压缩成.gz 文件</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="文件权限设置"><a href="#文件权限设置" class="headerlink" title="文件权限设置"></a>文件权限设置</h2><h3 id="chmod-命令"><a href="#chmod-命令" class="headerlink" title="chmod 命令"></a>chmod 命令</h3><p>用于改变linux系统文件或目录的访问权限。</p>
<h4 id="命令格式-20"><a href="#命令格式-20" class="headerlink" title="命令格式"></a>命令格式</h4><pre><code>chmod [-cfvR] [--help] [--version] mode file
</code></pre>
<h4 id="常用参数-19"><a href="#常用参数-19" class="headerlink" title="常用参数"></a>常用参数</h4><p>必要参数：</p>
<ul>
<li>-c 当发生改变时，报告处理信息</li>
<li>-f 错误信息不输出</li>
<li>-R 处理指定目录以及其子目录下的所有文件</li>
<li>-v 运行时显示详细处理信息</li>
<li>选择参数：</li>
<li>–reference=&lt;目录或者文件&gt; 设置成具有指定目录或者文件具有相同的权限</li>
<li>–version 显示版本信息</li>
<li>&lt;权限范围&gt;+&lt;权限设置&gt; 使权限范围内的目录或者文件具有指定的权限</li>
<li>&lt;权限范围&gt;-&lt;权限设置&gt; 删除权限范围的目录或者文件的指定权限</li>
<li>&lt;权限范围&gt;=&lt;权限设置&gt; 设置权限范围内的目录或者文件的权限为指定的值</li>
</ul>
<p>权限范围：</p>
<ul>
<li>u ：目录或者文件的当前的用户</li>
<li>g ：目录或者文件的当前的群组</li>
<li>o ：除了目录或者文件的当前用户或群组之外的用户或者群组</li>
<li>a ：所有的用户及群组</li>
</ul>
<p>权限代号：</p>
<ul>
<li>r：读权限，用数字4表示</li>
<li>w：写权限，用数字2表示</li>
<li>x：执行权限，用数字1表示</li>
<li>-：删除权限，用数字0表示<h4 id="使用示例-21"><a href="#使用示例-21" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod a+x test.log           //增加文件所有用户组可执行权限</span><br><span class="line">chmod a-x test.log           //删除所有用户的可执行权限</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="chgrp-命令"><a href="#chgrp-命令" class="headerlink" title="chgrp 命令"></a>chgrp 命令</h3><p>可采用群组名称或群组识别码的方式改变文件或目录的所属群组。</p>
<h4 id="命令格式-21"><a href="#命令格式-21" class="headerlink" title="命令格式"></a>命令格式</h4><pre><code>chgrp [参数] [组] [文件]
</code></pre>
<h4 id="常用参数-20"><a href="#常用参数-20" class="headerlink" title="常用参数"></a>常用参数</h4><p>必要参数:</p>
<ul>
<li>-c 当发生改变时输出调试信息</li>
<li>-f 不显示错误信息</li>
<li>-R 处理指定目录以及其子目录下的所有文件</li>
<li>-v 运行时显示详细的处理信息</li>
<li>–dereference 作用于符号链接的指向，而不是符号链接本身</li>
<li>–no-dereference 作用于符号链接本身</li>
</ul>
<p>选择参数:</p>
<ul>
<li>–reference=&lt;文件或者目录&gt;</li>
<li>–help 显示帮助信息</li>
<li>–version 显示版本信息<h4 id="使用示例-22"><a href="#使用示例-22" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chgrp -v bin test.log                  //改变文件的群组属性</span><br><span class="line">chgrp --reference=test.log test1.log   //改变文件test1.log 的群组属性，使得文件test1.log的群组属性和参考文件test.log的群组属性相同</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="chown-命令"><a href="#chown-命令" class="headerlink" title="chown 命令"></a>chown 命令</h3><p>通过chown改变文件的拥有者和群组。</p>
<h4 id="命令格式-22"><a href="#命令格式-22" class="headerlink" title="命令格式"></a>命令格式</h4><pre><code>chown [参数] [所有者] [:[组]] 文件
</code></pre>
<h4 id="常用参数-21"><a href="#常用参数-21" class="headerlink" title="常用参数"></a>常用参数</h4><p>必要参数:</p>
<ul>
<li>-c 显示更改的部分的信息</li>
<li>-f 忽略错误信息</li>
<li>-h 修复符号链接</li>
<li>-R 处理指定目录以及其子目录下的所有文件</li>
<li>-v 显示详细的处理信息</li>
<li>-deference 作用于符号链接的指向，而不是链接文件本身</li>
</ul>
<p>选择参数:</p>
<ul>
<li>–reference=&lt;目录或文件&gt; 把指定的目录/文件作为参考，把操作的文件/目录设置成参考文件/目录相同拥有者和群组</li>
<li>–from=&lt;当前用户：当前群组&gt; 只有当前用户和群组跟指定的用户和群组相同时才进行改变</li>
<li>–help 显示帮助信息</li>
<li>–version 显示版本信息<h4 id="使用示例-23"><a href="#使用示例-23" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chown mail:mail test.log       //改变拥有者和群组</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="磁盘存储"><a href="#磁盘存储" class="headerlink" title="磁盘存储"></a>磁盘存储</h2><h3 id="df-命令"><a href="#df-命令" class="headerlink" title="df 命令"></a>df 命令</h3><p>显示指定磁盘文件的可用空间。</p>
<h4 id="命令格式-23"><a href="#命令格式-23" class="headerlink" title="命令格式"></a>命令格式</h4><pre><code>df [参数] [文件]
</code></pre>
<h4 id="常用参数-22"><a href="#常用参数-22" class="headerlink" title="常用参数"></a>常用参数</h4><p>必要参数：</p>
<ul>
<li>-a 全部文件系统列表</li>
<li>-h 方便阅读方式显示</li>
<li>-H 等于“-h”，但是计算式，1K=1000，而不是1K=1024</li>
<li>-i 显示inode信息</li>
<li>-k 区块为1024字节</li>
<li>-l 只显示本地文件系统</li>
<li>-m 区块为1048576字节</li>
<li>–no-sync 忽略 sync 命令</li>
<li>-P 输出格式为POSIX</li>
<li>–sync 在取得磁盘信息前，先执行sync命令</li>
<li>-T 文件系统类型</li>
</ul>
<p>选择参数：</p>
<ul>
<li>–block-size=&lt;区块大小&gt; 指定区块大小</li>
<li>-t&lt;文件系统类型&gt; 只显示选定文件系统的磁盘信息</li>
<li>-x&lt;文件系统类型&gt; 不显示选定文件系统的磁盘信息</li>
<li>–help 显示帮助信息</li>
<li>–version 显示版本信息<h4 id="使用示例-24"><a href="#使用示例-24" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">df -t ext3                     //显示指定磁盘使用情况</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="du-命令"><a href="#du-命令" class="headerlink" title="du 命令"></a>du 命令</h3><p>显示每个文件和目录的磁盘使用空间。</p>
<h4 id="命令格式-24"><a href="#命令格式-24" class="headerlink" title="命令格式"></a>命令格式</h4><pre><code>du [参数] [文件]
</code></pre>
<h4 id="常用参数-23"><a href="#常用参数-23" class="headerlink" title="常用参数"></a>常用参数</h4><ul>
<li>-a或-all 显示目录中个别文件的大小。</li>
<li>-b或-bytes 显示目录或文件大小时，以byte为单位。 – -c或–total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。</li>
<li>-k或–kilobytes 以KB(1024bytes)为单位输出。</li>
<li>-m或–megabytes 以MB为单位输出。</li>
<li>-s或–summarize 仅显示总计，只列出最后加总的值。</li>
<li>-h或–human-readable 以K，M，G为单位，提高信息的可读性。</li>
<li>-x或–one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。</li>
<li>-L&lt;符号链接&gt;或–dereference&lt;符号链接&gt; 显示选项中所指定符号链接的源文件大小。</li>
<li>-S或–separate-dirs 显示个别目录的大小时，并不含其子目录的大小。</li>
<li>-X&lt;文件&gt;或–exclude-from=&lt;文件&gt; 在&lt;文件&gt;指定目录或文件。</li>
<li>–exclude=&lt;目录或文件&gt; 略过指定的目录或文件。</li>
<li>-D或–dereference-args 显示指定符号链接的源文件大小。</li>
<li>-H或–si 与-h参数相同，但是K，M，G是以1000为换算单位。</li>
<li>-l或–count-links 重复计算硬件链接的文件。<h4 id="使用示例-25"><a href="#使用示例-25" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">du test                           //显示指定目录或文件所占空间（目录）</span><br><span class="line">du test.log                       //（文件）</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="性能监控和优化命令"><a href="#性能监控和优化命令" class="headerlink" title="性能监控和优化命令"></a>性能监控和优化命令</h2><h3 id="top-命令"><a href="#top-命令" class="headerlink" title="top 命令"></a>top 命令</h3><p>显示当前系统正在执行的进程的相关信息，包括进程ID、内存占用率、CPU占用率等。</p>
<h4 id="命令格式-25"><a href="#命令格式-25" class="headerlink" title="命令格式"></a>命令格式</h4><pre><code>top [参数]
</code></pre>
<h4 id="常见参数"><a href="#常见参数" class="headerlink" title="常见参数"></a>常见参数</h4><ul>
<li>-b 批处理</li>
<li>-c 显示完整的治命令</li>
<li>-I 忽略失效过程</li>
<li>-s 保密模式</li>
<li>-S 累积模式</li>
<li>-i&lt;时间&gt; 设置间隔时间</li>
<li>-u&lt;用户名&gt; 指定用户名</li>
<li>-p&lt;进程号&gt; 指定进程</li>
<li>-n&lt;次数&gt; 循环显示的次数<h4 id="使用示例-26"><a href="#使用示例-26" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">top                        //显示进程信息。</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="free-命令"><a href="#free-命令" class="headerlink" title="free 命令"></a>free 命令</h3><p>显示系统使用和空闲的内存情况，包括物理内存、交互区内存(swap)和内核缓冲区内存。</p>
<h4 id="命令格式-26"><a href="#命令格式-26" class="headerlink" title="命令格式"></a>命令格式</h4><pre><code>free [参数]
</code></pre>
<h4 id="常见参数-1"><a href="#常见参数-1" class="headerlink" title="常见参数"></a>常见参数</h4><ul>
<li>-b  以Byte为单位显示内存使用情况</li>
<li>-k  以KB为单位显示内存使用情况</li>
<li>-m  以MB为单位显示内存使用情况</li>
<li>-g 以GB为单位显示内存使用情况</li>
<li>-o  不显示缓冲区调节列</li>
<li>-s&lt;间隔秒数&gt;  持续观察内存使用状况</li>
<li>-t  显示内存总和列。</li>
<li>-V  显示版本信息。<h4 id="使用示例-27"><a href="#使用示例-27" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">free                   //显示内存情况</span><br><span class="line">free -g                //以GB为单位</span><br><span class="line">free -m                //以MB为单位</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h3><p>用来显示虚拟内存的信息。</p>
<h4 id="命令格式-27"><a href="#命令格式-27" class="headerlink" title="命令格式"></a>命令格式</h4><ul>
<li><p>vmstat [-a] [-n] [-S unit] [delay [ count]]</p>
</li>
<li><p>vmstat [-s] [-n] [-S unit]</p>
</li>
<li><p>vmstat [-m] [-n] [delay [ count]]</p>
</li>
<li><p>vmstat [-d] [-n] [delay [ count]]</p>
</li>
<li><p>vmstat [-p disk partition] [-n] [delay [ count]]</p>
</li>
<li><p>vmstat [-f]</p>
</li>
<li><p>vmstat [-V]</p>
<h4 id="常见参数-2"><a href="#常见参数-2" class="headerlink" title="常见参数"></a>常见参数</h4></li>
<li><p>-a：显示活跃和非活跃内存</p>
</li>
<li><p>-f：显示从系统启动至今的fork数量</p>
</li>
<li><p>-m：显示slabinfo</p>
</li>
<li><p>-n：只在开始时显示一次各字段名称</p>
</li>
<li><p>-s：显示内存相关统计信息及多种系统活动数量</p>
</li>
<li><p>delay：刷新时间间隔。如果不指定，只显示一条结果</p>
</li>
<li><p>count：刷新次数。如果不指定刷新次数，但指定了刷新时间间隔，这时刷新次数为无穷</p>
</li>
<li><p>-d：显示磁盘相关统计信息</p>
</li>
<li><p>-p：显示指定磁盘分区统计信息</p>
</li>
<li><p>-S：使用指定单位显示。参数有 k 、K 、m 、M ，分别代表1000、1024、1000000、1048576字节（byte）。默认单位为K（1024 bytes）</p>
<h4 id="使用示例-28"><a href="#使用示例-28" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vmstat -a 5 5                  //显示活跃和非活跃内存（5秒时间内进行5次采样）</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="lostat-命令"><a href="#lostat-命令" class="headerlink" title="lostat 命令"></a>lostat 命令</h3><p>通过iostat方便查看CPU、网卡、tty设备、磁盘、CD-ROM 等等设备的活动情况, 负载信息。</p>
<h4 id="命令格式-28"><a href="#命令格式-28" class="headerlink" title="命令格式"></a>命令格式</h4><pre><code>iostat [参数] [时间] [次数]
</code></pre>
<h4 id="常见参数-3"><a href="#常见参数-3" class="headerlink" title="常见参数"></a>常见参数</h4><ul>
<li>-C 显示CPU使用情况</li>
<li>-d 显示磁盘使用情况</li>
<li>-k 以 KB 为单位显示</li>
<li>-m 以 M 为单位显示</li>
<li>-N 显示磁盘阵列(LVM) 信息</li>
<li>-n 显示NFS 使用情况</li>
<li>-p[磁盘] 显示磁盘和分区的情况</li>
<li>-t 显示终端和CPU的信息</li>
<li>-x 显示详细信息<h4 id="使用示例-29"><a href="#使用示例-29" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iostat 2 3                   //定时显示所有信息（每隔2秒刷新显示，且显示3次）</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="lsof-命令"><a href="#lsof-命令" class="headerlink" title="lsof 命令"></a>lsof 命令</h3><p>用于查看你进程开打的文件，打开文件的进程，进程打开的端口(TCP、UDP)。</p>
<h4 id="命令格式-29"><a href="#命令格式-29" class="headerlink" title="命令格式"></a>命令格式</h4><pre><code>lsof [参数] [文件]
</code></pre>
<h4 id="常见参数-4"><a href="#常见参数-4" class="headerlink" title="常见参数"></a>常见参数</h4><ul>
<li>-a 列出打开文件存在的进程</li>
<li>-c&lt;进程名&gt; 列出指定进程所打开的文件</li>
<li>-g 列出GID号进程详情</li>
<li>-d&lt;文件号&gt; 列出占用该文件号的进程</li>
<li>+d&lt;目录&gt; 列出目录下被打开的文件</li>
<li>+D&lt;目录&gt; 递归列出目录下被打开的文件</li>
<li>-n&lt;目录&gt; 列出使用NFS的文件</li>
<li>-i&lt;条件&gt; 列出符合条件的进程。（4、6、协议、:端口、 @ip ）</li>
<li>-p&lt;进程号&gt; 列出指定进程号所打开的文件</li>
<li>-u 列出UID号进程详情<h4 id="使用示例-30"><a href="#使用示例-30" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lsof /bin/bash                //查看谁正在使用bash文件，也就是说查找某个文件相关的进程</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="网络命令"><a href="#网络命令" class="headerlink" title="网络命令"></a>网络命令</h2><h3 id="ipconfig-命令"><a href="#ipconfig-命令" class="headerlink" title="ipconfig 命令"></a>ipconfig 命令</h3><p>ifconfig 命令用来查看和配置网络设备。</p>
<h4 id="命令格式-30"><a href="#命令格式-30" class="headerlink" title="命令格式"></a>命令格式</h4><pre><code>i**f**config [网络设备] [参数]
</code></pre>
<h4 id="常见参数-5"><a href="#常见参数-5" class="headerlink" title="常见参数"></a>常见参数</h4><ul>
<li>up 启动指定网络设备/网卡</li>
<li>down 关闭指定网络设备/网卡。</li>
<li>arp 设置指定网卡是否支持ARP协议</li>
<li>-promisc 设置是否支持网卡的promiscuous模式，如果选择此参数，网卡将接收网络中发给它所有的数据包</li>
<li>-allmulti 设置是否支持多播模式，如果选择此参数，网卡将接收网络中所有的多播数据包</li>
<li>-a 显示全部接口信息</li>
<li>-s 显示摘要信息（类似于 netstat -i）</li>
<li>add 给指定网卡配置IPv6地址</li>
<li>del 删除指定网卡的IPv6地址<h4 id="使用示例-31"><a href="#使用示例-31" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ifconfig eth0 up                              //启动指定网卡</span><br><span class="line">ifconfig eth0 down                            //关闭指定网卡</span><br><span class="line">ifconfig eth0 hw ether 00:AA:BB:CC:DD:EE      //用ifconfig修改MAC地址</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="route-命令"><a href="#route-命令" class="headerlink" title="route 命令"></a>route 命令</h3><p>Route命令是用于操作基于内核ip路由表，它的主要作用是创建一个静态路由让指定一个主机或者一个网络通过一个网络接口，如eth0。</p>
<h4 id="命令格式-31"><a href="#命令格式-31" class="headerlink" title="命令格式"></a>命令格式</h4><pre><code>route [-f] [-p] [Command [Destination] [mask Netmask] [Gateway] [metric Metric]] [if Interface]]
</code></pre>
<h4 id="常见参数-6"><a href="#常见参数-6" class="headerlink" title="常见参数"></a>常见参数</h4><ul>
<li>-c 显示更多信息</li>
<li>-n 不解析名字</li>
<li>-v 显示详细的处理信息</li>
<li>-F 显示发送信息</li>
<li>-C 显示路由缓存</li>
<li>-f 清除所有网关入口的路由表。</li>
<li>-p 与 add 命令一起使用时使路由具有永久性。</li>
<li>add:添加一条新路由。</li>
<li>del:删除一条路由。</li>
<li>-net:目标地址是一个网络。</li>
<li>-host:目标地址是一个主机。</li>
<li>netmask:当添加一个网络路由时，需要使用网络掩码。</li>
<li>gw:路由数据包通过网关。注意，你指定的网关必须能够达到。</li>
<li>metric：设置路由跳数。</li>
<li>Command 指定您想运行的命令 (Add/Change/Delete/Print)。</li>
<li>Destination 指定该路由的网络目标。<h4 id="使用示例-32"><a href="#使用示例-32" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">route                                                      //显示当前路由</span><br><span class="line">route -n                                                   //显示当前路由（不解析名字）</span><br><span class="line">route add -net 224.0.0.0 netmask 240.0.0.0 dev eth0        //添加网关/设置网关</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="ping-命令"><a href="#ping-命令" class="headerlink" title="ping 命令"></a>ping 命令</h3><p>确定网络和各外部主机的状态；跟踪和隔离硬件和软件问题；测试、评估和管理网络。</p>
<h4 id="命令格式-32"><a href="#命令格式-32" class="headerlink" title="命令格式"></a>命令格式</h4><pre><code>ping [参数] [主机名或IP地址]
</code></pre>
<h4 id="常见参数-7"><a href="#常见参数-7" class="headerlink" title="常见参数"></a>常见参数</h4><ul>
<li>-d 使用Socket的SO_DEBUG功能</li>
<li>-f 极限检测。大量且快速地送网络封包给一台机器，看它的回应</li>
<li>-n 只输出数值</li>
<li>-q 不显示任何传送封包的信息，只显示最后的结果</li>
<li>-r 忽略普通的Routing Table，直接将数据包送到远端主机上。通常是查看本机的网络接口是否有问题</li>
<li>-R 记录路由过程</li>
<li>-v 详细显示指令的执行过程</li>
<li>-c 数目：在发送指定数目的包后停止</li>
<li>-i 秒数：设定间隔几秒送一个网络封包给一台机器，预设值是一秒送一次 -I 网络界面：使用指定的网络界面送出数据包 -l 前置载入：设置在送出要求信息之前，先行发出的数据包 -p 范本样式：设置填满数据包的范本样式 -s 字节数：指定发送的数据字节数，预设值是56，加上8字节的ICMP头，一共是64ICMP数据字节 -t 存活数值：设置存活数值TTL的大小<h4 id="使用示例-33"><a href="#使用示例-33" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ping -b 192.168.120.1            //ping 网关</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="traceroute-命令"><a href="#traceroute-命令" class="headerlink" title="traceroute 命令"></a>traceroute 命令</h3><p>让你追踪网络数据包的路由途径，预设数据包大小是40Bytes，用户可另行设置。</p>
<h4 id="命令格式-33"><a href="#命令格式-33" class="headerlink" title="命令格式"></a>命令格式</h4><pre><code>traceroute [参数] [主机]
</code></pre>
<h4 id="常见参数-8"><a href="#常见参数-8" class="headerlink" title="常见参数"></a>常见参数</h4><ul>
<li>-d 使用Socket层级的排错功能</li>
<li>-f 设置第一个检测数据包的存活数值TTL的大小</li>
<li>-F 设置勿离断位</li>
<li>-g 设置来源路由网关，最多可设置8个</li>
<li>-i 使用指定的网络界面送出数据包</li>
<li>-I 使用ICMP回应取代UDP资料信息</li>
<li>-m 设置检测数据包的最大存活数值TTL的大小</li>
<li>-n 直接使用IP地址而非主机名称</li>
<li>-p 设置UDP传输协议的通信端口</li>
<li>-r 忽略普通的Routing Table，直接将数据包送到远端主机上</li>
<li>-s 设置本地主机送出数据包的IP地址</li>
<li>-t 设置检测数据包的TOS数值</li>
<li>-v 详细显示指令的执行过程</li>
<li>-w 设置等待远端主机回报的时间</li>
<li>-x 开启或关闭数据包的正确性检验<h4 id="使用示例-34"><a href="#使用示例-34" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">traceroute www.baidu.com           //traceroute 用法简单、最常用的用法</span><br><span class="line">traceroute -m 10 www.baidu.com     //跳数设置</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="netstat-命令"><a href="#netstat-命令" class="headerlink" title="netstat 命令"></a>netstat 命令</h3><p>用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。</p>
<h4 id="命令格式-34"><a href="#命令格式-34" class="headerlink" title="命令格式"></a>命令格式</h4><pre><code>netstat [-acCeFghilMnNoprstuvVwx] [-A&lt;网络类型&gt;] [--ip]
</code></pre>
<h4 id="常见参数-9"><a href="#常见参数-9" class="headerlink" title="常见参数"></a>常见参数</h4><ul>
<li>-a或–all 显示所有连线中的Socket</li>
<li>-A&lt;网络类型&gt;或–&lt;网络类型&gt; 列出该网络类型连线中的相关地址</li>
<li>-c或–continuous 持续列出网络状态</li>
<li>-C或–cache 显示路由器配置的快取信息</li>
<li>-e或–extend 显示网络其他相关信息</li>
<li>-F或–fib 显示FIB</li>
<li>-g或–groups 显示多重广播功能群组组员名单</li>
<li>-h或–help 在线帮助</li>
<li>-i或–interfaces 显示网络界面信息表单</li>
<li>-l或–listening 显示监控中的服务器的Socket</li>
<li>-M或–masquerade 显示伪装的网络连线</li>
<li>-n或–numeric 直接使用IP地址，而不通过域名服务器</li>
<li>-N或–netlink或–symbolic 显示网络硬件外围设备的符号连接名称</li>
<li>-o或–timers 显示计时器</li>
<li>-p或–programs 显示正在使用Socket的程序识别码和程序名称</li>
<li>-r或–route 显示Routing Table</li>
<li>-s或–statistice 显示网络工作信息统计表</li>
<li>-t或–tcp 显示TCP传输协议的连线状况</li>
<li>-u或–udp 显示UDP传输协议的连线状况</li>
<li>-v或–verbose 显示指令执行过程</li>
<li>-V或–version 显示版本信息</li>
<li>-w或–raw 显示RAW传输协议的连线状况</li>
<li>-x或–unix 此参数的效果和指定”-A unix”参数相同</li>
<li>–ip或–inet 此参数的效果和指定”-A inet”参数相同<h4 id="使用示例-35"><a href="#使用示例-35" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -a                //列出所有端口</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="telnet-命令"><a href="#telnet-命令" class="headerlink" title="telnet 命令"></a>telnet 命令</h3><p>执行telnet指令开启终端机阶段作业，并登入远端主机。</p>
<h4 id="命令格式-35"><a href="#命令格式-35" class="headerlink" title="命令格式"></a>命令格式</h4><pre><code>telnet [参数] [主机]
</code></pre>
<h4 id="常见参数-10"><a href="#常见参数-10" class="headerlink" title="常见参数"></a>常见参数</h4><ul>
<li>-8 允许使用8位字符资料，包括输入与输出</li>
<li>-a 尝试自动登入远端系统</li>
<li>-b&lt;主机别名&gt; 使用别名指定远端主机名称</li>
<li>-c 不读取用户专属目录里的.telnetrc文件</li>
<li>-d 启动排错模式</li>
<li>-e&lt;脱离字符&gt; 设置脱离字符</li>
<li>-E 滤除脱离字符</li>
<li>-f 此参数的效果和指定”-F”参数相同<h4 id="使用示例-36"><a href="#使用示例-36" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">telnet 192.168.120.206               //远程服务器无法访问</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><h3 id="ln-命令"><a href="#ln-命令" class="headerlink" title="ln 命令"></a>ln 命令</h3><p>为某一个文件在另外一个位置建立一个同步的链接.当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p>
<h4 id="命令格式-36"><a href="#命令格式-36" class="headerlink" title="命令格式"></a>命令格式</h4><pre><code>ln [参数] [源文件或目录] [目标文件或目录]
</code></pre>
<h4 id="常用参数-24"><a href="#常用参数-24" class="headerlink" title="常用参数"></a>常用参数</h4><p>必要参数:</p>
<ul>
<li>-b 删除，覆盖以前建立的链接</li>
<li>-d 允许超级用户制作目录的硬链接</li>
<li>-f 强制执行</li>
<li>-i 交互模式，文件存在则提示用户是否覆盖</li>
<li>-n 把符号链接视为一般目录</li>
<li>-s 软链接(符号链接)</li>
<li>-v 显示详细的处理过程</li>
</ul>
<p>选择参数:</p>
<ul>
<li>-S “-S&lt;字尾备份字符串&gt; ”或 “–suffix=&lt;字尾备份字符串&gt;”</li>
<li>-V “-V&lt;备份方式&gt;”或“–version-control=&lt;备份方式&gt;”<h4 id="使用示例-37"><a href="#使用示例-37" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln -s test.log linktest             //为 test.log文件创建软链接linktest</span><br><span class="line">ln test.log lntest                  //为 test.log创建硬链接lntest</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="diff-命令"><a href="#diff-命令" class="headerlink" title="diff 命令"></a>diff 命令</h3><p>比较单个文件或者目录内容。</p>
<h4 id="命令格式-37"><a href="#命令格式-37" class="headerlink" title="命令格式"></a>命令格式</h4><pre><code>diff [参数] [文件1或目录1] [文件2或目录2]
</code></pre>
<h4 id="常用参数-25"><a href="#常用参数-25" class="headerlink" title="常用参数"></a>常用参数</h4><ul>
<li>-c 上下文模式，显示全部内文，并标出不同之处</li>
<li>-u 统一模式，以合并的方式来显示文件内容的不同</li>
<li>-a 只会逐行比较文本文件</li>
<li>-N 在比较目录时，若文件 A 仅出现在某个目录中，预设会显示：Only in 目录。若使用 -N 参数，则 diff 会将文件 A 与一个空白的文件比较</li>
<li>-r 递归比较目录下的文件<h4 id="使用示例-38"><a href="#使用示例-38" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">diff test1.txt test2.txt               //显示 test1.txt 和 test2.txt 两个文件差异</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="grep-命令"><a href="#grep-命令" class="headerlink" title="grep 命令"></a>grep 命令</h3><p>一种强大的文本搜索工具，它能使用<strong>正则表达式</strong>搜索文本，并把匹 配的行打印出来。</p>
<h4 id="命令格式-38"><a href="#命令格式-38" class="headerlink" title="命令格式"></a>命令格式</h4><pre><code>grep [option] pattern file
</code></pre>
<h4 id="常用参数-26"><a href="#常用参数-26" class="headerlink" title="常用参数"></a>常用参数</h4><ul>
<li>-c 计算找到‘搜寻字符串’（即 pattern）的次数</li>
<li>-i 忽略大小写的不同，所以大小写视为相同</li>
<li>-n 输出行号</li>
<li>-v 反向选择，打印不匹配的行</li>
<li>-r 递归搜索</li>
<li>–color=auto 将找到的关键词部分加上颜色显示<h4 id="使用示例-39"><a href="#使用示例-39" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep &quot;root&quot; /etc/passwd --color=auto            </span><br><span class="line">cat /etc/passwd | grep &quot;root&quot; --color=auto       //将 /etc/passwd 文件中出现 root 的行取出来，关键词部分加上颜色显示</span><br><span class="line">grep -v &quot;root&quot; /etc/passwd | grep -v &quot;nologin&quot;   //将 /etc/passwd 文件中没有出现 root 和 nologin 的行取出来</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="wc-命令"><a href="#wc-命令" class="headerlink" title="wc 命令"></a>wc 命令</h3><p>用来显示文件所包含的行、字和字节数。</p>
<h4 id="命令格式-39"><a href="#命令格式-39" class="headerlink" title="命令格式"></a>命令格式</h4><pre><code>wc [参数] [文件]
</code></pre>
<h4 id="常用参数-27"><a href="#常用参数-27" class="headerlink" title="常用参数"></a>常用参数</h4><ul>
<li>-c 统计字节数</li>
<li>-l 统计行数</li>
<li>-m 统计字符数，这个标志不能与 -c 标志一起使用</li>
<li>-w 统计字数，一个字被定义为由空白、跳格或换行字符分隔的字符串</li>
<li>-L 打印最长行的长度<h4 id="使用示例-40"><a href="#使用示例-40" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wc -c test.txt             //统计文件的字节数</span><br><span class="line">wc -l test.txt             //统计文件的行数</span><br><span class="line">wc -m test.txt             //统计文件的字符数</span><br><span class="line">cat test.txt | wc -c       //统计文件的字节数只打印数字，不打印文件名</span><br><span class="line">cat test.txt | wc -l       //统计文件的行数只打印数字，不打印文件名</span><br><span class="line">cat test.txt | wc -m       //统计文件的字符数，只打印数字，不打印文件名</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="ps-命令"><a href="#ps-命令" class="headerlink" title="ps 命令"></a>ps 命令</h3><p>用来显示当前进程的状态。</p>
<h4 id="命令格式-40"><a href="#命令格式-40" class="headerlink" title="命令格式"></a>命令格式</h4><pre><code>ps [参数]
</code></pre>
<h4 id="常用参数-28"><a href="#常用参数-28" class="headerlink" title="常用参数"></a>常用参数</h4><ul>
<li>a 显示所有进程</li>
<li>-a 显示同一终端下的所有程序</li>
<li>-A 显示所有进程</li>
<li>c 显示进程的真实名称</li>
<li>-N 反向选择</li>
<li>-e 等于“-A”</li>
<li>e 显示环境变量</li>
<li>f 显示程序间的关系</li>
<li>-H 显示树状结构</li>
<li>r 显示当前终端的进程</li>
<li>T 显示当前终端的所有程序</li>
<li>u 指定用户的所有进程</li>
<li>-au 显示较详细的资讯</li>
<li>-aux 显示所有包含其他使用者的行程</li>
<li>-C&lt;命令&gt; 列出指定命令的状况</li>
<li>–lines&lt;行数&gt; 每页显示的行数</li>
<li>–width&lt;字符数&gt; 每页显示的字符数<h4 id="使用示例-41"><a href="#使用示例-41" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -A                   //显示所有进程信息</span><br><span class="line">ps -u root              //显示指定用户信息</span><br><span class="line">ps -ef                  //显示所有进程信息，连同命令行</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="watch-命令"><a href="#watch-命令" class="headerlink" title="watch 命令"></a>watch 命令</h3><p>可以将命令的输出结果输出到标准输出设备，多用于周期性执行命令/定时执行命令。</p>
<h4 id="命令格式-41"><a href="#命令格式-41" class="headerlink" title="命令格式"></a>命令格式</h4><pre><code>watch [参数] [命令]
</code></pre>
<h4 id="常用参数-29"><a href="#常用参数-29" class="headerlink" title="常用参数"></a>常用参数</h4><ul>
<li>-n或–interval watch缺省每2秒运行一下程序，可以用-n或-interval来指定间隔的时间。</li>
<li>-d或–differences 用-d或–differences 选项watch 会高亮显示变化的区域。 而-d=cumulative选项会把变动过的地方(不管最近的那次有没有变动)都高亮显示出来。</li>
<li>-t 或-no-title 会关闭watch命令在顶部的时间间隔,命令，当前时间的输出。</li>
<li>-h, –help 查看帮助文档<h4 id="使用示例-42"><a href="#使用示例-42" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">watch -n 1 -d netstat -ant               //每隔一秒高亮显示网络链接数的变化情况</span><br><span class="line">watch -n 1 -d &#x27;pstree|grep http&#x27;         //每隔一秒高亮显示http链接数的变化情况</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="at-命令"><a href="#at-命令" class="headerlink" title="at 命令"></a>at 命令</h3><p>在一个指定的时间执行一个指定任务，只能执行一次。（<strong>需开启atd进程</strong>）</p>
<h4 id="命令格式-42"><a href="#命令格式-42" class="headerlink" title="命令格式"></a>命令格式</h4><pre><code>at [参数] [时间]
</code></pre>
<h4 id="常用参数-30"><a href="#常用参数-30" class="headerlink" title="常用参数"></a>常用参数</h4><ul>
<li>-m 当指定的任务被完成之后，将给用户发送邮件，即使没有标准输出</li>
<li>-I atq的别名</li>
<li>-d atrm的别名</li>
<li>-v 显示任务将被执行的时间</li>
<li>-c 打印任务的内容到标准输出</li>
<li>-V 显示版本信息</li>
<li>-q&lt;列队&gt; 使用指定的列队</li>
<li>-f&lt;文件&gt; 从指定文件读入任务而不是从标准输入读入</li>
<li>-t&lt;时间参数&gt; 以时间参数的形式提交要运行的任务<h4 id="使用示例-43"><a href="#使用示例-43" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">at 5pm+3 days </span><br><span class="line">at&gt; /bin/ls</span><br><span class="line">at&gt; &lt;EOT&gt;                    //3天后的下午5点执行/bin/ls</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="crontab-命令"><a href="#crontab-命令" class="headerlink" title="crontab 命令"></a>crontab 命令</h3><p>在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。(需开启crond服务)</p>
<h4 id="命令格式-43"><a href="#命令格式-43" class="headerlink" title="命令格式"></a>命令格式</h4><pre><code>crontab [-u user] file 或
</code></pre>
<p>crontab [-u user] [ -e | -l | -r ]</p>
<h4 id="常用参数-31"><a href="#常用参数-31" class="headerlink" title="常用参数"></a>常用参数</h4><ul>
<li>-u user：用来设定某个用户的crontab服务，例如，“-u ixdba”表示设定ixdba用户的crontab服务，此参数一般有root用户来运行。</li>
<li>file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。</li>
<li>-e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。</li>
<li>-l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。</li>
<li>-r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。</li>
<li>-i：在删除用户的crontab文件时给确认提示。<h4 id="使用示例-44"><a href="#使用示例-44" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">crontab -l                //列出 crontab 文件</span><br><span class="line">crontab -e                //编辑crontab 文件</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Crontab-任务实例"><a href="#Crontab-任务实例" class="headerlink" title="Crontab 任务实例"></a>Crontab 任务实例</h4><p>1.每1分钟执行一次command</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* * * * * command                   //每1分钟执行一次command</span><br><span class="line">3,15 * * * * command                //每小时的第3和第15分钟执行</span><br><span class="line">3,15 8-11 * * * command             //在上午8点到11点的第3和第15分钟执行</span><br></pre></td></tr></table></figure>


<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="http://linux.vbird.org/">鸟哥的私房菜</a><br><a href="https://www.runoob.com/w3cnote/linux-common-command-2.html">Linux 常用命令学习</a></p>
]]></content>
      <categories>
        <category>工具篇</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker的使用</title>
    <url>/2019/12/21/docker%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Docker 是 Linux 虚拟化的一种封装，提供简单易用的容器使用接口。 它将应用程序与该程序的依赖，打包在一个文件里面。所以有了 Docker，就不用担心环境问题。</p>
<p>说到虚拟化，很容易想到虚拟器。Docker 和虚拟机有很大的区别，虚拟机一般是在系统上运行的另外一个系统，需要消耗大量的系统资源，而 Docker 可以理解为一个系统上的不同用户，他们都是运行的同一个系统上，性能消耗少，而且启动速度很快。</p>
<h2 id="Linux-下安装"><a href="#Linux-下安装" class="headerlink" title="Linux 下安装"></a>Linux 下安装</h2><p>这里使用的 Centos7，Docker 要求 CentOS 系统的内核版本高于 3.10，如果你的内核版本过低需要升级内核才能支持 Docker</p>
<p>注意 OpenVZ 架构的 VPS 是不支持升级内核的，KVM 是支持的，或者使用云服务器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">more /etc/centos-release # 查看centos系统版本</span><br><span class="line">uname -r # 查看内核版本</span><br></pre></td></tr></table></figure>


<p>如果没有源的话导入下官方的源就行了，<a href="https://docs.docker.com/install/linux/docker-ce/centos/">这里是官方的教程</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 卸载旧版本</span><br><span class="line">yum -y remove docker docker-common docker-selinux docker-engine</span><br><span class="line">yum update</span><br><span class="line"># 安装</span><br><span class="line">yum install docker</span><br></pre></td></tr></table></figure>


<p>安装完毕输入<code>docker version</code>查看是否安装完毕，分为客户端和服务端。</p>
<p>在安装 docker 时，默认的安装位置是<code>/var/lib/docker</code>，后面下载的镜像也是在这个位置</p>
<p>如果提示 Cannot connect to the Docker daemon 表示服务端没启动，通过<code>systemctl start docker</code>命令启动 docker</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Client:</span><br><span class="line"> Version:         1.13.1</span><br><span class="line"> API version:     1.26</span><br><span class="line"> Package version: docker-1.13.1-91.git07f3374.el7.centos.x86_64</span><br><span class="line"> Go version:      go1.10.3</span><br><span class="line"> Git commit:      07f3374/1.13.1</span><br><span class="line"> Built:           Wed Feb 13 17:10:12 2019</span><br><span class="line"> OS/Arch:         linux/amd64</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Version:         1.13.1</span><br><span class="line"> API version:     1.26 (minimum version 1.12)</span><br><span class="line"> Package version: docker-1.13.1-91.git07f3374.el7.centos.x86_64</span><br><span class="line"> Go version:      go1.10.3</span><br><span class="line"> Git commit:      07f3374/1.13.1</span><br><span class="line"> Built:           Wed Feb 13 17:10:12 2019</span><br><span class="line"> OS/Arch:         linux/amd64</span><br><span class="line"> Experimental:    false</span><br></pre></td></tr></table></figure>


<h2 id="Windows-下安装"><a href="#Windows-下安装" class="headerlink" title="Windows 下安装"></a>Windows 下安装</h2><p>有两个 Docker for Windows 和 Docker Toolbox，二者的工作原理都是在虚拟机的 Linux 环境下安装 Docker</p>
<p>Docker for Windows 使用的是 Windows 自带的 Hyper-v 虚拟技术，因此对系统的要求是 Win10 专业版</p>
<p>Docker Toolbox 则使用的是 Virtualbox，如果本机已经安装过 Virtualbox 在安装过程中可以选择不安装 Virtualbox，</p>
<p>通过 <code>docker-machine</code> 命令，可以创建一个 运行 docker 的运行环境，通过<code>docker-machine env</code>切换不同的 docker 环境。从这里也可以看到在 windows 上执行的 docker 命令其实是转发到 Linux 里面的(TCP)</p>
<p>注意 docker-machine 在创建虚拟机的过程中会去 Github 上下载最新的系统镜像，由于网路原因等待过程可能会很久，也可以自己手动去下载然后放到<code>~/.docker/machine/cache/boot2docker.iso</code>。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Docker安装目录下，在git-bash通过执行脚本创建</span></span><br><span class="line">./start.sh</span><br><span class="line"></span><br><span class="line"><span class="comment">## 也可以手动创建运行环境</span></span><br><span class="line">docker-machine create -d virtualbox default</span><br><span class="line">docker-machine start default</span><br><span class="line">docker-machine <span class="built_in">env</span> default</span><br><span class="line">docker-machine <span class="built_in">ls</span></span><br><span class="line">docker-machine ssh default</span><br></pre></td></tr></table></figure>


<p>创建完毕，<code>docker info</code> 若显示无法连接服务端，由于每次重启 IP 会变化，需要更新下 IP 到环境变量里面，再重启终端就好了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-machine restart default</span><br><span class="line">docker-machine env default # 将default机器的连接IP写到环境变量</span><br><span class="line"># 关闭终端重新进入刷新最新的环境变量，再次查看应该就成功了</span><br><span class="line">docker info</span><br></pre></td></tr></table></figure>


<h2 id="Registry-仓库"><a href="#Registry-仓库" class="headerlink" title="Registry 仓库"></a>Registry 仓库</h2><p>docker 镜像托管和 git 仓库托管是很像的，对比 GitHub ，官方的镜像仓库是<a href="https://hub.docker.com/">Docker Hub</a>，拥有大量的高质量的官方镜像，当拉取镜像时，默认使用的也是改镜像。</p>
<p>由于国内网络环境下载镜像很慢，可以通过配置仓库的镜像地址加速下载</p>
<p>Linux 环境下更改配置文件<code>/etc/docker/daemon.json</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;https://hub-mirror.c.163.com&quot;</span><span class="punctuation">,</span> <span class="string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>


<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br><span class="line">docker info <span class="comment"># Registry Mirrors</span></span><br></pre></td></tr></table></figure>


<p>Windows 的 Docker Toolbox 环境下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-machine ssh default</span><br><span class="line">sudo vi /var/lib/boot2docker/profile # linux 环境，</span><br><span class="line">docker-machine stop</span><br><span class="line">docker-machine start</span><br></pre></td></tr></table></figure>


<p>修改内容,在 EXTRA_ARGS 参数下追加<code>--registry-mirror</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXTRA_ARGS=&#x27;</span><br><span class="line">--label provider=virtualbox</span><br><span class="line">--registry-mirror https://hub-mirror.c.163.com</span><br><span class="line">--registry-mirror https://docker.mirrors.ustc.edu.cn</span><br><span class="line">&#x27;</span><br></pre></td></tr></table></figure>


<p>除了下载外，你也可以推送镜像到仓库，以阿里云的容器镜像服务为例</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker tag nginx registry.cn-hangzhou.aliyuncs.com/xxx/xxx:v1.0</span><br><span class="line">docker login --username=177****@qq.com registry.cn-hangzhou.aliyuncs.com</span><br><span class="line">docker push registry.cn-hangzhou.aliyuncs.com/xxx/xxx:v1.0</span><br></pre></td></tr></table></figure>


<h2 id="image-相关命令"><a href="#image-相关命令" class="headerlink" title="image 相关命令"></a>image 相关命令</h2><p>Docker 把应用程序及其依赖打包在 image 文件里面。</p>
<p>image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 列出本地镜像</span><br><span class="line">docker image ls</span><br><span class="line"></span><br><span class="line"># 删除镜像，若改镜像已生成容器实例，需要把所有实例删除才可以删除镜像</span><br><span class="line">docker image rm [imageName]</span><br><span class="line">docker rmi</span><br><span class="line"></span><br><span class="line"># 从远端下载镜像，比如从官方库下载hello-world项目docker image pull [域名/IP][:端口/][用户名/][项目名][:标签]</span><br><span class="line"># 除了项目名外都有默认值，下面的两条命令是等价的</span><br><span class="line">docker image pull docker.io/library/hello-world:latest</span><br><span class="line">docker image pull hello-world</span><br></pre></td></tr></table></figure>


<h2 id="container-相关命令"><a href="#container-相关命令" class="headerlink" title="container 相关命令"></a>container 相关命令</h2><p>image 文件生成的容器实例，本身也是一个文件，称为容器文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 列出本机正在运行的容器，可以得到容器 ID 进行后继操作</span><br><span class="line">docker container ls</span><br><span class="line"># 列出本机所有容器，包括终止运行的容器</span><br><span class="line">docker container ls --all</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 生成一个正在运行的容器实例,本地没有会自动执行 docker image pull</span><br><span class="line"># 运行同一个镜像每次都会生成一个新的容器</span><br><span class="line"># 如 docker container run hello-world，该应用运行完后会自动退出。有些容器不会自动终止，因为提供的是服务</span><br><span class="line"></span><br><span class="line"># --name 自定义容器名字，否则是一个随机串</span><br><span class="line"># --rm 容器停止后自动删除</span><br><span class="line"># -d 开启 Daemon 模式，后台运行</span><br><span class="line"># -p 端口映射，主机端口:容器端口</span><br><span class="line"># -v 路径映射，两边必须都是绝对路径,模式 rw,ro 主机路径:容器路径[:模式],$PWD表示当前外部主机的目录</span><br><span class="line">docker container run [imageName]</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 用来启动已经生成、已经停止运行的容器文件</span><br><span class="line">docker container start/stop/restart [containerID]</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 删除容器实例，若在运行无法删除, 需要先stop</span><br><span class="line">docker container rm [containerID]</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 强制终止容器运行，相当于向容器里面的主进程发出 SIGKILL 信号</span><br><span class="line">docker container kill [containerID]</span><br><span class="line"></span><br><span class="line"># 终止容器运行，相当于向容器里面的主进程发出 SIGTERM 信号，然后过一段时间再发出 SIGKILL 信号</span><br><span class="line"># 应用程序收到 SIGTERM 信号以后，可以自行进行收尾清理工作。</span><br><span class="line">docker container stop [containerID]</span><br></pre></td></tr></table></figure>


<p>如果需要查看容器创建时的启动命令，可以使用 inspect，不过内容太多，可以使用<code>runlike</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker container inspect 3186de74c6be</span><br><span class="line"></span><br><span class="line">pip3 install runlike</span><br><span class="line">runlike 3186de74c6be</span><br></pre></td></tr></table></figure>


<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/12924220/1620183865237-badc9a02-2367-4885-a277-ac5cd5957a1f.jpeg#clientId=u5e03a6ab-2b16-4&from=drop&id=uf7e03740&margin=%5Bobject%20Object%5D&name=runlike.jpg&originHeight=281&originWidth=733&originalType=binary&size=56741&status=done&style=none&taskId=ub505ecbb-eb95-4c38-ae33-adec91ce5a3" alt="runlike.jpg"></p>
<h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><p>使用<code>docker stats</code>命令可以方便的看出正在运行的容器的 CPU 占用等信息</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1620183858060-e12449da-d2d5-4434-83a1-e072d47aa9cd.png#clientId=u5e03a6ab-2b16-4&from=drop&id=u40c9710a&margin=%5Bobject%20Object%5D&name=docker-stats.png&originHeight=103&originWidth=917&originalType=binary&size=3817&status=done&style=none&taskId=u69d24b0c-e333-4128-b6dd-57a47bc76fb" alt="docker-stats.png"></p>
<p>使用<code>docker search [imageName]</code>用于从镜像仓库搜索可用的镜像</p>
<p>使用<code>docker cp</code>用于容器与主机之间的数据拷贝；<br>如<code>docker cp /www/site01 96f7f14e99ab:/www/</code>将 site01 目录的内容拷贝到 ID 为 96f7f14e99ab 的容器中</p>
<p>使用<code>docker search [imageName]</code>从镜像仓库搜索镜像</p>
<p>使用<code>docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</code>可以运行容器中的脚本，前提是容器正在运行；<br>它有 3 个参数可选<code>-d :分离模式: 在后台运行</code>,<code>-i :即使没有附加也保持STDIN 打开</code>,<code>-t :分配一个伪终端</code>;</p>
<p>比如<code>docker exec -it 8b57a62e9e1f bash</code>实际上是<code>/bin/bash</code>可以进入容器中中断，并可以进行交互。</p>
<p>默认一些常用软件是没有的，想要安装额外的软件可以：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install vi</span><br><span class="line">apt-get install telnet</span><br><span class="line"># ifconfig</span><br><span class="line">apt-get install net-tools</span><br></pre></td></tr></table></figure>


<p>比如<code>docker exec 8b57a62e9e1f env</code>可以查看容器的环境变量</p>
<p>使用<code>docker inspect [conatiner]</code>查看改容器的更多详细信息，比如 IPAddress 字段表示容器的 IP 地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker exec app01-mysql env</span><br><span class="line">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">HOSTNAME=6faa0da5db0c</span><br><span class="line">MYSQL_ROOT_PASSWORD=123456</span><br><span class="line">GOSU_VERSION=1.7</span><br><span class="line">MYSQL_MAJOR=8.0</span><br><span class="line">MYSQL_VERSION=8.0.15-1debian9</span><br><span class="line">HOME=/root</span><br></pre></td></tr></table></figure>


<h3 id="安装-tomcat"><a href="#安装-tomcat" class="headerlink" title="安装 tomcat"></a>安装 tomcat</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1620183870165-7f303689-4ab2-4543-a8bb-8bc544352f3f.png#clientId=u5e03a6ab-2b16-4&from=drop&id=u53b3d9f2&margin=%5Bobject%20Object%5D&name=image-tomcat.png&originHeight=296&originWidth=1309&originalType=binary&size=37075&status=done&style=none&taskId=u6142b636-f9f7-4aa5-98c2-d08b67b9136" alt="image-tomcat.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 下载镜像到本地</span><br><span class="line">docker pull tomcat</span><br><span class="line"></span><br><span class="line"># 后台运行</span><br><span class="line"># 自定义名字</span><br><span class="line"># 端口映射</span><br><span class="line"># 路径映射</span><br><span class="line">docker container run -d --name app01 -p 80:8080 -v /home/app01:/usr/local/tomcat/webapps/app01 tomcat</span><br><span class="line"></span><br><span class="line"># 上传代码到/home/app01</span><br><span class="line"></span><br><span class="line"># 重启应用</span><br><span class="line">docker container restart app01</span><br><span class="line"></span><br><span class="line"># 访问http://127.0.0.1:80/index.jsp</span><br></pre></td></tr></table></figure>


<h3 id="安装-mysql"><a href="#安装-mysql" class="headerlink" title="安装 mysql"></a>安装 mysql</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用命令搜寻镜像</span><br><span class="line">docker search mysql</span><br><span class="line">docker pull mysql</span><br><span class="line"># MYSQL_DATABASE=testdb 同时创建一个testdb的数据库</span><br><span class="line">docker run --name app02 -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -e MYSQL_DATABASE=testdb -d mysql --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci</span><br></pre></td></tr></table></figure>


<p>设置外部访问权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it app02 /bin/bash</span><br><span class="line">mysql -u root -p</span><br><span class="line">ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>


<h2 id="容器之间通信"><a href="#容器之间通信" class="headerlink" title="容器之间通信"></a>容器之间通信</h2><p>启动 docker 时，docker 进程会创建一个名为 docker0 的虚拟网桥，用于宿主机与容器之间的通信。当启动一个 docker 容器时，docker 容器将会附加到虚拟网桥上，容器内的报文通过 docker0 向外转发。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker inspect app01</span><br><span class="line">docker inspect app01</span><br><span class="line"># 宿主机通过ifconfig查看网络</span><br></pre></td></tr></table></figure>


<p>多个容器之间通过 IP 通信，缺点是容器重启后自己的 IP 会改变,link 机智很好的解决了这个问题，且可以安全的传递一些连接信息给其它的容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">删除之前创建的容器</span><br><span class="line">docker container stop app01 app02</span><br><span class="line">docker container rm app01 app02</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建mysql容器命名为app02</span><br><span class="line">docker run --name app02 -e MYSQL_ROOT_PASSWORD=123456 -e MYSQL_DATABASE=testdb -d mysql --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci</span><br><span class="line"></span><br><span class="line"># 创建tomcat容器命名为app01，并链接到app02</span><br><span class="line">docker container run -d --name app01 -p 80:8080 --link app02:app01db -v /home/app01:/usr/local/tomcat/webapps/app01 tomcat</span><br><span class="line"></span><br><span class="line"># 进入tomcat容器</span><br><span class="line">docker exec -it app01 bash</span><br><span class="line"></span><br><span class="line"># 查看系统变量，可以看到mysql容器内的一些变量</span><br><span class="line">env</span><br><span class="line"></span><br><span class="line"># 测试连通</span><br><span class="line"># 64 bytes from app01db (172.17.0.2): icmp_seq=1 ttl=64 time=0.949 ms</span><br><span class="line">ping app01db</span><br><span class="line">telnet app01db 3306</span><br></pre></td></tr></table></figure>


<p>Java 代码测试数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String JDBC_DRIVER = &quot;com.mysql.jdbc.Driver&quot;;</span><br><span class="line">String DB_URL = &quot;jdbc:mysql://app01db:3306/testdb&quot;;</span><br><span class="line">String USER = &quot;root&quot;;</span><br><span class="line">String PASS = &quot;123456&quot;;</span><br></pre></td></tr></table></figure>


<p>如果报错<code>Unable to load authentication plugin &#39;caching_sha2_password&#39;</code>表示 mysql 版本太高，jdbc 太低，问题不大，百度即可解决。但是说明已经可以访问到数据库了。</p>
<h2 id="Docker-Compose-工具"><a href="#Docker-Compose-工具" class="headerlink" title="Docker Compose 工具"></a>Docker Compose 工具</h2><p>综上，容器之间通信，命令行提供容器之间的连接信息不便于管理。</p>
<p>Docker 公司推出了 Docker Compose，可以管理多个 Docker 容器组成一个应用。你需要定义一个 YAML 格式的 compose 配置文件。默认是 docker-compose.xml，或者使用-f 命令指定配置文件</p>
<p>安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.23.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line">docker-compose --version</span><br></pre></td></tr></table></figure>


<p>新建 docker-compose.yml 文件，写入下面的内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app02:</span><br><span class="line">  image: mysql:5.7</span><br><span class="line">  environment:</span><br><span class="line">    - MYSQL_ROOT_PASSWORD=123456</span><br><span class="line">    - MYSQL_DATABASE=testdb</span><br><span class="line">app01:</span><br><span class="line">  image: tomcat</span><br><span class="line">  links:</span><br><span class="line">    - app02:app01db</span><br><span class="line">  ports:</span><br><span class="line">    - 80:8080</span><br><span class="line">  volumes:</span><br><span class="line">    - /home/app01:/usr/local/tomcat/webapps/app01</span><br></pre></td></tr></table></figure>


<p><code>docker-compose up</code>启动，或者<code>docker-compose up -d</code>在后台运行</p>
<p><code>docker-compose ps</code>产看正在运行的容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    Name                 Command             State          Ports</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">root_app01_1   catalina.sh run               Up      0.0.0.0:80-&gt;8080/tcp</span><br><span class="line">root_app02_1   docker-entrypoint.sh mysqld   Up      3306/tcp, 33060/tcp</span><br></pre></td></tr></table></figure>


<p>基本的使用就是这样…</p>
<h2 id="自定义镜像"><a href="#自定义镜像" class="headerlink" title="自定义镜像"></a>自定义镜像</h2><p>有两种方式创建属于自己的镜像</p>
<ol>
<li><p> 根据 container 生成镜像<br>进入到一个运行的容器中,比如执行一些操作如安装软件，然后再提交改变生成镜像  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker container exec -it 1a548378cf20 sh</span><br><span class="line">touch demo.txt</span><br><span class="line">exit</span><br><span class="line">docker container stop 1a548378cf20</span><br><span class="line"># docker container diff 1a548378cf20</span><br><span class="line">docker commit -m &quot;install app&quot; 1a548378cf20 customer-image:v1.0.1</span><br><span class="line">docker image ls</span><br><span class="line"># docker push customer-image:v1.0.1</span><br><span class="line"># docker run -p 10086:80 -d customer-image:v1.0.1</span><br></pre></td></tr></table></figure></li>
<li><p> 通过 Dockerfile 来生成自定义镜像<br>注意，每次的 RUN/COPY 等操作都会生成一层，为了镜像的大小可以吧多个 RUN 的命令合并成一个<br>生成镜像，注意所处的目录不要有多余的文件，因为会把当前目录临时拷贝到容器内  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM openjdk:8</span><br><span class="line"># RUN mkdir -p /work</span><br><span class="line">COPY ./demo.jar /work/demo.jar</span><br><span class="line">WORKDIR /work</span><br><span class="line">CMD [ &quot;java&quot;, &quot;-jar&quot;, &quot;demo.jar&quot; ]</span><br><span class="line">EXPOSE 80</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker image build -t spring:v1.0.0 .</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>在 Docker Toolbox 环境下，容器绑定宿主机端口后并不能通过 127.0.0.1，因为在 Docker Toolbox 环境下宿主机是虚拟机， 应使用<code>docker-machine ip default</code>去访问</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.docker.com/install/linux/docker-ce/centos/">Docker 官方文档</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html">阮一峰 - Docker 入门教程</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2018/02/docker-wordpress-tutorial.html">阮一峰 - Docker 微服务教程</a></p>
<p><a href="http://www.runoob.com/docker/docker-command-manual.html">菜鸟教程 - Docker 命令大全</a></p>
<p><a href="https://vuepress.mirror.docker-practice.com/">Docker 从入门到实践 </a></p>
<p><a href="https://hui.lu/reduce-docker-image-size/">减小 Docker 镜像体积</a></p>
]]></content>
      <categories>
        <category>服务篇</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>虚拟机</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Jekyll+GitHub博客增加第三方livere评论功能</title>
    <url>/2019/10/20/Jekyll+GitHub%E5%8D%9A%E5%AE%A2%E5%A2%9E%E5%8A%A0%E7%AC%AC%E4%B8%89%E6%96%B9livere%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>经过一番周折，终于在大佬的帮助下搭建好了一个Jekyll+GitHub的个人博客网站，但是我发现这个博客丧失了他的灵魂——没有互动，不能和别人讨论，因为每个项目每个人都会有不同的见解，不能讨论遇见的问题，对一件事情的理解就片面了很多，于是各种网站查第三方评论的接口，终于选定了livere~</p>
<p>其实有许多第三方的评论系统大概常见的的有</p>
<ul>
<li>多说：曾经较火的评论系统，网上介绍文章比较多，但已关闭，无法再用了</li>
<li>畅言，sohu旗下的，但是需要个人博客备案后才能使用，但github pages个人博客感觉备案比较难</li>
<li>友言，jiaThis旗下的，由于时http请求，github pages现在都是https了， 在https站点无法调用http请求，故也无法使用</li>
<li>网易云跟贴，曾被当作“多说”的替代品，可惜官方通报说也将在2017.08.01关闭了</li>
<li>disqus，国外比较火的评论系统，但在国内墙了，故也不考虑。</li>
<li>gitment，这个据说还可以，不过因为我权衡了一下支持的评论登录方式不够多，因此放弃了</li>
</ul>
<p><strong>至于我选livere的理由嘛，简单说一说</strong></p>
<ol>
<li>不需要翻墙，给好多想评论用户最大的方便</li>
<li>尤其可以登录国内的QQ、微信、微博等常用的社交账户，也可以支持谷歌、Facebook、Twitter、Instagram等国外的社交帐户</li>
</ol>
<h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><h3 id="申请账号"><a href="#申请账号" class="headerlink" title="申请账号"></a>申请账号</h3><p>首先去<a href="https://www.livere.com/">livere官网</a>申请账号，不需要网页域名备案，填入自己的网页域名就可以啦，顺便可以把livere账号和自己的社交账号绑定。</p>
<p>这就不用我多说了，老生常谈的内容，填个邮箱验证一下就行了，哦对了，这个给网站翻到最底下还支持中文，可以说十分友好了，对他的喜爱又多了一些</p>
<h3 id="管理后台"><a href="#管理后台" class="headerlink" title="管理后台"></a>管理后台</h3><ol>
<li> 登录之后点击右上角的管理界面，进入后台，第一次登录会出现一个弹窗，点击实行<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1620183996711-7f19f204-c308-43c2-9eb6-0e21736004cc.png#clientId=u65a48815-78c6-4&from=drop&id=uaa952cde&margin=%5Bobject%20Object%5D&name=01.png&originHeight=195&originWidth=477&originalType=binary&size=14399&status=done&style=none&taskId=u5eac85b8-6322-4c21-b385-a5bf56c78d1" alt="01.png"></li>
<li> 然后弹出窗口，填入信息提交就行了，其中的名称其实就是个备注，后期也可以修改的，网址别忘了带http的头<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1620184000724-2a54e7a8-e86c-4b40-a612-0b9ede039794.png#clientId=u65a48815-78c6-4&from=drop&id=u17bc7e68&margin=%5Bobject%20Object%5D&name=02.png&originHeight=596&originWidth=694&originalType=binary&size=40555&status=done&style=none&taskId=u13642caf-9434-4722-8259-6ea873c902a" alt="02.png"></li>
<li> 然后他会弹出来一段代码，选择<strong>一般网址</strong>就可以了（如果没弹出来也不要紧，重新登录到后台，选择<strong>代码管理</strong>），复制代码<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1620184005978-10a861c1-6d50-4977-9cea-7f83fcc10c01.png#clientId=u65a48815-78c6-4&from=drop&id=u632f5e6b&margin=%5Bobject%20Object%5D&name=03.png&originHeight=579&originWidth=977&originalType=binary&size=56199&status=done&style=none&taskId=ueb28abce-99db-43cf-a2bf-09579a8bf96" alt="03.png"></li>
<li> 然后将打开GitHub项目中的<strong>post.html</strong>，我的是在**_layout/mypost.html** </li>
<li> 将代码找到合适位置粘贴一下，一般实在文章的下面，备案信息的上面 </li>
<li> 其实到现在就结束了，不过还可以再多改一些设置，打开<strong>livere管理界面</strong>可以添加评论提醒，我感觉这个功能也相当实用，有新评论的的时候可以有邮件提醒。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1620184013694-6ceaf1c1-f81c-4f4c-9170-819be571b8f6.png#clientId=u65a48815-78c6-4&from=drop&id=u54818491&margin=%5Bobject%20Object%5D&name=04.png&originHeight=570&originWidth=985&originalType=binary&size=38978&status=done&style=none&taskId=u15fc4a43-98eb-4c56-8ed9-6f7bc843bd5" alt="04.png"></li>
<li> 最后还有个<strong>访客评论登录的设置</strong>，在这里可以更改名称以及网址，还可以选择SNS登录，我是全选上了其实可以随意的。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1620184018717-ad3f59ad-3ba7-4a48-9e75-67f5622538cf.png#clientId=u65a48815-78c6-4&from=drop&id=u5ab2d375&margin=%5Bobject%20Object%5D&name=05.png&originHeight=614&originWidth=941&originalType=binary&size=62368&status=done&style=none&taskId=ud49910fe-b4ce-472c-ba31-15271a7f583" alt="05.png"></li>
</ol>
<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>大家可以通过访问我的<a href="https://github.nanfeng.ink/">个人博客</a>去看具体的效果，可以通过快捷登录各种社交网站的账号来进行评论，包括国内的QQ，微信，微博，豆瓣，百度，人人，还有国外的Facebook，Twitter，Instagram，Google+账号等等等等，非常的丰富。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/ggabcda/article/details/77141221">在Jekyll博客添加评论系统：gitment篇</a><br><a href="https://phdluffy.com/2020/02/19/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%B7%BB%E5%8A%A0/">个人静态博客添加第三方评论系统</a><br><a href="https://blog.csdn.net/weixin_41196185/article/details/79178780">hexo+github打造个人博客系列之评论系统</a></p>
]]></content>
      <categories>
        <category>网站篇</category>
      </categories>
      <tags>
        <tag>HTML+CSS</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS下搭建Aria2</title>
    <url>/2019/10/19/CentOS%E4%B8%8B%E6%90%AD%E5%BB%BAAria2/</url>
    <content><![CDATA[<p>适用于CentOS 6.3 32位，64位替换下rpm就可以了</p>
<p>在网上找了些教程，但是CentOS的第三方软件源RepoForge已经无法访问的</p>
<p>替换为<a href="http://ftp.tu-chemnitz.de/pub/linux/dag/redhat/el6/en/i386/rpmforge/RPMS/">http://ftp.tu-chemnitz.de/pub/linux/dag/redhat/el6/en/i386/rpmforge/RPMS/</a>就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://ftp.tu-chemnitz.de/pub/linux/dag/redhat/el6/en/i386/rpmforge/RPMS/aria2-1.16.4-1.el6.rf.i686.rpm</span><br><span class="line"></span><br><span class="line">http://ftp.tu-chemnitz.de/pub/linux/dag/redhat/el6/en/i386/rpmforge/RPMS/nettle-2.2-1.el6.rf.i686.rpm</span><br><span class="line"></span><br><span class="line">http://ftp.tu-chemnitz.de/pub/linux/dag/redhat/el6/en/i386/rpmforge/RPMS/nettle-devel-2.2-1.el6.rf.i686.rpm</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -ivh aria2-1.16.4-1.el6.rf.i686.rpm</span><br></pre></td></tr></table></figure>

<p>在安装过程有可能会出现缺少 libnettle.so.4 的错误提示，先安装nettle 即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -ivh aria2-1.16.4-1.el6.rf.i686.rpm</span><br><span class="line">rpm -ivh nettle-2.2-1.el6.rf.i686.rpm</span><br><span class="line">rpm -ivh nettle-devel-2.2-1.el6.rf.i686.rpm</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>以 机器之血.Bleeding.Steelv.2017.1080p.WEB-DL.X264.AAC-国语中字-RARBT的种子为例,2GB的电影在VPS里面差不多两分钟就下载好了</p>
<p>最大化的利用VPS的高速宽带，把电影放在http服务的目录下直接观看还是挺方便的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aria2c http://111.73.45.199:8090/b1/%E6%9C%BA%E5%99%A8%E4%B9%8B%E8%A1%80.Bleeding.Steelv.2017.1080p.WEB-DL.X264.AAC-%E5%9B%BD%E8%AF%AD%E4%B8%AD%E5%AD%97-RARBT.torrent</span><br></pre></td></tr></table></figure>

<h2 id="WebUI"><a href="#WebUI" class="headerlink" title="WebUI"></a>WebUI</h2><p>使用 AriaNg，纯html/js/css 通过ajax调用aria2的rpc接口来下载文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://ariang.mayswind.net/zh_Hans/</span><br></pre></td></tr></table></figure>

<p>启动 aria2c</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aria2c --enable-rpc --rpc-listen-all=true  --disable-ipv6=true --rpc-allow-origin-all</span><br></pre></td></tr></table></figure>

<p>设置AriaNg</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://域名:6800/jsonrpc</span><br><span class="line"></span><br><span class="line">http连接，密码不填写，会提示连接成功</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>服务篇</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Aria2</tag>
      </tags>
  </entry>
  <entry>
    <title>Git日常使用</title>
    <url>/2019/10/11/git%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1620184313157-9a2517c6-fc8a-468a-8ee3-95706d2b141d.png#clientId=u9cf9f284-c66a-4&from=drop&height=386&id=u52f2617b&margin=%5Bobject%20Object%5D&name=001.png&originHeight=593&originWidth=840&originalType=binary&size=34592&status=done&style=none&taskId=u31ccfd83-2714-4972-bbb1-d69ae202d52&width=547" alt="001.png"></p>
<ul>
<li><p> 设置账号和邮箱  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;xxx&quot;</span><br><span class="line">git config --global user.email &quot;xx@xx.com&quot;</span><br></pre></td></tr></table></figure></li>
<li><p> <code>git init</code><br>在当前目录创建一个版本库 </p>
</li>
<li><p> <code>git add &lt;path&gt;</code><br>主要用于把我们要提交的文件的信息添加到暂存区（stage）中，当我们使用<code>git commit</code>时，git将依暂存区中的内容来进行文件的提交 </p>
</li>
<li><p> <code>git commit</code><br>把修改（暂存区）提交到版本库中。一般使用 <code>git commit -m &quot;message&quot;</code>。如果你的文件之前已经提交过，但这次的改动还没有进stage，可以使用<code>git commit -am &quot;message&quot;</code>和先add再commit的效果一样 </p>
</li>
<li><p> <code>git log</code><br>查看HEAD指向的分支的log，<code>--pretty=oneline</code>简略查看 </p>
</li>
<li><p> <code>git reflog</code><br>可以查看所有分支的所有操作记录 </p>
</li>
<li><p><code>git reset</code><br>在本地仓库中回退到某个commit </p>
<ol>
<li> <code>git reset –mixed</code><br>此为默认方式，不带任何参数的<code>git reset</code>，即时这种方式，它回退到某个版本，只保留源码，回退commit和index信息 </li>
<li> <code>git reset –soft</code><br>回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit即可 </li>
<li> <code>git reset –hard</code><br>彻底回退到某个版本，本地的源码也会变为上一个版本的内容 </li>
</ol>
</li>
<li><p> <code>git checkout</code><br>把文件在工作区的修改全部撤销，这里有两种情况：<br>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；<br>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 </p>
</li>
<li><p> git rm<br>从版本库删除文件 </p>
</li>
<li><p> <code>git clone &lt;url&gt;</code><br>从远程仓库克隆一个项目<br>一次 Git 克隆会建立你自己的本地分支 master 和远程分支 origin/master，并且将它们都指向 origin 上的 master 分支。 </p>
</li>
<li><p> <code>git remote add origin &lt;url&gt;</code><br>把本地项目与远程项目关联 </p>
</li>
<li><p> <code>git push origin master</code><br>把本地master分支推动到远端的origin（相当于本地的HEAD） </p>
</li>
<li><p> <code>git pull</code><br>从远端抓取并试图合并 </p>
</li>
<li><p> <code>git branch &lt;name&gt;</code><br>创建一个分支 </p>
</li>
<li><p> <code>git checkout &lt;name&gt;</code><br>切换到某个分支，<code>git checkout -b &lt;name&gt;</code> 创建同时切换到分支 </p>
</li>
<li><p> <code>git branch</code><br>列出所有分支，当前分支前面会标一个*号 </p>
</li>
<li><p> <code>git merge &lt;name&gt;</code><br>把某个分支合并到当前分支,默认是快速合并,有时候要解决冲突<br>Git 默认使用快进式合并（fast-farward merge），只是将 master 分支指针指向 bugfix-0.1分支，而使用<code>git merge --no-ff name</code>了则会创建一条合并日志，保证分支删除时不丢失历史日志<br>对应的tortoisegit合并分支选项是非Fast Forword </p>
</li>
<li><p> <code>git branch -d branchName</code><br>删除分支，有时候完成合并后，不需要了就可以删除了因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。 </p>
</li>
<li><p> <code>git tag tagName</code><br>创建标签，默认标签是打在最新提交的commit上的 </p>
</li>
<li><p> <code>git tag -d tagName</code><br>删除标签 </p>
</li>
<li><p> <code>git push origin v1.0</code><br>推送标签 </p>
</li>
</ul>
<h2 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h2><ul>
<li> 主分支Master<br>首先，代码库应该有一个、且仅有一个主分支。所有提供给用户使用的正式版本，都在这个主分支上发布。<br>Git主分支的名字，默认叫做Master。它是自动建立的，版本库初始化以后，默认就是在主分支在进行开发。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1620184332111-0764ba9a-22bf-4213-b25c-570d1cc70ebd.png#clientId=u9cf9f284-c66a-4&from=drop&height=418&id=u63ddd483&margin=%5Bobject%20Object%5D&name=002.png&originHeight=600&originWidth=300&originalType=binary&size=5536&status=done&style=none&taskId=u5c4dcff2-7aae-4a28-b138-c6e618d551b&width=209" alt="002.png"></li>
<li> 开发分支Develop<br>主分支只用来分布重大版本，日常开发应该在另一条分支上完成。我们把开发用的分支，叫做Develop。<br>如果想正式对外发布，就在Master分支上，对Develop分支进行”合并”（merge）<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1620184339147-f158d98b-7d1a-441a-94c3-6aba56120609.png#clientId=u9cf9f284-c66a-4&from=drop&height=361&id=u39bc672c&margin=%5Bobject%20Object%5D&name=003.png&originHeight=553&originWidth=500&originalType=binary&size=8980&status=done&style=none&taskId=ubf26930c-da03-48d2-9bf5-72cef5c76f0&width=326" alt="003.png"></li>
<li>临时性分支<br>用于日常开发 <ul>
<li> 功能（feature）分支<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1620184349876-e7f5b658-263e-4f3a-8966-c7656edc3f3d.png#clientId=u9cf9f284-c66a-4&from=drop&height=331&id=ud7262132&margin=%5Bobject%20Object%5D&name=004.png&originHeight=727&originWidth=400&originalType=binary&size=9176&status=done&style=none&taskId=u78f8c7a7-a9b3-4b5e-b9dd-0479dc119d8&width=182" alt="004.png"></li>
<li> 预发布（release）分支 </li>
<li> 修补bug（fixbug）分支<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1620184359477-e77524c3-8ecc-425a-8677-d8984ea82267.png#clientId=u9cf9f284-c66a-4&from=drop&height=259&id=u38011011&margin=%5Bobject%20Object%5D&name=005.png&originHeight=427&originWidth=500&originalType=binary&size=8324&status=done&style=none&taskId=u68d4b1f6-2b28-4f53-b589-6aa12e91229&width=303" alt="005.png"></li>
</ul>
</li>
</ul>
<h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><h3 id="配置ss登陆"><a href="#配置ss登陆" class="headerlink" title="配置ss登陆"></a>配置ss登陆</h3><p><a href="http://blog.tmaize.net/posts/2017/07/22/github%E9%85%8D%E7%BD%AEssh%E7%99%BB%E9%99%86.html">配置ss登陆</a></p>
<h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><p>有三种方法</p>
<ol>
<li> 把别人的公钥加到你项目的公钥 </li>
<li> 建一个组织，这样组织中的所有人都有提交权限 </li>
<li> 别人fork你的项目，然后给你发 pull request </li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">廖雪峰Git教程</a><br><a href="http://www.ruanyifeng.com/blog/2012/07/git.html">阮一峰Git分支管理策略</a></p>
]]></content>
      <categories>
        <category>工具篇</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Sakurafrp实现远程桌面控制</title>
    <url>/2019/08/24/%E4%BD%BF%E7%94%A8Sakurafrp%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于平时学习的需要，经常是要用到工位的电脑，再加上我自己的电脑也不太好使，毕竟是五六年前的电脑了，运行速度可见一斑。于是我便搞起了远程控制。</p>
<h2 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h2><p>首先要交代一下我的环境，我平时在宿舍有一台运行很慢的电脑，工位有一台配置还算不错的，我想要在宿舍控制工位的电脑，跑一些程序啥的。<br>而我面临的问题主要是，工位的电脑他并<strong>没有公网ip</strong>，我无法直接访问，其实这种修改一下学校路由器的配置做一个端口映射也是完全可以的，但是显然对于学生而言，技术上可以实现但在管理上应该是不允许的。我自己家里的电脑我可以修改我们家的路由器，但前提是我家路由器拨号访问的网络得到的是公网ip。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>那话说回来，既然无法修改路由器配置，那就只能另寻出路了，一般想的是内网穿透技术，这方面做的比较有名的大概是<strong>花生壳、向日葵</strong>了，我前两年确实用过向日葵，不过他的免费流量实在太慢了而且又少于是就放弃了。后来经过辗转寻找终于找到了<a href="https://www.natfrp.com/">sakurafrp</a>，我当时用的时候还不需要实名认证，也不需要花钱，但现在好像要交一个实名认证费，我也忘了多少钱了，反正不多。他家的服务确实还不错，免费的流量对于我这种并不是时时刻刻都需要远程的人来说够用了，而且速度比较靠谱。</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>其实实现原理也比较简单，我说的不专业一点，就是你的被控电脑上面一直运行一个服务，时不时的告诉sakuraftp的服务器我在哪哪哪（地址+端口号），然后你拿着另一台电脑也就直接访问这个地址就能实现远程控制了。当然我这说的省去了太多中间的步骤，咱也不不是计算机网络专业的，还是以实用为主。</p>
<h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><p>下面来讲一下具体操作吧。</p>
<h3 id="服务创建"><a href="#服务创建" class="headerlink" title="服务创建"></a>服务创建</h3><ul>
<li>首先登录<a href="https://www.natfrp.com/">sakurafrp</a>官网，注册账号并登录。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619245193488-00ec3aa2-78a9-4362-a714-46f79d0fdccc.png#clientId=ub6d9ab8a-83de-4&from=paste&height=318&id=u8f730d83&margin=%5Bobject%20Object%5D&originHeight=635&originWidth=1556&originalType=url&status=done&style=none&taskId=uc9c59ba5-6e4e-48dc-8d25-787dcd78531&width=778"></p>
<ul>
<li>进行实名认证</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619245294761-00440676-4e1c-4e52-9994-99489e909065.png#clientId=ub6d9ab8a-83de-4&from=paste&height=192&id=uc214f70f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=383&originWidth=1551&originalType=binary&size=102880&status=done&style=none&taskId=ua30d8c60-eb58-46d8-91eb-7155999e02e&width=775.5" alt="image.png"></p>
<ul>
<li>认证之后,选择左边的创建隧道,创建一个新的隧道</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619245399782-00d78fa2-2b86-42af-8569-87b0d2d5ca3a.png#clientId=ub6d9ab8a-83de-4&from=paste&height=410&id=uc3191b66&margin=%5Bobject%20Object%5D&name=image.png&originHeight=819&originWidth=423&originalType=binary&size=60733&status=done&style=none&taskId=u96c93c04-2ce0-4662-85f1-17eafeea9cd&width=211.5" alt="image.png"></p>
<ul>
<li>这里可以看到,Sakurafrp 选择TCP隧道类型,注意本地端口要自己填3389，这是Windows远程桌面服务的默认端口,远程端口可选可不选，自己选容易和其他的用户数字冲突，可能要多试几个端口,直到成功为止.</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619245556746-2a9f696b-b8a6-4975-b09d-3e4740000ae3.png#clientId=ub6d9ab8a-83de-4&from=paste&height=344&id=ub1e161cc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=688&originWidth=1047&originalType=binary&size=73608&status=done&style=none&taskId=u6083aa89-52a6-4ec5-ab22-34cad746235&width=523.5" alt="image.png"></p>
<h3 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h3><ul>
<li>首先在工位电脑（也就是被控制的电脑）下载Sakurafrp客户端，点击网站左侧的软件下载，选上面的启动器就可以。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619245859345-71d1dc38-0f4f-4abf-b8e2-c2927cd2283d.png#clientId=ub6d9ab8a-83de-4&from=paste&height=367&id=u7a462974&margin=%5Bobject%20Object%5D&name=image.png&originHeight=733&originWidth=1695&originalType=binary&size=151387&status=done&style=none&taskId=u0ebd7232-7c44-4494-a613-5c3bdd7ccae&width=847.5" alt="image.png"></p>
<h3 id="本地配置"><a href="#本地配置" class="headerlink" title="本地配置"></a>本地配置</h3><p>运行Sakurafrp客户端的方法有4种</p>
<ul>
<li>方法一</li>
</ul>
<p>直接双击下载的Sakurafrp,输入账号和密码,再输入服务器ID,选择合适自己的服务器<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619245988118-66e8765c-e3fd-4ebd-a36a-dd003581c310.png#clientId=ub6d9ab8a-83de-4&from=paste&height=481&id=u692e687a&margin=%5Bobject%20Object%5D&originHeight=961&originWidth=1398&originalType=url&status=done&style=none&taskId=u5eb04b8f-86c7-439a-8d07-b0488fd1188&width=699"><br>就已经内网穿透成功了,其他电脑打开微软远程桌面（快捷键Win+R，输入mstsc）,或者手机安装微软远程桌面app,电脑ip地址位置输入<code>服务器地址+远程端口号</code>点击连接，然后输入你的Windows账号密码就可以（这里注意如果是用的微软账号的自然是邮箱+密码【注意不是pin码】，一般的本地账户的就要查看一下自己的用户名了）。<br>例如台湾的百兆服务器就在远程桌面app地址栏输入<code>s21.natfrp.org:10010</code></p>
<ul>
<li>方法二</li>
</ul>
<p>亦可以直接运行那个软件，在软件中选择配置，需要输入本地的ip，然后一直在后台挂着软件。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/12924220/1619246816274-cf1bd091-5c7c-4d8f-9d08-e5a279742869.png#clientId=ub6d9ab8a-83de-4&from=paste&height=308&id=u7c561713&margin=%5Bobject%20Object%5D&name=image.png&originHeight=615&originWidth=975&originalType=binary&size=239570&status=done&style=none&taskId=u049d569c-c4da-4cc7-9d19-b304d3ca729&width=487.5" alt="image.png"></p>
<ul>
<li>方法三</li>
</ul>
<p>在powershell等终端软件中打开Sakurafrp,这种方法可以免去每次手动输入账户名,密码,服务器ID.只要在Sakurafrp客户端所在的文件夹中,按住Shift键,选择打开powershell,然后在powershell中输入:<br><code>./Sakura_frpc_Windows_amd64.exe --su=&quot;你的用户名&quot; --sp=&quot;你的密码&quot; --sid=&quot;服务器ID&quot;</code></p>
<p>即可自动登录并且选择服务器.（我个人不太推荐这种方式，不太可视化，对于新手不友好）</p>
<ul>
<li>方法四</li>
</ul>
<p>开机自启动Sakurafrp.虽然上面三种方法可以使用,但是会在任务栏上显示出来,而且软件不能关闭,只要关闭就会断掉,所以第四种方法是将Sakurafrp放在后台,自动开机启动.<br>首先在Sakurafrp所在的文件夹新建一个批处理文件,命名为:<code>Sakura_frpc.bat</code><br>，这是一种相当于Windows的脚本文件吧，能代替你自动执行一些重复的操作。<br>右键该文件,选择编辑,输入:<code>Sakura_frpc_Windows_amd64.exe --su=&quot;你的用户名&quot; --sp=&quot;你的密码&quot; --sid=&quot;服务器ID&quot; </code>然后保存。<br>再在Sakurafrp所在的文件夹新建一个文本文件,命名为:<code>Sakura_frpc.vbs</code><br>右键该文件,选择编辑,输入下面代码并且保存</p>
<figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> ws=WScript.CreateObject(<span class="string">&quot;WScript.Shell&quot;</span>)</span><br><span class="line">ws.Run <span class="string">&quot;Sakura_frpc.bat /start&quot;</span>,<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>这时,我们只要双击这个Sakura_frpc.vbs,软件就会在后台启动了,在任务栏是看不到的,但是在任务管理器中能够看到.<br>此时,我们右键Sakura_frpc.vbs,选择创建快捷方式，然后键盘Win+R键,输入<code>shell:startup</code><br>打开开机启动文件夹,把快捷方式放进去.<br>Sakurafrp就已经能够开机启动了.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本来我用公云，花生壳一类的工具，但是实在是无奈于他们的速度，无意间发现了Sakurafrp，没想到Sakurafrp竟然这么良心,免费提供服务器给别人使用，所以我必须在这里由衷的感谢Sakurafrp,</p>
]]></content>
      <categories>
        <category>服务篇</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Frp</tag>
      </tags>
  </entry>
  <entry>
    <title>实用小工具分享</title>
    <url>/2019/06/11/%E5%AE%9E%E7%94%A8%E5%B0%8F%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>用了这么多年电脑，多多少少也攒了一些好用的软件，所谓独乐乐不如众乐乐，今天把这些软件写道博客里，给大家分享一下，这一篇博客啥时候我想起来了就更新一下。ps：小的软件我直接就分享了，大的会用百度云，虽然我自己有私人云盘，但是考虑到可能会被百度等搜索引擎收录，我幼小的服务器不想暴露出去。</p>
<h2 id="破解工具"><a href="#破解工具" class="headerlink" title="破解工具"></a>破解工具</h2><h3 id="KMS激活工具（需安装）"><a href="#KMS激活工具（需安装）" class="headerlink" title="KMS激活工具（需安装）"></a>KMS激活工具（需安装）</h3><ul>
<li>可以破解Windows、Office的产品，需要安装但特别方便</li>
</ul>
<p><a href="https://www.yuque.com/attachments/yuque/0/2021/zip/12924220/1618635790320-d47155f2-272f-4248-bf02-d4763aef5551.zip?_lake_card=%7B%22src%22:%22https://www.yuque.com/attachments/yuque/0/2021/zip/12924220/1618635790320-d47155f2-272f-4248-bf02-d4763aef5551.zip%22,%22name%22:%22KMSpico_Install.zip%22,%22size%22:3195353,%22type%22:%22application/x-zip-compressed%22,%22ext%22:%22zip%22,%22status%22:%22done%22,%22taskId%22:%22ub98eb439-7c57-4cc4-94df-0104449a924%22,%22taskType%22:%22upload%22,%22id%22:%22ucdfc0ab4%22,%22card%22:%22file%22%7D">KMSpico_Install.zip</a></p>
<h3 id="KMS激活工具（免安装）"><a href="#KMS激活工具（免安装）" class="headerlink" title="KMS激活工具（免安装）"></a>KMS激活工具（免安装）</h3><ul>
<li>可以破解Windows、Office的产品</li>
</ul>
<p><a href="https://www.yuque.com/attachments/yuque/0/2021/zip/12924220/1618635870289-2d49b59f-681c-4f39-a0b5-efda5e5101c2.zip?_lake_card=%7B%22src%22:%22https://www.yuque.com/attachments/yuque/0/2021/zip/12924220/1618635870289-2d49b59f-681c-4f39-a0b5-efda5e5101c2.zip%22,%22name%22:%22%E7%A0%B4%E8%A7%A3%E6%96%87%E4%BB%B6.zip%22,%22size%22:3298445,%22type%22:%22application/x-zip-compressed%22,%22ext%22:%22zip%22,%22status%22:%22done%22,%22taskId%22:%22uae63359b-8930-4af6-a884-70f28fd84c8%22,%22taskType%22:%22upload%22,%22id%22:%22u18a7ab87%22,%22card%22:%22file%22%7D">破解文件.zip</a></p>
<h2 id="VPN连接工具"><a href="#VPN连接工具" class="headerlink" title="VPN连接工具"></a>VPN连接工具</h2><ul>
<li>也是现在高校经常使用的VPN连接工具，前提是学校服务器要配置好VPN服务，总之是个不错的小工具</li>
</ul>
<p><a href="https://www.yuque.com/attachments/yuque/0/2021/rar/12924220/1618636052983-8cd73da2-9f84-44cc-b0f7-af98a5aec5f5.rar?_lake_card=%7B%22src%22:%22https://www.yuque.com/attachments/yuque/0/2021/rar/12924220/1618636052983-8cd73da2-9f84-44cc-b0f7-af98a5aec5f5.rar%22,%22name%22:%22EasyConnectInstaller.rar%22,%22size%22:27695219,%22type%22:%22%22,%22ext%22:%22rar%22,%22status%22:%22done%22,%22taskId%22:%22u5674d5b6-2fe4-4411-a79e-dd0aa1f3b38%22,%22taskType%22:%22upload%22,%22id%22:%22u423a9088%22,%22card%22:%22file%22%7D">EasyConnectInstaller.rar</a></p>
<h2 id="下载工具"><a href="#下载工具" class="headerlink" title="下载工具"></a>下载工具</h2><ul>
<li>老牌下载工具之王IDM下载器，可以实现多线程下载，下载速度超快，配合浏览器插件使用，可以强力抓取。</li>
<li>但由于版权问题，破解版<strong>不能更新！不能更新！不能更新！每次更新的时候要点取消</strong></li>
</ul>
<p><a href="https://www.yuque.com/attachments/yuque/0/2021/zip/12924220/1618636362331-b26b292e-512d-48cc-9ac8-747cd9cfc43e.zip?_lake_card=%7B%22src%22:%22https://www.yuque.com/attachments/yuque/0/2021/zip/12924220/1618636362331-b26b292e-512d-48cc-9ac8-747cd9cfc43e.zip%22,%22name%22:%22IDM_6.37.9_2.zip%22,%22size%22:15490524,%22type%22:%22application/x-zip-compressed%22,%22ext%22:%22zip%22,%22status%22:%22done%22,%22taskId%22:%22u8eafd429-1896-4a93-8580-67117af5cc7%22,%22taskType%22:%22upload%22,%22id%22:%22ucfa73a7a%22,%22card%22:%22file%22%7D">IDM_6.37.9_2.zip</a></p>
<h2 id="解压工具"><a href="#解压工具" class="headerlink" title="解压工具"></a>解压工具</h2><ul>
<li>用了好多年的解压工具，但感觉WinRAR依然还是最好用的，功能多，软件体积小，除了有个广告，不过配合火绒的广告弹窗拦截功能还是可以接受的。</li>
<li>因为上传限制只能上传压缩包格式，其实是个自解压文件（.exe），下载之后，把后缀.zip删掉就可以了</li>
</ul>
<p><a href="https://www.yuque.com/attachments/yuque/0/2021/zip/12924220/1618636532267-459f4ebb-84b1-44fc-ae5f-e9d2e4500902.zip?_lake_card=%7B%22src%22:%22https://www.yuque.com/attachments/yuque/0/2021/zip/12924220/1618636532267-459f4ebb-84b1-44fc-ae5f-e9d2e4500902.zip%22,%22name%22:%22winrar-x64-580sc.exe.zip%22,%22size%22:3328072,%22type%22:%22application/x-zip-compressed%22,%22ext%22:%22zip%22,%22status%22:%22done%22,%22taskId%22:%22u02fca7db-c617-46f9-86e1-24aedf664c3%22,%22taskType%22:%22upload%22,%22id%22:%22u17ea4c34%22,%22card%22:%22file%22%7D">winrar-x64-580sc.exe.zip</a></p>
<h2 id="OCR文字识别工具"><a href="#OCR文字识别工具" class="headerlink" title="OCR文字识别工具"></a>OCR文字识别工具</h2><ul>
<li>F4截图识别，如果一次没事别出来就再识别一次，对于许多无法复制的文字可以使用，强力的文字提取工具</li>
</ul>
<p><a href="https://www.yuque.com/attachments/yuque/0/2021/rar/12924220/1618635619040-e2071db1-e68d-428d-81ea-1e2477506b31.rar?_lake_card=%7B%22src%22:%22https://www.yuque.com/attachments/yuque/0/2021/rar/12924220/1618635619040-e2071db1-e68d-428d-81ea-1e2477506b31.rar%22,%22name%22:%22%E5%A4%A9%E8%8B%A5%E6%96%87%E5%AD%97%E8%AF%86%E5%88%AB.rar%22,%22size%22:1948356,%22type%22:%22%22,%22ext%22:%22rar%22,%22status%22:%22done%22,%22taskId%22:%22u98f6cdae-2593-464e-a9c0-efd1f5d8c08%22,%22taskType%22:%22upload%22,%22id%22:%22u7b29fb05%22,%22card%22:%22file%22%7D">天若文字识别.rar</a></p>
]]></content>
      <categories>
        <category>工具篇</category>
      </categories>
      <tags>
        <tag>破解</tag>
      </tags>
  </entry>
</search>
